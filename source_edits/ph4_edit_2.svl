#svl
//
//	ph4_edit.svl	Pharmacophore query editor
//
//	16-sep-2017 (mk) adjust to list key navigation
//	21-jul-2017 (mk) add ph4 Fileprompt auto extension 
//	09-jun-2017 (ms) don't timeout when Warning before panel loaded
//	09-jun-2017 (ms) don't complain when loading matchsize=-Inf etc
//	08-jun-2017 (ms) more "Search:" msgs ("<3 features" etc)
//	01-jun-2017 (ms) extend p.match shortcut if >99 features
//	01-jun-2017 (ms) allow AtLeast 0; display "Full match" hint etc
//	19-jul-2016 (hf) added gz to fsb
//	20-jun-2016 (ms) coments; explicit EBIT_* consts, better sel.vol.types
//	25-may-2016 (ms) blue "Comment" text if comment not empty
//	12-feb-2016 (ms) chg saveAs filterList to "Pharmacophores (*.ph4)"
//	01-dec-2015 (mk) fixes UI scaling
//	30-nov-2015 (mk) split groups by cTagId instead of cTag
//	17-nov-2015 (ms) disable FilePrompt at startup
//	27-sep-2015 (mk) scalable icon sweep
//	14-aug-2014 (ms) "Cancel" in color restores the original colors
//	06-jan-2014 (ms) bugfix: missing "first" in token first SEARCH_fn
//	16-oct-2013 (ms) bugfix: eD_R_set on same values, hidden+chg rtype
//	11-oct-2013 (ms) partially empty que.labels (e.g. with volumes)
//	10-oct-2013 (ms) moved "Q" to the top (see QUE_BUTTON_ON_TOP)
//	10-oct-2013 (ms) fixed title update for Open/Save (new triggers)
//	10-oct-2013 (ms) hide sphere vs. text: rm QUE_render, disable text gbits
//	10-oct-2013 (ms) square "+V", "D", "=", force q.render on load
//	09-oct-2013 (ms) partial match problems with empty/non-EHT queries etc
//	08-oct-2013 (ms) partial match size (msize_3to1/1to3)
//	08-oct-2013 (ms) monitor changes & errors in texfields (tval_*)
//	08-oct-2013 (ms) better dyn.update of search panel (rscore count etc.)
//	08-oct-2013 (ms) eye3.ico->eye.ico, 'Q' dimming states
//	08-oct-2013 (ms) remember last search db fn
//	01-oct-2013 (ms) render popup with 2 features + union (select vs unpack)
//	01-oct-2013 (ms) fix lowering of mval when receptor rval too low
//	26-sep-2013 (ms) big rewrite: new interface, undo, clustering etc
//	29-jul-2013 (ms) EHT strength, new graphics controls etc
//	29-jan-2013 (ms) chg iadd to add to accomodate double wkey
//	26-oct-2012 (ms) delete is baseRed, c.lines show only if >0 endpt shown
//	12-oct-2012 (ms) added filterList/Index to FilePrompt calls
//	06-sep-2012 (al) set gobject class
//	06-sep-2012 (mk) color fixes
//	14-dec-2011 (ms) BMODE controls bump check on rec/lig
//	11-nov-2011 (ms) fixed VOWL in dd_shown: atom visibility of unions
//	10-nov-2011 (ms) update
//	10-nov-2011 (ms) Use Hs and LPs
//	07-nov-2011 (ms) smarter annotation of new features
//	07-nov-2011 (ms) added solvent annotation, fixed var. update issues
//	20-oct-2011 (ms) fixed oReparent VOWL in ensure_lig_dummies
//	07-oct-2011 (ms) RLS buttons (temp. test)
//	03-oct-2011 (ms) fixed VOWL in atom selection sync (misplaced line)
//	01-may-2011 (ms) new annotation widgets with receptor annotation
//	10-nov-2009 (ms) adjust vertical offset of overlapping ann.pts (YOFS)
//	30-oct-2009 (ah) typo resolution
//	30-oct-2009 (ms) fixed bugs in consensus and proj.vectors
//	29-oct-2009 (ms) always use the main system (SystemCurrent 0)
//	16-sep-2009 (ms) main does not return until window is created
//	13-jul-2009 (ms) allowed no-feature queries in qdata_OK
//	28-jan-2009 (ms) changed rules of feature expressions: Any vs. AtomQ
//	27-jan-2009 (ms) hide projected vectors when LIG_render=0
//	21-jan-2009 (ms) display non-default labels found by consensus
//	15-jan-2009 (ms) changed name of info panel
//	30-sep-2008 (ms) show projected constraints and proj.annot.vectors
//	29-sep-2008 (ms) prefixed chain names with "[PRIVATE]"
//	31-aug-2008 (ms) ph4_EditorGet/SetData
//	15-jul-2008 (ms) window_wait monitor_id must be a token
//	28-jan-2008 (ms) use ph4_SchemeList for default scheme
//	08-nov-2007 (ms) multiple OEB fiels OK in FilePrompt
//	07-nov-2007 (ms) OEB files OK for ph4 search FilePrompt
//	12-sep-2007 (ms) consensus uses info bits (CONS_USE_INFO_BITS)
//	10-sep-2007 (ms) removed ph4field from the consensus panel
//	07-sep-2007 (ms) collected consensus utilities from ph4_util.svl
//	05-aug-2007 (ms) fixed unwanted auto-selection of same-pos features
//	30-aug-2007 (ms) groups of nearby dummies (label, select, autotype)
//	29-aug-2007 (ms) render buried annotation features as points
//	02-aug-2007 (ms) replaced all ph4 annotation and matching calls
//	27-jun-2007 (ms) toggle on/off annotation visibility
//	15-jun-2007 (ms) sped up annotation update on system topology change
//	09-apr-2007 (ms) changed to from ph4_Eval... to ph4_QueryMatch_...
//	23-feb-2007 (ms) same-atom constraint
//	23-feb-2007 (ms) modified ph4_eval allows SMARTS in feature expr.
//	25-jul-2005 (ms) change constraints when moving features up/down
//	21-jul-2005 (ms) no warning when isspace(filename)
//	20-jul-2005 (ms) res.limit for annotation + timeout for matching
//	20-jul-2005 (ms) dropped Met for auto-expr
//	20-jul-2005 (ms) explicit numerical values for feature types
//	27-jun-2005 (ms) allow qdata and filehandle input
//	26-feb-2004 (ms) check for stale handle in task_getenv 'DB_VIEW'
//	19-feb-2004 (ms) file checking in FilePrompt (Open ph4, Consensus db)
//	16-feb-2004 (ms) replaced oValid with oType
//	12-feb-2004 (ms) fixed initialization problems (avoid WT widget update)
//	05-feb-2004 (ms) indicator of query matching annotated chains
//	16-jan-2004 (ms) ph4_search starts with FilePrompt in 'multi' mode
//	29-apr-2003 (ms) modified range of feature radius wheel to 0-100
//	15-jan-2003 (ms) bugfixes
//	29-nov-2002 (ms) added ph4 consensus
//	12-nov-2002 (ms) use ph4_ExprCheckSyntax and ph4_ExprAtomMask
//	05-nov-2002 (ms) annotate visible atoms only; avoid redrawing spheres
//	29-oct-2002 (ms) rewrote rendering panel and sphere generation
//	22-oct-2002 (ms) rewrote most of the code to include unions etc.
//	10-sep-2002 (ms) experimental xvolumes (doMulti)
//	03-may-2002 (ms) bug fixes/requests
//	25-apr-2002 (ms) bug fixes
//	28-mar-2002 (ms) beta
//	20-feb-2002 (ms) alpha3
//	05-feb-2002 (ms) alpha2
//	25-jan-2002 (ms) alpha
//	27-sep-2001 (ms) created
//
// COPYRIGHT (C) 2004-2017 CHEMICAL COMPUTING GROUP ULC ("CCG").
// ALL RIGHTS RESERVED.
//
// PERMISSION TO USE, COPY, MODIFY AND DISTRIBUTE THIS SOFTWARE IS HEREBY
// GRANTED PROVIDED THAT: (1) UNMODIFIED OR FUNCTIONALLY EQUIVALENT SOFTWARE
// DERIVED FROM THIS SOFTWARE MUST CONTAIN THIS NOTICE; (2) ALL CODE DERIVED
// FROM THIS SOFTWARE MUST ACKNOWLEDGE THE AUTHOR(S) AND INSTITUTION(S); (3)
// THE NAMES OF THE AUTHOR(S) AND INSTITUTION(S) NOT BE USED IN ADVERTISING
// OR PUBLICITY PERTAINING TO THIS SOFTWARE WITHOUT SPECIFIC WRITTEN PRIOR
// PERMISSION; (4) ALL CODE DERIVED FROM THIS SOFTWARE BE EXECUTED WITH THE
// MOLECULAR OPERATING ENVIRONMENT LICENSED FROM CCG.
//
// CCG DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
// ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, AND IN NO EVENT
// SHALL CCG BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
// ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
// IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
// OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

#set title	'Pharmacophore Query Editor'
#set class	'MOE:pharmacophore'
#set version	'2017.09'

#set main	'ph4_QueryEditor'

// Recent debugging/development branches:

local function PR, WR;		// dbg print functions
const FIND_PRINT = 0;		// 1=replace PR or WR with E_BUG

const QUE_BUTTON_ON_TOP = 1;	// 1='Q' on top, next to RSL
const USE_GEAR = 0;		// config for just EHT
const CONTOUR_LINES = 1;	// draw contour lines (not points)
const CONTOUR_MAXZ = 0;		// use the plane of the top circle of the union
const DBG_CLUSTER_SPH_VERB = 0;		// dbg union: spheres clusters info
const DBG_DOMINANT_SPH_VERB = 0;	// dbg union: buried spheres info
const DBG_DOMINANT_SPH_DAG = 0;		// dbg union: buried spheres DAG ok
const INTERSECTIONS_LATER = 0;
const APOS_IS_DOUBLE = 1; // 1 iff (aSetPos[a,p]] ==> eqL[p,aPos a]) for any p

const USE_ISMATCH = 0;		// hide ismatch box
const CALC_MATCH = 0;		// updated match against the template ligands
const PARTIAL_MATCH_P = 1;	// p.match widgets when n/a: 0=insens 1=hidden

const SHOW_ABSPOS_WARNING = 1;	// 1=show warning if (min) #features <3

const NEW_AFF = 0;		// new perspective world-to-screen fcns
#if NEW_AFF
local function SystemViewState, ViewAffData, AffW2V, AffV2W;
#endif

const NEW_VOLSURF	= 1;	// Future volume surfaces
const USE_DL_arad	= 0;	// Process ann.pts hidden by bigger atoms

#if 1
local function run_file arg = run arg;
#else
// Run-files are taken from the same directory
local function run_file [fname, arg] = run [
    tok_cat [ fpath db_Filename (modenv[]).filename, '/', fname ],
    arg
];
#endif

// local function ph4_edit_bhelp [] = run 'ph4_bhelp.svl';
local function ph4_edit_bhelp []
    static bhelp;
    if isnull bhelp then bhelp = run_file 'ph4_bhelp.svl'; endif
    return bhelp;
endfunction

// function ph4_AnnotationLig, ph4_AnnotationProp;
function ph4_AnnotationMap, ph4_AnnotationPos;
function ph4_AnnotationRec, ph4_AnnotationRecOK;
function ph4_AnnotationEmask, ph4_AnnotationAidx, ph4_AnnotationPairs;

#if NEW_VOLSURF
function msurf_MolecularSurface;
#endif

function ph4_SchemeList, ph4_SchemeOK, ph4_SchemeSetDefault;
// !!! function ph4_AnnotationFeatures;
function ph4_AnnotationData;

function ph4_SchemeNewFeatureBits, ph4_ExprNeededBits, ph4_ExprProjectedBits;
function ph4_SchemeBitsExpr, ph4_SchemeBitsColor, ph4_SchemeBitsRad;
function ph4_SchemeBitsProjected, ph4_SchemeGetBitmaskAll;

function ph4_ExprColor;
function ph4_ExprAtypes, ph4_ExprSvalControls;

function ph4_SchemeFcn;
function ph4_SchemeLabels, ph4_SchemeBits;
function ph4_SchemeDefmask, ph4_SchemeFdesc, ph4_SchemeNote;
function ph4_SchemeBitLabel, ph4_SchemeTypeMask;

function fread_PH4, fwrite_PH4;
function FilePrompt;
function ph4_ExprCleanupF, ph4_ExprCleanupV, ph4_ExprIndex;
function ph4_ExprAtomMask, ph4_ExprCheckSyntaxF, ph4_ExprCheckSyntaxV;
function ph4_ExprAddSval;
function ph4_CheckFile;

function ph4_QueryMatch_Open, ph4_QueryMatch_Close;
function ph4_QueryMatch_SetMol, ph4_QueryMatch_3D;
function _ph4_QdataErrNo, ph4_QdataValidate, ph4_QdataInit;

function WindowCall;

// ======================= tinkeries =======================

// const NO_WIN_QUIT_MSG = HOSTNAME == 'GOLEM';
const NO_WIN_QUIT_MSG = 1;	// 1=don't prompt on Close or Quit

// !!!
const NEW_EHT = 1;
const USE_DARKGREEN = 1;

const  __DBX_PH4_INIT = 0;	// default value for experimental mode
static __DBX_PH4;		// experimental mode (use glob.var if default=0)
const  LIG_use_Hs_init = [1,1,1]; // use hydrogen positions in r/s/l

const USE_ATOMQ = 1;		// Use AtomQ/AtomL instead of old-style Any

const SHOW_QUERY_BITS = 1;	// show "Query" button in the "Info..." panel
const USE_DL_GROUP = 1;		// detect groups of nearby annotation points
// !!!
const USE_DL_SEL = 0;		// synch list selection with sel.dummies

const SHOW_DL_SAMEAIDX = 1;	// connect projecting/projected annot.pts

const SHOW_DC_SAMEAIDX = 1;	// visualize projected contraints
const SHOW_DC_OPTION = 0	// display "Show:" checkbox or option
    and SHOW_DC_SAMEAIDX;
const SHOW_DC_CONES = 0		// allow visualization by cones
    and SHOW_DC_OPTION;

const SHOW_MATCH_IMPLICIT = 0;
// const CALC_MATCH = SHOW_MATCH_IMPLICIT;

const GROUP_RAD = 0.3;		// Dummies to be selected and typed together

const LIST_DEFLEN = 10;		// Default size (#of rows) of the main list
const DIST_COLOR = 1;		// Enable/disable colored distance
const LIG_SYNCTEXTCOLOR = 1;	// Sync lig.ann. text color with the query
const COLOR_FONT = 'small';	// Size of color buttons in Query Render panel
const COLOR_MARK = 1;		// Mark current color in Query Render panel
const SNAP_AUTO_COLOR = 1;	// Snap auto color to the nearest named color
const USE_GAMMA = 1;		// Blend colors as energies (remove gamma)
const ESSENTIAL_MODE = 2;	// Allow "Essential" on multi-selection (0,1,2)
				// 0=exactly one 1=no volumes 2=at least one
const VOLTYPE_MODE = 2;		// Allow "Vol.Type" on multi-selection (0,1,2)
				// 0=exactly one 1=no features 2=at least one
const EXPR_MODE = 2;		// Allow expression on multi-selection (0,1,2,3)
				// 0=one item 1=same expr 2=no mix V+F 3=always
const PROMPT_DELETE = 1;	// Prompt before deleting query items
const DELPROMPT_ENUMERATE = 1;	// Enumerate (list) items to be deleted (0,1,2)
				// 0=none 1=#of items 2=full list
const USE_LISTHEADER = 0;	// Show a header line in the main list
const FOLD_NEW_GROUPS = 1;	// Fold newly created groups
const SCALED_DENSITY = 1;	// Automatic scaling of sphere density (0,1,2):
				// 0=none 1=low,med,high(auto) 2=all(checkbox)

// !!! Intended only for the future release of the WT binary
const ENABLE_CBCOLOR = 0;	// Change Checkbox bgcolor on partial selection

const DL_BURIED_GVERTEX = 1;	// buried ann.pts as GPoint (not Dummy)

static CONS_wkey;
const CONS_FNAME = 'ph4_consensus.svl';
local function call_consensus arg = call ['ph4_Consensus_GUI', arg, CONS_FNAME];

// ===== Rendering Defaults ============================================

// Object properties: r:rendering type t:text offset, d:density
// k		r:0x07	d:0x700	GBITS:
// 1:dot	0x01	0x400	0x501
// 2:line	0x00	0x500	0x400
// 3:solid	0x03	0x500	0x503
// 4:contour	0x02	0	0x002
// 5:none	0x04	0	0x004

const RTYPE_NAME = ['Dot', 'Line', 'Solid', 'Contour', 'None'];
const RTYPE_GBITS = [0x501, 0x400, 0x503, 0x002, 0x004];
const DF_DEF_RTYPE = 2;		// index into RTYPE_NAME/GBITS (2=line)
const DV_DEF_RTYPE = 2;		// index into RTYPE_NAME/GBITS (2=line)

const GOBJ_DEFDENSITY = 0x300;	// Density of a new sphere
const DV_DEFLABEL = '';		// Default label on excluded volumes

const DF_DEFCOLOR = icolor 'yellow';	// Default color for features
const DV_DEFCOLOR = icolor 'dark gray';	// Default color for excluded volumes
// const DV_DEFCOLOR = icolor 'orange';	// Default color for excluded volumes

const DF_DEF_TRANS = 0;
const DV_DEF_TRANS = 0;

static DF_DEF_MAT;		// set to GOBJ_matDefault in initval_GOBJ
static DV_DEF_MAT;

const DC_DEFEXPR = 'SOME';	// Default expr. on a new constraint

// ======================= sync editor/search =======================

// !! These values must be synchronized between the editor and the search
const CTYPE = untag [
    SOME: 'At Least One',
    SOME2: 'At Least Two',
    SOME3: 'At Least Three',
    SOME4: 'At Least Four',
    SOME5: 'At Least Five',
    ONE: 'Exactly One',
    TWO: 'Exactly Two',
    NALL: 'All or None',
//  ======================
    SAMEAIDX: 'Same atom(s)',
    SHAREAIDX: 'Shared atom(s)'
];

const N_CTYPE_NFEAT = indexof ['NALL', CTYPE(1)]; // # of nfeat options in CTYPE

// ======================= function use =======================

local function GOpenQueN;

// ======================= RC names =======================

const RC_MEMPFX		= 'ph4edit.mem.';	// internal use
const RC_PVECTORS	= 'ph4edit.pvectors';	// 1=show ann.pvectors on start
const RC_DC_COLOR	= 'ph4edit.C.color';	// proj.constrs (1 anchor found)
const RC_DC_COLOR0	= 'ph4edit.C.color0';	// proj.constrs (anchor unknown)
const RC_USE_RVAL	= 'ph4edit.useRval';	// R-Strength startup value
const RC_UNDO_NMAX	= 'ph4edit.undo.nmax';	// #undos

local function DefaultColorBG []
    const BLANC_BG = 0xd8d8d8, NOIR_BG = 0x3b3b38;
    return icolor GetRC ['default.color.background', BLANC_BG];
endfunction

// ======================= ID strings =======================

static EDITOR_id;	// Unique token identifying the editor (coldinit)
//  EDITOR_id = token swrite ['{n:f}', clock[]];

const  PRIVATE_PH4_QUE_PREFIX = '[PRIVATE] Pharmacophore Query Features ';
const  PRIVATE_PH4_LIG_PREFIX = '[PRIVATE] Pharmacophore Annotation Points ';

const GCLASS_QUE = '.Ph4Query';			// used by GOpenQueN
const GCLASS_ANN = '.Ph4Annotation';		// not (yet) used

// ======================= definitions =======================

const EBIT_ESSENTIAL	= 0x1;	// essential feature, contraint or volume
const EBIT_IGNORED	= 0x8;	// ignored feature, contraint or volume
const GBIT_HIDDEN	= 0x80;	// ignored feature or volume

const LIGHT_GREEN	= 0x70ff70;
const DARK_GREEN	= icolor 'DarkGreen';
const DARK_RED		= 0xe00000;

static TASKENV_dbfilename; // The filename of the current DB (key may go down)

static  WIN_QUE_TITLE, WIN_QUE_NAME;
// const  WIN_QUE_TITLE = 'Pharmacophore Query Editor';	// main panel title
// const  WIN_QUE_NAME = WIN_QUE_TITLE;			// main panel windowName

const  WIN_COMMENT_TITLE = 'Pharmacophore Query Comment';
const  WIN_RENDER_TITLE = 'Pharmacophore Query Rendering';
const  WIN_SEARCH_TITLE = 'Pharmacophore Database Search';

const  WIN_QUIT_MSG =
    'Pharmacophore Query Editor:\n'
    'Save changes before quitting?';

static WIN_key;		// main "P. Query Editor" window handle
static WIN_SEARCH_key;	// "Search..." window handle, 0 when no window
static SEARCH_tid;	// grandparent of all search tasks
static SEARCH_fn;	// db file name for ph4 search FilePrompt

const  CHAIN_QUE_NAME	= PRIVATE_PH4_QUE_PREFIX;
static CHAIN_QUE_key;	// Chain of ph4 query dummies	(coldinit)
static CHAIN_QUE_tag;	// Identifies the chain of ph4que dummies (coldinit)

const  CHAIN_LIG_NAME	= PRIVATE_PH4_LIG_PREFIX;
static CHAIN_LIG_key;	// Chain of ph4 ligand dummies	(coldinit)
static CHAIN_LIG_tag;	// Identifies the chain of ph4lig dummies (coldinit)

const  UNDO_USE_OFS = 1; // 1=offset to a circular buffer, 0=resizing buff
static UNDO_OFS, UNDO_I, UNDO_N, UNDO_NMAX, UNDO_S;
static UNDO_dbg;	// 1=print dbg info on undo/redo/usnap (see undo_dbg)

local function initval_SYS editor_id
#   ifnot __DBX_PH4_INIT
    // __DBX_PH4>0 is used to specify an experimental mode of the editor.
    // If __DBX_PH4_INIT>0, __DBX_PH4 is set to the value of __DBX_PH4_INIT.
    // If __DBX_PH4_INIT=0, __DBX_PH4 is set to the value of the global
    // variable __DBX_PH4, which can be changed by the user on the CLI.
    __DBX_PH4 = anytrue sym_value '__DBX_PH4';
#   endif

    if anytrue task_getenv 'DB_VIEW' then
	local key = db_Key task_getenv 'DB_VIEW';
	if anytrue key then
	    TASKENV_dbfilename = db_Filename key;
	endif
    endif

    CHAIN_QUE_key = 0;
    CHAIN_QUE_tag = tok_cat [PRIVATE_PH4_QUE_PREFIX, editor_id];
    CHAIN_LIG_key = 0;
    CHAIN_LIG_tag = tok_cat [PRIVATE_PH4_LIG_PREFIX, editor_id];

    WIN_SEARCH_key = 0;

    UNDO_OFS = UNDO_I = UNDO_N = 0;
    UNDO_NMAX = GetRCNumber [RC_UNDO_NMAX, 1000];
    UNDO_dbg = 0;
endfunction

static GOBJ_QUE_name1;	// Identifies the gobj of ph4 spheres (coldinit)
static GOBJ_QUE_name2;	// Identifies the gobj of ph4 text (coldinit)

static DD_gkey;		// gkeys for query spheres
static GOBJ_matDefault;
static GOBJ_QUE_key1;	// gkey for query constraints
static GOBJ_QUE_key2;	// gkey for query text and contours
static GOBJ_QUE_ViewOrientation;	// last ViewOrientation used by draw

static GOBJ_LIG_name;	// Identifies the gobj of lig.annotation (coldinit)
static GOBJ_LIG_key;	// graphics key of the lig.annotation text
#if SHOW_DL_SAMEAIDX
static GOBJ_LIG_name2;	// Identifies the gobj of lig.annotation (coldinit)
static GOBJ_LIG_key2;	// graphics key of the lig.annotation proj.vectors
#endif
static GOBJ_LIG_ViewOrientation;	// last ViewOrientation used by draw

local function initval_GOBJ editor_id
    // !!! this is a hack
    GOBJ_matDefault = bitand [first GMaterialTSGB G_BACKGROUND_KEY, 0xffffff];

    if allfalse GKey GOBJ_QUE_key1 then GOBJ_QUE_key1 = GOpenQueN 1; endif
    if allfalse GKey GOBJ_QUE_key2 then GOBJ_QUE_key2 = GOpenQueN 1; endif

    GOBJ_QUE_name1 = tok_cat [PRIVATE_PH4_QUE_PREFIX, editor_id, '_1'];
    GOBJ_QUE_name2 = tok_cat [PRIVATE_PH4_QUE_PREFIX, editor_id, '_2'];

    GOBJ_LIG_key = 0;
    GOBJ_LIG_name = tok_cat [PRIVATE_PH4_LIG_PREFIX, editor_id];

#if SHOW_DL_SAMEAIDX
    GOBJ_LIG_name2 = tok_cat [PRIVATE_PH4_LIG_PREFIX, '2', editor_id];
    GOBJ_LIG_key2 = 0;
#endif

    DF_DEF_MAT = DV_DEF_MAT = GOBJ_matDefault;
endfunction

// Query dummies

static DD_atom;			// Atom handle of dummy atoms
static DD_x, DD_y, DD_z;	// Position (synchronized to aPos DD_atom)
static DD_r;			// Radius (set by "R:" wheel)
static DD_color;		// Color (set by "Color:" option or "Render...")
static DD_expr;			// Type expression (set by TextWidget&"Apply")

static DD_ebits;	// Match-related bit properties
//	0x1:  essential feature (vs. non-essential)
//	0x2:  exterior volume (vs. interior) "bounding" or "ligand shape"
//	0x4:  included volume (vs. excluded) "occupied"
//	0x8:  ignored object (vs. used in search)

static DD_gbits;	// Graphics-related bit properties
//	obsolete:
//		0x01: dot sphere (vs. line)
//		0x02: dense sphere (vs. normal)
//		0x04: no sphere (vs. shown)
//	0x07: sphere type: 0=line, 1=dot, 2=contour, 3=solid 4=none
//	obsolete:
//		0x08: centered text (vs. offset)
//		0x10: short text (vs. long)
//		0x20: no text (vs. shown)
//	0x40: auto color (vs. explicit)
//	0x80: hidden object (vs. shown)
//	0x700: density: 0=reserved, 1=min, 2=lo, 3=med, 4=hi, 5=max

// const RMASK_ALL	= 0x70f;	// density + type + (!!! txt.offs?)
const RMASK_ALL		= 0x707;	// density + type
const RMASK_TYPE	= 0x007;	// type only
const RMASK_IGNORE	= 0x038;	// obsolete text center/short/hide bits

// !!!
static QUE_textmode; // 0=no text,1=short('F1'),2=full(def),3=full+strength

static DD_umask;	// 0=single sphere, 1=union of >=2 spheres
static DD_usel;		// selected unions (1 flag per union)
static DD_ufold;	// folded unions (1 flag per union)

static DD_sel;			// Selected spheres (features/volumes)
static DC_sel;			// Selected constraints

static DIST_monitor;		// Distance monitoring toggle (coldinit)

static DF_count;		// #of features (coldinit)
static DV_count;		// #of volumes (coldinit)
static DC_count;		// #of constraints (coldinit)

static LIST_seg;		// segment vector of the mainlist sel.mask

// Query constraints

static DC_expr;		// Constraint expression (e.g. "At Least One")
static DC_ids;		// id's of features in the constraint (e.g. [1,3,4])
static DC_ebits;	// Match-related bit properties
#if SHOW_DC_OPTION
static DC_gbits;	// Visualization properties
#endif

// Ligand dummies

static LIG_seg;
static LIG_rsl;		// [R:0/1/2, S:0/1, L:0/1]
static LIG_use_Hs;	// 1: use hydrogen positions in r/s/l
static LIG_abspos;	// 1: don't superpose when matching db ligands
static LIG_allrec;	// 0: detect active site, 1: annotate all rec.surface
static LIG_nrecatoms;	// # rec. (non-solvent) atoms in each receptor
static LIG_nrec;	// # receptors to be annotated
static LIG_hasrec;	// 1 iff there is a receptor that could be annotated
static LIG_hassol;	// 1 iff there is a solvent that could be annotated
static LIG_haslig;	// 1 iff there is a ligand that could be annotated
static LIG_gtextcolored;	// Colorize ligand annotation text
static LIG_atom;		// Atoms to be annotated (per chain)
#if SHOW_DL_SAMEAIDX
// !!! initialized to  GetRC [RC_PVECTORS, 0]
static LIG_pvectors;	// 0=none, 1=lines (coldinit)
#endif
static LIG_svalMin;	// !!!

local function initval_LIG []
    LIG_rsl = [0,0,1];
    LIG_use_Hs = 1;
    LIG_abspos = 0;
    LIG_allrec = 0;
    LIG_nrec = 0;
    LIG_hasrec = 0;
    LIG_hassol = 0;
    LIG_haslig = 0;

    LIG_gtextcolored = 1;
    LIG_svalMin = [Acc: 0.80, Don: 0.60];	// !!! HACK
#if SHOW_DL_SAMEAIDX
    LIG_pvectors = GetRCBoolean [RC_PVECTORS, 1];
#endif
endfunction

// Properties of pharmacophore sphere (e.g. PCH)

static SCHEME_list;	// list of all available schemes
static SCHEME_name;	// name of the scheme
static SCHEME_type;	// basic ph4 types used by the scheme
static SCHEME_tcode;	// numerical value for each type
static SCHEME_mask;	// actual mask of annotation types

// DL_xxx(i) is receptor|solvent iff i <= LIG_nrec*2

static SCHEME_svalOK;	// 1=sval attached to annotation data
static DL_sval;		// Hueckel emd/ema strength extracted from lig.ann.pts
static QUE_svalMin;	// calculated: min of displayed DL_sval

// useFrval=	1: use DL_sval+DD_rval>EHB, 0: force DD_rval=1
// useFmval=	1: use EHB=QUE_tval+DD_mval, 0: force DD_mval=0
static SVAL_useRval;	// 0=user sets DD_sval, 1=user sets DD_rval, DD_mval

// Obtained by 'SvalInfo' method from ph4 scheme:
static SVAL_Xxx;	// list of Acc/Don sval controls (e.g. [Acc,Don])
static SVAL_XxxYyy;	// what Xxx controls, e.g. [Acc:[Acc,Acc2], Don:...]
static SVAL_default;	// default sval lower limits for displayed Acc/Don
static RVAL_default;	// default rval value of new Acc/Don que.featuere
static MVAL_default;	// SVAL_default * RVAL_default

// initval_SCHEME initializes scheme-relateed statics.

local function initval_SCHEME []

// !!! The EHT should not be needed, but the code is still fragile and this
// lowers the probability of problems do to the order of switching schemes.
#if 1
    local info = ph4_SchemeFcn ['EHT', 'SvalInfo'];
    SVAL_default = info.svalDefault;		// min.displayed
    RVAL_default = info.rvalDefault;

    SVAL_XxxYyy = info.svalControl;		// [Acc:['Acc','Acc2', Don:...]
    SVAL_Xxx = tags SVAL_XxxYyy;		// ['Acc', 'Don']

    local Xxx;
    for Xxx in SVAL_Xxx loop
	MVAL_default.(Xxx) = SVAL_default.(Xxx) * RVAL_default.(Xxx);
    endloop
#endif

    SVAL_useRval = GetRCBoolean [RC_USE_RVAL, 0];

    SCHEME_list = ph4_SchemeList[];
    SCHEME_svalOK = 0;
endfunction


static DD_svalXxx;	// current state of Xxx=Acc/Don in the bottom "S:" line

static DD_sval;		// sval used for ph4 search matching
static DD_rval;		// Hueckel emd/ema extracted from nearby receptor
static DD_mval;		// DD_mval = DD_sval * DD_rval

static DL_atom;			// Atom handle of dummy atoms
static DL_x, DL_y, DL_z;	// Position (synchronized to aPos DL_atom)
// static DL_r;			// Radius (set by "R:" wheel)
static DL_color;		// Color (set by "Color:" option or "Render...")
static DL_expr;			// Type expression (set by TextWidget&"Apply")
#if USE_DARKGREEN
static DL_expr2;		// Type expression + sval
#endif
static DL_index;		// Index of a feature in the ligand (symmetry!)

#if USE_DL_SEL
static DL_sel;
#endif

#if USE_DL_GROUP
static DL_group;		// group ID of nearby features
static DL_grank;		// rank of features within the same group
#endif

static DL_bits;		// annotation bits
static DL_buried;	// buried annotation features

#if SHOW_DL_SAMEAIDX
static DL_tail;		// index of the projecting annotation point
static DL_head;		// index of the projected annotation point
static DL_astate;	// ann.group state: no change means no recalc needed
#endif

static DS_scheme;		// Ph4 scheme (set from the panel)
static DS_matchsize;		// Min.match size (set from the panel)
static DS_title;		// Brief query description (set from the panel)
static DS_comment;		// Extended comment (set from a sep.window)
static DS_comment_bhelp;

static QUE_gtextcolored;	// colorize GText sphere labels in MOE Window
static QUE_scaled_density;	// Sphere rendering density scales with radius

static QUE_changed;	// Query changed since the last data update
static QUE_fplus;	// Query changed since the file load/save
static QUE_saved_data;	// Last query data saved to a file
static QUE_fname;	// File name of the last loaded/saved ph4 query

static QUE_qdata;	// q2008 tagvector of DD_*/DS_* values
static QUE_qdataOK;	// 1=QUE_qdata up to date, 0=must call qdata_Sync
// !!! WIN_QUE_NAME WIN_QUE_TITLE

static MATCH_update;

local function initval_QUE []
    DF_count = DV_count = DC_count = 0;
    QUE_gtextcolored = 1;
    QUE_textmode = 2;	// 0=no text,1=short('F1'),2=full,3=full+strength
    QUE_scaled_density = 1;
    QUE_changed = 0;
    QUE_qdataOK = 0;
    QUE_fplus = 0;
    QUE_fname = '';
    DIST_monitor = 0;
    MATCH_update = 1;

    local bhelp = ph4_edit_bhelp [];
    DS_comment_bhelp = [bhelp.comment, bhelp.comment_undo];
endfunction


// ==================== past debugging / future development ====================

// E_BUG immediately terminates the execution of its task and reports
// the location of the code in the error message (and in the crash history).
// The function is meant to be used to report failed algorithmic assertions,
// not illegal arguments or inconsistent data.  That is, the function being
// called should indicate that there is a bug in the code and the code needs
// to be rewritten.

local function E_BUG msg
    local [line, fn] = get [where -1, [[4,2],[3,2]]];
    if anytrue msg then msg = twrite [': {}', msg]; endif
    WindowShow 'SVLCrashHistory';
    exit twrite ['BUG {}_{}{}', fbase ftail fn, line, msg];
endfunction

// PR/WR are synonyms for pr/write that should be used for debugging
// purposes.  All debugging prints must be removed or disabled in the
// public version.  Setting FIND_PRINT=1 (on top of the file) will make
// it easier to find any remaining instances: an error msg will be generated
// with the line number of the culprit PR/WR.

#if FIND_PRINT
    local function E_LINENO x
	local [line, fn] = get [where -1, [[4,3],[3,3]]];
	WindowShow 'SVLCrashHistory';
	exit twrite ['Bad {} in {}_{}', x, fbase ftail fn, line];
    endfunction
    local function PR x = E_LINENO 'PR';	//  error w/line# & stack trace
    local function WR x = E_LINENO 'WR';
#else
    local function PR x = pr x;			// dbg print functions
    local function WR x = write x;
#endif

#if 0
// LL prints the line numbers of the current call stack, followed by x,
// where x can be either a tagged vector or the argument to "write".
//
// Note: line #s from other files (not this) are preceded by the filename.
// Note: if x is null or a tagvector, we include the NEW LINE automatically.
// If x is an argument to "write", the caller must include "\n", as needed.

function LL x
    local line	=  dropfirst (where -1)(4);		// lines
    local file	=  ftail dropfirst (where -1)(3);	// filenames
    local m	= btom file;
    line	= split [line, mtoc m];			// split by filename
    file	= file | m;
    m		= file <> file(1);			// not this file
    line | m	= app nest apt cat [file | m, line | m]; // prepend filename
    local w	= cat line;				// flat

    write ['{v} ', w];				// lines
    if isnull x then		write '\n';	// no text
    elseif istagged x then	print x;	// tagevec
    else			write x;	// write arg
    endif
endfunction

#if 0
// WindowSetData wrapper will report any pgm.changes in values of widgets
// with names from "CHK".

local function __WindowSetData x = WindowSetData x;
local function WindowSetData [wkey, x]
    const CHK	= ['msize', 'msize_sign'];
    local k	= x_join [tags x, CHK];
    if notnull k then
	write '-----------------\n';
	LL 'WindowSetData '; print x[k];
    endif
    __WindowSetData [wkey, x];
endfunction
#endif
#endif

const USE_AUTOBIT = 0;	// 1=add "auto" as a special color (experimental)

// GOpenQueN opens n graphics objects and sets their class to GCLASS_QUE.

local function GOpenQueN n
    local gkey = app GOpen rep [[], n];
    GSetClass [gkey, GCLASS_QUE];
    return gkey;
endfunction

const DBG = 0;
local function event name
#   if DBG
    static events_wkey;
    if allfalse WindowKey events_wkey then
	call ['ph4_DbgEventsWindow', task_key -1, 'ph4_edit2.svl'];
	local stask;
	[stask, events_wkey] = task_receive 0.5;
	if isnull stask then exit 'Event monitor failed'; endif
	task_reply stask;
    endif
    WindowCall [events_wkey, 'event', name];
#   endif
endfunction


// ensure_Xxx ensures that DD_sval, DD_rval and DD_mval have correct tags.

local function ensure_Xxx n
    if not SCHEME_svalOK then return; endif
    if isnull n then n = length DD_expr; endif

    local Xxx;
    for Xxx in SVAL_Xxx loop
	if isnull DD_sval.(Xxx) then
	    DD_sval.(Xxx) = rep [SVAL_default.(Xxx), n];
	endif
	if isnull DD_rval.(Xxx) then
	    DD_rval.(Xxx) = rep [RVAL_default.(Xxx), n];
	endif
	if isnull DD_mval.(Xxx) then
	    DD_mval.(Xxx) = rep [MVAL_default.(Xxx), n];
	endif
    endloop

    if l_length tagvals DD_sval <> n then E_BUG[]; endif
    if l_length tagvals DD_rval <> n then E_BUG[]; endif
    if l_length tagvals DD_mval <> n then E_BUG[]; endif
endfunction

local function T_get [tvec, k]
    local [stag, sval] = untag tvec;
    return tag [stag, apt get [sval, [k]]];
endfunction

local function T_put [tvec, k, val]
    local [stag, sval] = untag tvec;
    return tag [stag, apt put [sval, [k], [val]]];
endfunction

local function T_poke [tvec, k, val]
    local [stag, sval] = untag tvec;
    return tag [stag, apt poke [sval, [k], [val]]];
endfunction

// local function tagvals tvec = second untag tvec;

// !!! move this outside the function
local function WaterScale [x, mode] =
    ph4_SchemeFcn [SCHEME_name, 'WaterScale', [x, mode]]
;

local function round_100 x = round (x * 100) / 100;
local function f100 x =  maxE [1, minE [floor(x * 100), 10000]] / 100;
local function avg x =  add x * invz length x;

// ==================== initialization ====================

local function coldinit []
    EDITOR_id = token swrite ['{n:f}', clock[]];

    initval_SYS EDITOR_id;
    initval_GOBJ EDITOR_id;
    initval_LIG [];
    initval_QUE [];
    initval_SCHEME [];
endfunction

// ---------------------------- utilities ----------------------------

// The monitor is an endless loop that waits for a windows trigger.
// The monitor is started with the first call to window_wait
// delivers its task ID to the calling task (with an empty task_send).
// The monitor is terminated with the end of the calling task.
// In each cycle, the monitor blocks until a trigger from the window
// is received.  Then it sends the trigger info to the calling task and
// blocks until the calling task wakes it up with task_reply in
// the next call to window_wait.

local function monitor_window [ptask, wkey]
    task_send ptask;
    loop task_send [ptask, WindowWait wkey]; endloop
endfunction

// The function window_wait behaves identically to WindowWait, except
// that if a windows trigger is not received before the specified timeout
// expires, the functions return with [] as its result.
// The function starts and maintains a monitor task that waits for the
// window trigger.  window_wait will wait in task_receive for the window
// trigger to be delivered by the monitoring task.  If the trigger is
// not delivere within the timeout, task_receive wakes up and returns [].

// WARNING1: Even though semantically it would make sense to wait on
// several windows at the same time (round-robin with a small timeout),
// the function's implementation does not allow it - we'd need to replace
// the task_send/receive/reply protocol with something else.

// WARNING2: Similarly to WindowWait, window_wait kills the calling task
// when the window handle is destroyed.

static WWTBL;

local function window_wait [wkey, opt]

	// The ID of the monitoring task is stored in the static variable
	// WWTBL.  To look it up, we must use an ID composed of the ID of
	// the calling task and the key of the window, because:
	// 1) different tasks may share the same static variable
	// 2) after it is finished with one window, the same task may start
	// waiting on another window.

    local this_task = task_key -1;
    // !!! local monitor_id = [[this_task, wkey]];
    local monitor_id = token mpu_charencode [this_task, wkey];

    if isnull WWTBL.(monitor_id) then
	local [mid, sid] = untag WWTBL;			// clean up the cache:
	WWTBL = tag ([mid, sid] || [task_key sid]);	// drop old monitors
	const TARG = [master:'mutual', creator:'detach', prio:0];
	task_call [#monitor_window, [this_task, wkey], TARG]; // start m.
	WWTBL.(monitor_id) = first task_receive [];	// the monitor task id
    endif

	// 1) If the previous task_receive returned with a trigger, then
	// the monitor is still blocking on the last task_send (with its
	// message already received), and task_reply will wake it up.
	// 2) If the previous task_receive returned with null when its timeout
	// expired, then the monitor is either still blocking on WindowWait
	// or already blocking on a new task_send (with its message not yet
	// received), and the task_reply will be ignored.

    task_reply WWTBL.(monitor_id);		// wake up the monitor
    return second task_receive opt.timeout;	// block on the monitor
endfunction

// Send a programmatic trigger to given window.

local function window_trigger [wkey, trig, value]
    local [rtask_, wkey_] = tr tags WWTBL;
    local rtask = rtask_ | wkey_ == wkey;

    if isscalar rtask then if task_key rtask then
	task_send [rtask, [value, trig], 0];
    endif endif
endfunction


// ==================== utilities: colors ====================

// Colors used by the color button bar in Query Rendering panel

const RENDER_CNAME = [
    // pure hues
    'Red',
    'Dark Red',
    'Green',
    'Dark Green',
    'Blue',
    'Dark Blue',
    'Yellow',
    'Dark Yellow',

    // mixed hues
    'Purple',
    'Dark Purple',
    'Orange',
    'Dark Orange',
    'Cyan',
    'Dark Cyan',
    'Pink',
    'Dark Pink',
    'Brown',
    'Dark Brown',

    // shades
    'Gray',
    'Dark Gray',
    'White',
    'Black'
];

// Colors used by the option widget in the main panel

const CNAME1 = [
    'Red', 'Green', 'Blue', 'Yellow',
    'Purple', 'Orange', 'Cyan', 'Pink', 'Brown',
    'Gray', 'White',
    'Dark Red', 'Dark Green', 'Dark Blue', 'Dark Yellow',
    'Dark Purple', 'Dark Orange', 'Dark Cyan', 'Dark Pink', 'Dark Brown',
    'Dark Gray', ''
];

const AUTOLABEL = 'Auto';
const CNAME2 = [
    'Red', 'Green', 'Blue', 'Yellow',
    'Purple', 'Orange', 'Cyan', 'Pink', 'Brown',
    'Gray', 'White', AUTOLABEL,
    'Dark Red', 'Dark Green', 'Dark Blue', 'Dark Yellow',
    'Dark Purple', 'Dark Orange', 'Dark Cyan', 'Dark Pink', 'Dark Brown',
    'Dark Gray', 'Black', ''
];

const CNAME = peek [[CNAME1, CNAME2], inc USE_AUTOBIT];


const SHADE = [ 'White', 'Gray', 'Dark Gray', 'Black' ];
const HUE = diff [CNAME | icolor CNAME <> -1, SHADE];

const RGB_HUE = bitand [0xff, bitshr [[icolor HUE], [16,8,0]]];
const RGB_SHADE = bitand [0xff, bitshr [[icolor SHADE], [16,8,0]]];


// Convert RGB integer color to color name.

local function int_to_color rgb
    if not isscalar rgb then return app int_to_color rgb; endif
    rgb = bitand [0xff, bitshr [rgb, [16,8,0]]];
    if max rgb - min rgb > 40 then
	return HUE(x_min norm (rgb - RGB_HUE));
    else
	return SHADE(x_min norm (rgb - RGB_SHADE));
    endif
endfunction


// Return per-channel average of given set of RGB colors.
// Note: dividing (and multiplying) the colors by 0xff for the gamma
// calculations is not necessary.

local function avg_color color
    color = bitand [0xff, bitshr [color, [[0,8,16,24]]]];
    if USE_GAMMA then
	color = pow [color, 2.4];
	color = add color * invz length color;
	color = int pow [color, inv 2.4];
    else
	color = int (add color * invz length color);
    endif
    color = bitor bitshl [color, [0,8,16,24]];
    return color;
endfunction

// ==================== utilities: ph4 ====================

local function expr2xxx expr	// !!! HACK
    local Xxx = lhs ['', expr];
    if SCHEME_svalOK then
#if 1
	local i;
	for i = 1, length expr loop
	    local svalCtrl = ph4_ExprSvalControls [expr(i), SVAL_XxxYyy];
	    if length svalCtrl then Xxx(i) = first svalCtrl; endif
	endloop
#else
	Xxx | m_findmatch ['*Acc*', expr] = 'Acc';
	Xxx | m_findmatch ['*Don*', expr] = 'Don';
#endif
    endif
    return Xxx;
endfunction



// get_listsel converts selection state stored in DD_sel, DD_usel, DC_sel
// to a mask usable with the list widget.  The function stores the segment
// information that corresponds to "folded" unions in LIST_seg and returns
// a catenated, flat selection mask.

local function get_listsel []
    local sel = DD_sel;		// start with sel.mask of dummies
    sel | DD_ufold = [[]];		// drop dummies of folded unions
    sel | DD_umask = apt prepend [	// prepend union headers to all unions
	sel | DD_umask, DD_usel | DD_umask];

    local m = stretch [[1,0,1], [DF_count, DC_count, DV_count]];
    sel = unpack [sel, DC_sel, m];	// splice in sel.mask of constraints
    LIST_seg = app length sel;		// store the segment information

    return cat sel;			// return flat selection
endfunction


// put_listsel is inverse to get_listsel.  It converts the input flat selection
// mask, together with static LIST_seg to the selection state of DD/DC items
// and stores the information in DD_sel, DD_usel, DC_sel.

local function put_listsel sel
    sel = split [sel, LIST_seg];	// segment unions

    local m = stretch [[1,0,1], [DF_count, DC_count, DV_count]];
    DC_sel = sel | not m;		// extract constraint selection

    sel = sel | m;			// keep only DD selection
    DD_usel | DD_umask = app first (sel | DD_umask); // union headers
    sel | DD_umask = app dropfirst (sel | DD_umask); // drop union headers
    DD_sel | not DD_ufold = sel | not DD_ufold;	 // non-folded items

    // !!! selection of union headers vs. selection of union items?
endfunction

// Automatically assign color according to the types present in a given
// expression.

local function auto_color expr
    if not isflat expr then return app auto_color expr; endif
    local color = ph4_ExprColor [SCHEME_name, expr];
    color | color == -1 = DF_DEFCOLOR;
    if SNAP_AUTO_COLOR then color = icolor int_to_color color; endif
    return color;
endfunction

// msize_1to3 converts a single signed integer (d.S.matchsize) to 3 values:
// [non-zero flag, sign (1=pos,2=neg), abs.value].  (Currently not used.)
// (See also load_qdata, which replaces 0 by DF_count.)

local function msize_1to3 x		// data.S.matchsize
    if x <= -INT_MAX then return [1, 1, 0]; endif	// AtLeast 0
    return [ notnot x, inc (x < 0), abs x ];
endfunction

// msize_3to1 convers  3 values: [non-zero flag, sign (1=pos,2=neg), abs.value]
// to a single integer.  (Used in the main event loop to convert the values of
// 3 widgets, [v.msize_nonzero, v.msize_sign, v.msize], into DS_matchsize.

local function msize_3to1 [msize_nonzero, msize_sign, msize]
    static emsg;
    if not msize_nonzero then	return 0;	// =0:full match (checkbox=OFF)
    elseif msize < 0 then	return NaN;
    elseif msize_sign == 1 then			// AtLeast
	if msize > 0 then	return msize;
	elseif msize == 0 then	return -Inf;	// no minimum
	elseif notnull emsg then return 0;	// already reported (some) err
	else			emsg = W_BUG ['Unexpected msize {}', msize];
	endif
    elseif msize_sign == 2 then			// AllBut
	if msize > 0 then	return -msize;
	elseif msize == 0 then	return 0;	// full match
	elseif notnull emsg then return 0;	// already reported (some) err
	else			emsg = W_BUG ['Unexpected msize {}', msize];
	endif
    elseif isnull emsg then
	emsg = W_BUG ['Unexpected msize_sign {}', msize_sign];
    endif

	// Warn about an unexpected state, but only once.
	// Note: an unexpected state always results in msize=0, i.e.full match.

    Warning emsg;
    return 0;
endfunction


// Return 1 iff the chain of ligand annotation dummies, CHAIN_LIG_key, is valid.

local function ph4lig_chain_ok []
    // if isnull CHAIN_LIG_key then	(coldinit)
    if neL [oType CHAIN_LIG_key, 'chain'] then
    elseif neL [cTag CHAIN_LIG_key, CHAIN_LIG_tag] then
    else return 1;
    endif
    return 0;
endfunction

// The following functions is needed to restore the query and/or annotation
// after "Close" has been pressed.
// If flg=0, we save the current view (for later use).
// If flg=1, we restore the last saved view.

local function loadstore_view do_load	// (M2)
    static view_org, view_yz, view_scale;

    if allfalse do_load then		// do_load=0 ==> store the current view
	view_org = ViewLookAt[];
	view_yz = ViewOrientation[];
	view_scale = ViewScale[];
    else				// do_load=1 ==> restore the last view
	ViewLookAt view_org;
	ViewOrientation view_yz;
	ViewScale view_scale;
    endif
endfunction

// Draw the ligand annotation text

const PH4CLASS = 'MOE-ph4Edit';		// !!! must be sync'ed to undo

local function _GCreateUnique name
    local gkey = GCreateUnique name;
    GSetClass [gkey, PH4CLASS];
    return gkey;
endfunction


local function draw_lig_text []		// (M1)
    if DBG then event 'lig_update_gobj'; endif

	// Prevent reentrant execution:  If a new A is reentering
	// a running B, let B do the A's work in an extra loop iteration.

    static running;
    if anytrue running then running = 2; return; endif	// force extra iteration
    running = 1;					// one iteration
    loop	// SPECIAL USE: loop body not nested!

	// Reset the last-drawn-view value (to avoid being called again
	// if the view does not change).

    GOBJ_LIG_ViewOrientation = ViewOrientation[];

	// If there is no text to be drawn, make sure that the gobj is empty
	// and return immediately.

    static last, last_tstate;

    if isnull DL_expr or allfalse LIG_rsl then
	if length last then
	    GOBJ_LIG_key = _GCreateUnique GOBJ_LIG_name;
	    last = last_tstate = [];
	endif
	continue;
    endif

	// If the graphics object does not exist (e.g. was destroyed),
	// create a new one.  Force recalculation.

    if allfalse (GOBJ_LIG_key == GList []) then
	GOBJ_LIG_key = _GCreateUnique GOBJ_LIG_name;
	last = allfalse last;	// force recalculation
    endif

	// Avoid redrawing the same data (unless the graphics object
	// was destroyed).  !Note!: this will fail to detect any changes
	// that done externally, directly (programmatically) to the gobj.

    local force_text = neL [last_tstate, last_tstate = [
#if USE_DARKGREEN
	LIG_rsl, LIG_allrec, DL_index, DL_expr, DL_expr2
#else
	LIG_rsl, LIG_allrec, DL_index, DL_expr
#endif
    ]];
    local no_change = eqL [last, last = [
	GOBJ_LIG_ViewOrientation, LIG_rsl, LIG_allrec, LIG_gtextcolored,
	last_tstate, DL_color, DL_x, DL_y, DL_z
    ]];
    if no_change then continue; endif

	// Destroy previous gobj and create a new one.
	// NOTE: each editor instance uses a separate unique name.

    GOBJ_LIG_key = _GCreateUnique GOBJ_LIG_name;
    if DBG then event 'lig_draw_gobj'; endif	// new gobj --> redraw

	// Generate text, as required.
#if USE_DARKGREEN
	// LIG_rsl(i), (i=1:rec,i=2:sol,i=3:lig):
	//   0=none, 1=points, 2=points&text 3=points&text&sval
#else
	// LIG_rsl(i): 0=none, 1=points, 2=points&text (i::1=rec,2=sol,3=lig)
#endif

    static text;
    local m_text = tok_length text;
    if force_text then
#if USE_DARKGREEN
	m_text = (LIG_rsl >= 2) + (LIG_rsl > 2);
#else
	m_text = LIG_rsl == 2;
#endif
	m_text = stretch [m_text,
	    [LIG_nrec, LIG_nrec, length DL_expr - 2*LIG_nrec]];
	m_text = stretch [m_text, app length DL_expr];
	text = select [cat DL_expr, '', m_text];
#if USE_DARKGREEN
	text | m_text == 2 = cat DL_expr2 | m_text == 2;
#endif
    endif

	// Prepare to generate spheres and text

    local color = cat DL_color | m_text;
    local pos = app cat [DL_x, DL_y, DL_z] || [m_text];
    const RAD = 0.25;
    // !!! RAD should change depending on nucleus type of the lig.ann.dummies
    // and any of the lig.atoms nearby

    static TEXT_COLOR;
    if isnull TEXT_COLOR then
	TEXT_COLOR = (ViewSetup[]).text_color;
    endif


    if allfalse LIG_gtextcolored then color = TEXT_COLOR; endif

    local y = first GOBJ_LIG_ViewOrientation;
    local z = second GOBJ_LIG_ViewOrientation;
    local x = rot3d_vCross GOBJ_LIG_ViewOrientation;
    local diag = rot3d_vNormalize (x + y - z * 0.0001); // draw behind DD text

	// When multiple molecules get overlayed, their annotation labels
	// become unreadable.  Such groups (clusters) of ann.pts are denoted
	// by the same, non-zero value of DL_group.  We vertically offset
	// the labels of ann.pts in the same group.  The labels are placed
	// (very close) below each other.

#if USE_DL_GROUP
    static YOFS;
    if isnull YOFS then
	YOFS = (max [(ViewSetup[]).text_base_size, 0.2] + 0.05) * 1.1;
    endif

    if anytrue DL_group then
	local g = cat DL_group | m_text;
	local gofs = YOFS * (0.5 * y * [cat DL_grank | m_text | g]);

	    // Each group is denoted by the same value of g.
	    // Replace the coordinates of the points in each group with
	    // the coordinates of the centroid of the group.
#if 1
	local k;
	for k in pack uniq g loop
	    local m = g == k;
	    local pos_k = pos || [m];
	    pos_k = app add pos_k * invz add m;
	    pos || [m] = pos_k;
	endloop
#endif
	pos || [g] = (pos || [g]) - gofs;
    endif
#endif


	// Position the text to the top-right of the annotation sphere

//  [rad, pos, normal_to_eye] = AffSphereHorizon [A, rad, pos];
//  local top_rightV = ...
//  local top_rightW = ...

//  pos = pos + top_rightW;
//  if anytrue DL_group then if anytrue g = cat DL_group | m_text then
//	for k in pack uniq g loop ... use group centroids ... endloop
//	local posG = pos || [g];
//	local textHeight = AffTextHeight [A, posG];
//	local y = second AffXYZ [A, posG]
//	local grankG = cat DL_grank | m_text | g;
//	pos || [g] = posG - textHeight * 1.05 * (0.5 * y * [grankG]);
//  endif endif


// !!! when the lig.atoms should be drawn (a little bit) more toward the eye,
// esp. when nearby atoms and dummies obscure the view.

    GText cat [GOBJ_LIG_key, [color], pos + RAD * diag, [text | m_text]];

    until not (running = dec running) endloop
endfunction

#if SHOW_DL_SAMEAIDX
local function draw_lig_pvectors[]

#if DL_BURIED_GVERTEX
    if anytrue DL_buried then			// need GPoints, i.e. key2
    elseif isnull DL_x or not LIG_pvectors then	// no ann.pts or no lines
#else
    if isnull DL_x or not LIG_pvectors then	// no ann.pts or no lines
#endif

	GDestroy GOBJ_LIG_key2;
	GOBJ_LIG_key2 = 0;
	return;
    endif

    GOBJ_LIG_key2 = _GCreateUnique GOBJ_LIG_name2;
    local i;

    for i = 1, length DL_atom loop
	local x = DL_x(i), y = DL_y(i), z = DL_z(i), c = DL_color(i);
#if DL_BURIED_GVERTEX
	if anytrue DL_buried(i) then
	    local m = DL_buried(i);
	    GPoint [GOBJ_LIG_key2, c|m, x|m, y|m, z|m];
	endif
	if not LIG_pvectors then continue; endif
#endif
	local j1 = DL_tail(i);
	local j2 = DL_head(i);
	[j1, j2] = [j1, j2] || not [DL_buried(i)[j1] or DL_buried(i)[j2]];
	GLine [GOBJ_LIG_key2, c[j2], x[j1], y[j1], z[j1], x[j2], y[j2], z[j2]];
    endloop
endfunction
#endif

local function ensure_que_dummies;

// Create ligand annotation dummies or update their positions and
// other properties.

// ensure_lig_dummies ensures that all DL_atom dummies are valid and their
// atoms reflect the values of DL_xxx, except for positions of already
// valid dummies.  Positions of newly created dummies are set to DL_x/y/z.
// If any dummies are created or destroyed, or if full_check=2,
// the query will is redrawn.

local function ensure_lig_dummies full_check	// (M1)
    local redraw = full_check === 2;

	// Verify the query chain.  (Create/recreate if not valid.)

    if not ph4lig_chain_ok[] then
	if DBG then event 'lig_create_c'; endif
	loadstore_view 1; // Reset view parameters to values before Close[]

	CHAIN_LIG_key = oCreate 0;
	cSetName [CHAIN_LIG_key, CHAIN_LIG_NAME];
	cSetTag [CHAIN_LIG_key, CHAIN_LIG_tag];
    endif

    local r = cat oChildren CHAIN_LIG_key;

	// Sync the number of chain residues with DL_xxx.
	// Destroy excess residues, without destroying their atoms
	// (if possible).  Create missing residues.

    local n = length DL_atom;
    local n_missing_res = n - length r;
    local r2;

    if n_missing_res < 0 then	// too many residues: drop the last few
	if DBG then event 'lig_destroy_r'; endif
	full_check = 1;
	r2 = keep [r, n_missing_res];		// residues to destroy
	if n then oReparent [cat oChildren r2, r(1)]; endif // keep the atoms
	oDestroy r2;
	r = keep [r, n];
    elseif n_missing_res > 0 then // too few residues: create a few new ones
	if DBG then event 'lig_create_r'; endif
	full_check = 1;
	r2 = oCreate rep [CHAIN_LIG_key, n_missing_res]; // new residues
	r = cat [r, r2];
    endif

	// Destroy excess (dangling) dummies (dummies not in DL_atom).

    local cur_atoms = cat oChildren r;
    local m = m_diff [cur_atoms, cat DL_atom];	// dangling dummies
    if anytrue m then
	if DBG then event 'lig_destroy_a'; endif
	full_check = 1;
	redraw = 1;
	oDestroy (cur_atoms | m);		// destroy dangling dummies
	cur_atoms = cur_atoms | not m;
    endif

	// Create missing dummies (DL_atom's without dummies).

    m = split [m_diff [cat DL_atom, cur_atoms], app length DL_atom];
    local i, a, pos;
    for i = 1, length DL_atom loop
	if allfalse m(i) then continue; endif
	if DBG then event 'lig_create_a'; endif
	redraw = 1;
	a = oCreate (r(i) | m(i));		// create missing dummies
	aSetInert [a, 1];
	aSetElement [a, 'LP'];
	aSetColorBy [a, 'rgb'];
	if alltrue m(i) then
	    DL_atom(i) = a;
	    aSetPos [a, [DL_x(i),DL_y(i),DL_z(i)]];
	else
	    // DL_atom(i) = unpack [a, DL_atom(i) | not m(i), m(i)];
	    DL_atom(i) = mput [DL_atom(i), m(i), a];
	    aSetPos [a, [DL_x(i),DL_y(i),DL_z(i)] || [m(i)]];
	    oReparent [DL_atom(i), r(i)];
	endif
    endloop

	// Update positions of dummies
	// !!! fix this

    for i = 1, length DL_atom loop
	if eqL [[DL_x(i),DL_y(i),DL_z(i)], aPos DL_atom(i)] then continue; endif
	redraw = 1;
	if DBG then event 'lig_pos'; endif
	aSetPos [DL_atom(i), [DL_x(i), DL_y(i), DL_z(i)]];
#ifnot APOS_IS_DOUBLE
	// Make sure that (double)pos === (float)pos;
	pos = aPos DL_atom(i);
	DL_x(i) = pos(1);
	DL_y(i) = pos(2);
	DL_z(i) = pos(3);
#endif
    endloop

	// If any atoms changed, we redraw the graphics objects
	// and force a full check

    if redraw then
	// !!! should be called explicitly by the caller (when needed)
	draw_lig_text[];
	full_check = 1;
    endif
#if SHOW_DL_SAMEAIDX
// !!! should be called explicitly by the caller (when needed)
    // draw_lig_pvectors[];
#endif

	// If only a minimum checking is requested, we are done.
	// (The DL_atom are now all valid, even though they may be
	// of wrong color, wrong type or belong to wrong residues...)

    if allfalse full_check then return; endif

	// Verify indices of dummy atoms.  Reparent if necessary.

    a = DL_atom;
    if anyfalse (oParent a == r) then oReparent [a, r]; endif

	// Set common and individual a. properties (avoid redraw if possible)

    local look = 'small-sphere';

#ifnot DL_BURIED_GVERTEX
    if length DL_buried then look || DL_buried = 'point'; endif
#endif

    if anyfalse (aElement a == 'LP') then aSetElement [a, 'LP']; endif
    if anyfalse (aInert a == 1) then aSetInert [a, 1]; endif
    if anyfalse (aColorBy a == 'rgb') then aSetColorBy [a, 'rgb']; endif
    if anyfalse (aNucleusLook a == look) then aSetNucleusLook [a, look]; endif

    if neL [aRGB a, DL_color] then aSetRGB [a, DL_color]; endif

	// Hide DL atoms that are either buried or share xyz with
	// DD atoms (within EPS).  (Clicking on a shared location
	// will therefore select the DD atom, not the DL atom.)

    ensure_que_dummies 0;	// ensure DD_atom handles
    local a0 = cat a;		// flat DL_atoms (ann.pts dummies)

    local dd_shown = not bitand [DD_gbits, GBIT_HIDDEN];
#if DL_BURIED_GVERTEX
    local dl_hidden = cat DL_buried;
#else
    local dl_hidden = m_null a0;
#endif
    if anytrue dd_shown then
	local a1 = cat (DD_atom || dd_shown);	// flat visible DD_atoms
	local EPS = 0.01;
	local prox = prox_open [EPS, aPos a0, EPS];
	local [seg, idx] = prox_find [prox, aPos a1, 0];
	dl_hidden[idx] = 1;	// hide DL_atoms coincident w/visible DD_atoms
    endif
    aSetHidden [a0, dl_hidden];

#if USE_DL_arad
// !!! We should mark ann.pts (and center-only que.features) that are hidden
// !!! by biger atoms

	// Find which annotation atoms are close to visible heavy atoms
	// that of of nucleus look small-sphere or sphere.

    a1 = Atoms[];
    a1 = a1 | aAtomicNumber a1;
    a1 = a1 | not aHidden a1;
#ifnot DL_BURIED_GVERTEX
    local a1look = aNucleusLook a1;
    local a2 = a1 | a1look == 'point';
    a1 = a1 | m_join [a1look, ['small-sphere', 'sphere']];
#else
    a1 = a1 | m_join [aNucleusLook a1, ['small-sphere', 'sphere']];
#endif

    [seg, idx] = prox_find [prox, aPos a1, 0];
    prox_close prox;

    local DL_arad = maxE [s_max [aDisplayRadius a1[idx], seg], 0];

#ifnot DL_BURIED_GVERTEX
    if length DL_buried then
	a0 = cat DL_atom | cat DL_buried;
	prox = prox_open [EPS, aPos a0, EPS];
	[seg, idx] = prox_find [prox, aPos a2, 0];
	prox_close prox;

	local r = maxE [s_max [aDisplayRadius a2[idx], seg], 0];
	DL_arad = maxE [DL_arad, unpack [r, 0, cat DL_buried]];
    endif
#endif

    DL_arad = split [DL_arad, app length DL_atom];
#endif


    loadstore_view 0;	// Store view parameters to be restored on Close[]
endfunction


// scheme_mask returns the last scheme mask used for a given scheme.
// If the scheme has not yet been used, we use the scheme default mask.

// Get the current scheme mask of the scheme.  If not yet set, set
// it to the scheme default mask.

local function scheme_mask scheme
    if isnull SCHEME_mask.(scheme) then
	SCHEME_mask.(scheme) = ph4_SchemeDefmask scheme;
    endif
    return SCHEME_mask.(scheme);
endfunction

// GetSmask/SetSmask gets/sets the mask of the currently shown ann.types.
// 1) GetSmask[] returns the mask of the currently shown ann.types.
// 2) GetSmask 'scheme' returns the mask used the last time the given scheme
//    was used or the default mask for the given scheme.
// 3) SetSmask sets the mask of ann.types to be shown.  Special mask values:
//    []=default for the cur.scheme, 0:show none, -1:show all
//    (Lig.annot's need to be updated for the change to take a visible effect.)
// Note: In addition to smask, the annotation also needs svalMin,
//    showProjectionVectors, allReceptorSurface etc.

local function _scheme_mask [do_get, scheme, mask]
    static stbl;
    if isnull scheme then scheme = SCHEME_name; endif
    if do_get then mask = stbl.(scheme); endif
    if isnull mask then mask = ph4_SchemeDefmask scheme; endif
    return stbl.(scheme) = mask;
endfunction

local function SchemeMask scheme = _scheme_mask [1, scheme];
local function SchemeSetMask mask = _scheme_mask [0, [], mask];

// Returns groups of atoms of the same cTagId, each split by RLC class:
// tr [ctag, rec, sol, lig].  The rec/sol/lig sets may be empty.
// The lig set is further split into (non-empty) connected components.
// The argument is a vector of RLC classes (tokens) that are needed;
// sets of RLC classes not present in the argument are returned as [].
// The function returns all tags of non-private chains, including those
// with no atoms or those with all atoms inert. 'unk' atoms are ignored.
// (Private chains have cName that starts with the prefix "[PRIVATE]".)

local function GetGroups []

	// Drop private chains and split by tag.

    local chains = Chains[];			// collect by cTagId
    chains = chains | not m_findmatch ['[[]PRIVATE]*', cName chains];
    local [idx, seg] = sac cTagId chains;
    local ctag = cTag chains[idx | ctom seg];
    local atoms = app cat split [cAtoms chains[idx], seg];
    atoms = atoms || (aAtomicNumber atoms or aIsLight atoms);
    local class = aClassRLS atoms;

	// Split each group of atoms of the same tag into rec+sol+lig.
	// Split lig into connected component.  (Ignore 'unk' atoms).
	// NOTE: we rely on dummies being reported as 'unk'.

    local i, rec = rep [[], length ctag], sol = rec, lig = rec;
    for i = 1, length ctag loop
	// idx = indicesof [RLS, class(i)];
	idx = indicesof [['rec','sol','lig'], class(i)];
	local a = atoms(i);
	rec(i) = a[idx(1)];
	sol(i) = a[idx(2)];
	local ll = a[idx(3)];
	lig(i) = apt get [[ll], graph_ccomponent_list BondGraph ll];
    endloop
    return [ctag, rec, sol, lig];
endfunction

// Return all properties that affect annotations of given atoms.
// If any these values change, annotations will be recalculated.

local function AnnotationState atoms
    local residues = uniq oParent atoms;
    local chains = uniq oParent residues;
    return [
	cTag chains,
	aPos atoms,
	aInert atoms,
	aHidden atoms,
	aClassRLS atoms,
	chains, residues, atoms,
	aElement atoms,
	aBonds atoms,
	aHintLP atoms,
	aGeometry atoms,
	aIon atoms
    ];
endfunction

// update_lig_annotation calculates positions of ligand annotation.
// The ann.ptrs are calculated on atoms of chains lig_chains.
// The features positions, radii, and types are stored in variables
// DL_x/y/z, DL_r, and DL_expr, respectively.

// At the end, call ensure_lig_dummies to create dummies or update their
// positions and other properties.  Call draw_lig_text to draw annotation text.

local function update_lig_annotation force	// (M1)
    local i;
    static LAST_nonview, LAST_astate;

	// Return a value, such that no change in the value guarantees
	// that the annotations do not need to be recalculated

    local function system_astate []
	local aa = Atoms[];
	// Note: in the future, oCollections may need to be monitored, too.
	return [
	    SystemTopologyState[], cTag Chains[],
	    aPos aa, aInert aa, aHidden aa, aClassRLS aa
	];
    endfunction

    if eqL [LAST_nonview, LAST_nonview = SystemNonviewState[]] then
	if allfalse force then return; endif
    elseif eqL [LAST_astate, LAST_astate = system_astate[]] then
	if allfalse force then return; endif
    endif

    if DBG then event 'lig_annotation'; endif
    MATCH_update = 1;


	// Get RLS sets for each non-private chain tag in the system.
	// Strip inert receptor atoms and all solvent atoms.

    local [ctag, rec, sol, lig] = GetGroups [];

// !!! solvent:
// To find pockets to be annotated, we use only receptor heavy atoms.
// To determine what is buried, we use rec+sol (even if ann.sol.only).
// When solvent (e.g. H2O) is annotated, the projecting atom (i.e. O)
// is always annotated.
//
// Note: hydrogens will be used only if use_Hs:1 and only on atoms
// that contain explicit hydrogens.  Otherwise, use heavy angles only.

	// If the current ph4 scheme does not support receptor
	// annotation, pretend the receptor and solvent does not exist.
	// Record whether or not there is any rec/sol/lig.

    LIG_hasrec = LIG_hassol = 0;

    if not ph4_AnnotationRecOK SCHEME_name then
	rec = app null rec;
	sol = app null sol;
    else

	// Keep only ert rec and lig atoms.  Keep only ligands that contain
	// an ert atom.  Since we display annotation only on visible atoms,
	// we also remove ligands that are completely hidden.

	rec = rec || not aInert rec;	// strip inert receptor atoms
	sol = sol || not aInert sol;	// strip inert solvent atoms

	local m_rec = app anytrue not aHidden rec;
	local m_sol = app anytrue not aHidden sol;
	if anyfalse [m_rec, m_sol] then
	    [rec, sol] = [rec, sol] || [m_rec or m_sol];
	endif

	LIG_hasrec = anytrue m_rec;
	LIG_hassol = anytrue m_sol;
    endif

    for i = 1, length lig loop
	lig(i) = lig(i) | app anyfalse aInert lig(i);	// must have ert atoms
	lig(i) = lig(i) | app anyfalse aHidden lig(i);	// must have vis.atoms
    endloop

    LIG_haslig = anytrue lig;

	// Bumpcheck mode: rec/sol ann.pts are blocked by corresponding sol/rec

    // const BMODE = 1;	// rec always blocks sol; sol always blocks rec
    // const BMODE = 2;	// rec blocks sol if rec on; sol blocks rec if sol on
    const BMODE = 3;	// rec always blocks sol; sol blocks rec if sol on

	// If the rec/sol/lig toggle button is off,
	// strip the groups of rec/sol/lig, resp.

    if BMODE == 1 then		// rec/sol always blocks sol/rec
	if allfalse keep [LIG_rsl, 2] then
	    rec = app null rec;
	    sol = app null sol;
	endif
    elseif BMODE == 2 then	// rec/sol blocks sol/rec only if on
	if not LIG_rsl(1) then rec = app null rec; endif
	if not LIG_rsl(2) then sol = app null sol; endif
    elseif BMODE == 3 then	// rec aways blocks sol, sol blocks rec if on
	if not LIG_rsl(2) then
	    sol = app null sol;
	    if not LIG_rsl(1) then rec = app null rec; endif
	endif
    endif

    if not LIG_rsl(3) then lig = app null lig; endif

    [rec, sol] = [rec, sol] || [app length rec or app length sol];
    LIG_nrec = length rec;

	// Flatten all ligands into the same list, regardless of tag.
	// !!! ms: this might change in the future

	// GROUP_ORDER: LIG_atom is a list of group of atoms, with
	// each group being annotated separately.  The first LIG_nrec
	// groups are receptors.  The next LIG_nrec groups are solvents.
	// The remaing groups are ligands.  (The annotation on rec&sol
	// is calculated differently than the annotation on ligands).

    LIG_atom = [rec, sol, cat lig];
    LIG_seg = app length LIG_atom;
    LIG_atom = cat LIG_atom; rec = sol = lig = [];

	// If the groups of atoms submitted for annotation
	// have not changed, do not recalculate the annotation
	// and only ensure the annotation dummies and re-draw
	// the labels.
	// Note: cmask(i) == 0:	i-th group is new or modified (re-annotate)
	// cmask(i) == j:	i-th group used to be j-th group (leave as-is)

    local cmask = indexof reverse [			// find new in old
	DL_astate,					// old value
	DL_astate = app AnnotationState LIG_atom	// new value
    ];
    if alltrue force then		// force recalculation of all rsl
	cmask = m_null cmask;
    elseif allfalse force then		// recalculate only what has changed
    elseif length force == 3 then	// selectively force some of r,s,l
	cmask | stretch [force, LIG_seg] = 0;
    endif

	// If rec/sol changes, force reset in the corresponding sol/rec.

    local iR = igen LIG_nrec;
    local iS = iR + LIG_nrec;
    cmask[iR | not cmask[iS]] = 0;
    cmask[iS | not cmask[iR]] = 0;

    local cidx = pack cmask;				// already annotated

	// Keep dummies of the groups that are already annotated.

    DL_atom =	unpack [DL_atom[cidx],	[[]], cmask];
    DL_x =	unpack [DL_x[cidx],	[[]], cmask];
    DL_y =	unpack [DL_y[cidx],	[[]], cmask];
    DL_z =	unpack [DL_z[cidx],	[[]], cmask];
    // DL_r =	unpack [DL_r[cidx],	[[]], cmask];
    DL_index =	unpack [DL_index[cidx],	[[]], cmask];
#if USE_DARKGREEN
    DL_expr2 =	unpack [DL_expr2[cidx],	[[]], cmask];
#else
#endif
    DL_expr =	unpack [DL_expr[cidx],	[[]], cmask];
    DL_bits =	unpack [DL_bits[cidx],	[[]], cmask];
    DL_buried =	unpack [DL_buried[cidx], [[]], cmask];
    DL_color =	unpack [DL_color[cidx],	[[]], cmask];
    DL_sval =	unpack [DL_sval[cidx],	[[]], cmask];
#if SHOW_DL_SAMEAIDX
    DL_tail =	unpack [DL_tail[cidx],	[[]], cmask];
    DL_head =	unpack [DL_head[cidx],	[[]], cmask];
#endif
    cidx = [];	// no longer needed

	// For each ligand chain that needs to be updated,
	// calculate a list of features and store them in DL_xxx variables

    local smask = scheme_mask SCHEME_name;

#if 0
	// Highlight (in red) the label of the group whose annotation is
	// is being calculated.  (This will become noticeable only if
	// the annotation takes long time, e.g. with big proteins or
	// numerous ligands.)

    local LIG_hasrsl = [LIG_hasrec, LIG_hassol, LIG_haslig];
    local rsl_col0 = select ['none', 'grayed', LIG_hasrsl];
    local rsl_col1 = apt mput [rsl_col0, matid 3, 'baseRed'];
    local rsl_col = cat [[rsl_col0], tr apt stretch [rsl_col1, [LIG_seg]]];
#endif

	// Prepare options for annotating receptors&solvents, optR,
	// and options for annotating ligands, optL.

    local oth; // !!! not finished
    local opt = [
	use_Hs: LIG_use_Hs
    ];

    if SCHEME_svalOK then opt.svalMin = LIG_svalMin; endif

    local optR = opt, optL = opt;
    optR.no_alpha = LIG_allrec;	// !!! optR.ratoms
    // !!! old: optL.use_Hs= LIG_use_Hs(3)

	// (Re)annotate groups of atoms that have changed.

    for i in x_pack not cmask loop	// groups to be annotated

	    // Calculate features

	local a = LIG_atom(i);

	local apos = aPos a;
	local abits, gfbits, gfaidx, gfpos, amask, gfmask;
	local map = [], fbits1, gpos1;
	local am0 = aHidden a;				// hidden atoms
	local eopt = [];

	    // Annotate the i-th group of atoms as a receptor (or solvent).
	    // (GROUP_ORDER: rec: 0<i<NR, sol: NR<i<=2*NR, lig: 2*NR<i,
	    // where NR=LIG_nrec.)

	if i <= 2*LIG_nrec then		// receptor
	    local is_sol = i > LIG_nrec;
	    if not LIG_rsl(is_sol + 1) then continue; endif
	    eopt.rec = 1;
	    // local eatoms = LIG_atom(i - sgn [LIG_nrec, is_sol]);
	    // eatoms = eatoms | aAtomicNumber eatoms > 1;
	    optR._sol	= is_sol;
	    optR.eatoms	= LIG_atom(i - sgn [LIG_nrec, is_sol]);
		// !!! optR.is_sol: is_sol,
		// !!! ignore: indices of hidden atoms

	    [map, abits, gfbits, gfpos, oth] =
		ph4_AnnotationRec [SCHEME_name, a, smask, optR];
	    [amask, gfmask] = zero [abits, gfbits];

	    // Annotate the i-th group of atoms as a ligand.
	    // (GROUP_ORDER: rec: 0<i<NR, sol: NR<i<=2*NR, lig: 2*NR<i,\
	    // where NR=LIG_nrec.)

	else			// ligand
	    [map, abits, gfbits, oth] =
		ph4_AnnotationMap [SCHEME_name, a, smask, optL];

	    [gfpos] = ph4_AnnotationPos [map, [apos], optL];
	    [[amask], [gfmask]] =
		ph4_AnnotationEmask [map, [apos], [gfpos], optL];
	endif
// !!! SMASK
	    // Apply the feature mask explicitly:
	    // just in case the scheme won't do it

	[abits, gfbits] = bitand [[abits, gfbits], smask];

	    // Remove annotation points defined by hidden atoms.
	    // (If any of the atoms defining an annotation point
	    // is hidden, remove the annotation point.)

	gfaidx = ph4_AnnotationAidx [map];
	local gm0 = am0[cat gfaidx];			// hidden gpoints
	if not isflat gfaidx then gm0 = s_max [gm0, app length gfaidx]; endif
	abits | am0 = 0;
	gfbits | gm0 = 0;


#if USE_ATOMQ
	    // Don't display atom bits, even if they are explicitly specified.

	abits = bitand [abits, 0x1fffffff];	// MASK = ICODE_ATOMQ - 1
#endif

	local fbits = cat [abits, gfbits];
	local lf_type = pack fbits;		// active ann.pts
	local ignore = x_pack not fbits;	// indices of inactive
	local imap = unpack [x_id lf_type, 0, fbits]; // x_active=imap[x_all]
	local [p1, p2] = ph4_AnnotationPairs [map, [ignore: ignore]];

	    // Connect projecting and projected annotation points.
	    // If annotating the receptor, the meaning of "projecting"
	    // and "projected" is reversed, e.g. "Don" becomes projected.

#if SHOW_DL_SAMEAIDX
	DL_tail(i) = imap[p1];
	DL_head(i) = imap[p2];
#endif

// !!! SMASK
	local lf_pos = apt cat [apos || [abits], gfpos || [gfbits]];
	local lf_buried = cat [amask | abits, gfmask | gfbits];
	local lf_index = unpack [0, x_pack not lf_buried, lf_buried];

	DL_sval(i) = [];
	if SCHEME_svalOK then
	    local [stag, snum] = untag oth.sval;
	    snum = snum || [fbits];
	    DL_sval(i) = tag [stag, snum];
	endif

	    // Reuse dummies of already annotated groups
	    // Note: It is important to keep correct association between
	    // the dummies and the ligand ann.pts, because the selection
	    // state of the ann.pts is kept only as the selection state
	    // of the corresponding dummies.  For example, if the user
	    // selects the dummy of the ann.pt. of a ring center, the
	    // dummy should stay selected even as it gets recalculated
	    // and repositioned when the ring atoms move.  (Some errors
	    // in the selection state in pathological cases are acceptable.)

	if isnull DL_expr(i) then			// all dummies new
	    DL_atom(i) = zero lf_index;			// init to 0
	elseif neL [lf_index, DL_index(i)] then		// keep some dummies
	    local amap = indexof [lf_index, DL_index(i)];	// keep these
	    amap | not lf_index = 0;
	    DL_atom(i) = unpack [DL_atom(i)[pack amap], 0, amap];
	    // local amap = indexof [lf_index, DL_expr(i)];	// keep these
	    // DL_atom(i) = unpack [DL_atom(i)[pack amap], 1, amap];
	else						// keep all dummies
	    // DL_atom(i) = DL_atoms(i);			// as-is
	endif
	DL_index(i) = lf_index;

	    // Set new positions

	DL_x(i) = lf_pos(1);
	DL_y(i) = lf_pos(2);
	DL_z(i) = lf_pos(3);

#if USE_DARKGREEN
	DL_expr2(i) =
	DL_expr(i) = ph4_SchemeBitsExpr [SCHEME_name, lf_type, eopt];
	if SCHEME_svalOK then if anytrue DL_sval(i) then
	    eopt.sval = DL_sval(i);
	    DL_expr2(i) = ph4_SchemeBitsExpr [SCHEME_name, lf_type, eopt];
	endif endif
#else
	DL_expr(i) = ph4_SchemeBitsExpr [SCHEME_name, lf_type, eopt];
#endif
	DL_bits(i) = lf_type;
	DL_color(i) = ph4_SchemeBitsColor [SCHEME_name, lf_type];

#if 1
	DL_buried(i) = lf_buried;
#endif
    endloop

	// When multiple molecules get overlayed, their annotation labels
	// become unreadable.  Here we find groups (clusters) of ann.pts
	// positioned on top of each other and rank the points within
	// each group, so that their labels can then be separated
	// by additional y-offset.  The cluster size is GROUP_RAD.

#if USE_DL_GROUP
#if USE_DARKGREEN
    local m_text = LIG_rsl >= 2;
#else
    local m_text = LIG_rsl == 2;
#endif
    m_text = stretch [m_text, [LIG_nrec, LIG_nrec, length DL_x - 2*LIG_nrec]];
    m_text = stretch [m_text, app length DL_x];

    local pos = app cat [DL_x, DL_y, DL_z];
    pos = pos || [m_text];

    local pkey = prox_open [GROUP_RAD, pos, GROUP_RAD];
    local [seg, idx] = prox_find [pkey, pos, 0];
    prox_close pkey;

    local leader = s_min [idx, seg];		// group leader
    local gnum = select [leader, 0, seg > 1];	// group number
    gnum = unpack [gnum, 0, m_text];
    gnum | gnum = prank pack gnum;		// remove gaps in gnum

    DL_group = split [gnum, app length DL_atom];

    local [k_, m_] = sam pack gnum;
    local grank = unpack [perm [x_id m_ - frank mtob m_, k_], 0, gnum];
    DL_grank = split [grank, app length DL_atom];
    // !!! DL_gsel = [];
#endif

#if USE_DL_SEL
    DL_sel = [];
#endif

	// Create dummies and draw text

    ensure_lig_dummies 1;	// force create/update ligand annotation dummies
    draw_lig_text[];		// draw ligand annotation text
#if SHOW_DL_SAMEAIDX
    draw_lig_pvectors[];
#endif

	// Prevent double update from the monitor.

    LAST_nonview = SystemNonviewState[];
    LAST_astate = system_astate[];

endfunction


// ============================== GUI ==============================

// NOTE: Volume constraint types: [0, V_EBIT_ALL=0x2, V_EBIT_ANY=0x4]
// Excluded:	0: no matching atoms inside the volume
// Lig.shape:	*ALL: all matching atoms inside the volume (exclude exterior)
// Occupied:	*ANY: at least one heavy matching atom inside

const ACTION = ['Open...', 'Save...', 'Search...', 'Close'];

const V_EBIT_ALL	= 0x2;	// lig.shape: include all (exclude exterior)
const V_EBIT_ANY	= 0x4;	// occupied: include some
const V_EBITMASK	= 0x6;
const V_EBITS	= [0,		V_EBIT_ALL,	V_EBIT_ANY];
const V_OPTION	= ['Excluded',	'Ligand Shape',	'Occupied'];
const V_OPTION2	= append [V_OPTION, ''];

//	0x2:  exterior volume (vs. interior) "bounding" or "ligand shape"
//	0x4:  included volume (vs. excluded) "occupied"

const SVAL_ACC_SHORTCUT = [
   '0.3  (H-S in CYS)',
   '1.2  (H-O in SER, THR, H-C-NH3+ in LYS+)',
   '1.8  (H-O in TYR)',
   '2.1  (H-NC=O backbone)',
   '2.3  (H-NC=O in ASN, GLN)',
   '2.4  (H-N in TRP)',
   '2.8  (H-N in HIS)',
   '3.5  (H-N in ARG+)',
   '4.6  (H-N in HIS+)',
   '6.4  (H-N in LYS+)'
];
const SVAL_DON_SHORTCUT = [
   '0.9  (O-H in TYR)',
   '1.4  (O-H in SER, THR, S in MET CYS)',
   '2.0  (O= in ASN, GLN, backbone)',
   '2.4  (N in HIS)',
   '3.0  (OC=O in ASP-, GLU-)'
];

const SVAL_MODVAL_SHORTCUT = [
    // '0.5','0.6','0.7','0.8','0.9','1.0','1.1','1.2','1.3','1.4','1.5','1.6'
    '0.5','0.8','1.0','1.2','1.5','2.0','3.0'
];

// update_ph4title returns the title of the query panel.  The title
// is composed of a unique task_title/window_name prefix and
// an optional suffix identifying the "current" ph4 file and
// an indication of whether or not the current contents has been
// modified, e.g. "Pharmacophore Query Editor (2) [+ foo.ph4]

local function update_ph4title wkey
    static fn, last_fn, last_fplus;

	// Ensure that fn represent the currently loaded ph4 query filename.
	// fn(1) shows the filename as-is. fn(2) prefixes it with "+".
	// E.g. fn = ['Ph4 Editor [foo.ph4]', 'Ph4 Editor [+foo.ph4]'].

    if neL [last_fn, last_fn = QUE_fname] then
	fn = ftail QUE_fname;
	if tok_length fn > 12 then
	    if not leL [1, tok_length fext fn, 4] then fn = ftrimname [fn,12];
	    else fn = tok_cat [ftrimname [fbase fn, 10], fext fn];
	    endif
	endif

	if allfalse fn then
	    fn = tok_cat [WIN_QUE_TITLE, ['', '']];
	else
	    fn = tok_cat [WIN_QUE_TITLE, ' [', ['','+'], fn, ']'];
	endif

	// If neither QUE_fname nor QUE_fplus has changed from their previos
	// value, do nothing.

    elseif eqL [last_fplus, QUE_fplus = QUE_fplus or QUE_changed] then
	// return;
    endif

	// Set the new window title. Note: "+" is added to the title
	// iff changes have been made to the ph4 data loaded from the file.

    // WindowSetAttr [wkey, [shell: [title: fn(inc (last_fplus = QUE_fplus))]]];
    WindowSetAttr [wkey, [shell: [title: fn(1)]]];
endfunction

// _tval_update implements tval_init/type/set/sync (cmd=0/1/2/3)
//
// These routines are used to update fg+bg of specified widgets to indicate
// whether or not the widget value has changed and whether the value is legal.
//
// tval_init	set given widgets to a given type; get their values from wkey
// tval_type	set given widgets to given type; update their look
// tval_set	set given widgets to given value; update their look
// tval_sync	update look of all widgets set by tval_init/type/sync
//
// Let A=previously set value, B=current widget value
// Then:
//	type:	note		background:	foreground:
//	-1	error		red		white
//	0	non-flt.pt.	none		A == B ? none : red
//	1	flt.pt.val	none		|A-B|<eps ? none : red

local function _tval_update [cmd, [wkey, v]]
    static _TVAL, _TTYPE;
    local attr, tvalS, tvalW, ttype;	// S=set value, W=current widget value

	// tval_init: set given types of given items and
	// initialize their set value to their current widget value.
	// NOTE: tval_init can be called multiple times to add more items
	// to the list of initialized items.

    if cmd == 0 then
	_TTYPE = tagcat [v, _TTYPE];
	_TVAL = tagcat [WindowGetData [wkey, tags v], _TVAL];
	return;

	// tval_type: set types of given items and update their look.

    elseif cmd ==  1 then
	[attr, ttype] = untag v;
	_TTYPE = tagput [_TTYPE, attr, ttype];

	tvalS = tagget [_TVAL, attr];				// set val
	tvalW = tagget [WindowGetData [wkey, attr], attr];	// curr.w.val

	// tval_set: set values of given items and update their look.

    elseif cmd == 2 then	// tval_set	... set given values
	[attr, tvalS] = untag v;
	tvalW = tagget [WindowGetData [wkey, attr], attr];	// curr.w.val
	_TVAL = tagput [_TVAL, attr, tvalS];
	WindowSetData [wkey, v | neE [tvalW, tvalS]];

	tvalW = tvalS;						// curr.w.val
	ttype = tagget [_TTYPE, attr];

	// tval_sync: update look all items (defined with tval_init)

    else			// tval_sync	... update all values
	[attr, ttype] = untag _TTYPE;
	tvalS = tagget [_TVAL, attr];
	tvalW = tagget [WindowGetData [wkey, attr], attr];	// curr.w.val
    endif

	// Prepare look index: 1=ok, 2=tvalS!=W, 3=err

    local idx = select [1, 2, eqE [tvalS, tvalW]];	// 1=same 2=diff
    local m = ttype == 1;				// mask of flt pt types
    idx | m = inc (abs sub [tvalS|m, tvalW|m] > 0.001); // 1=same 2=diff
    idx | ttype < 0 = 3;				// 3=err

	// Prepare the foreground and background for each look.

    local fg = ['none', DARK_RED, 'white'][idx];
    local bg = ['none', 'none',  DARK_RED][idx];

	// Set the foreground and background for each item.

    local i, A = [];
    for i = 1, length attr loop
	local name = attr(i);
	A.(name).foreground = fg(i);
	A.(name).background = bg(i);
    endloop
    WindowSetAttr [wkey, A];
endfunction

// (see _tval_update)

local function tval_init x	= _tval_update [0, x];
local function tval_type x	= _tval_update [1, x];
local function tval_set x	= _tval_update [2, x];
local function tval_sync x	= _tval_update [3, x];

local function edit_page_dd bhelp = [
    extendH:1,

    Hbox: [
	name: 'eD_type_hbox',
	flushLeft:0,
	extendH:1,

	Text: [
	    name: 'eD_type',
	    title:'F00:',
	    titleFont: 'mediumFixedBold',
	    len:25,	// !!! WT: WindowSetData miscalc's offset
	    onTrigger:'return',
	    shortcut:'',
	    extendH:1
	],
	Pager: [
	    Button: [
		name: 'eD_type_app',
		extendH: 1,
		text: 'Apply'
	    ],
	    Text: [
		len: 5
	    ]
	],
	bubbleHelp: third bhelp.eD_type
    ],

    Mbox: [
	extendH: 1,
	columns: 2,
	columnMajor: 1,
	// spacingH: 'medium',

	Checkbox: [
	    name:'button_ignore',
	    text: 'Ignore',
	    onTrigger: 'return', type: 'int',
	    bubbleHelp: bhelp.button_ignore
	],

	Pager: [
	    name: 'FV_pager',

	    Checkbox: [
		name: 'eD_essential',
		text:'Essential',
		onTrigger:'return',
		bubbleHelp: bhelp.eD_essential
	    ],
	    Option: [
		extendH: 1,
		name: 'eD_volumetype',
		text: V_OPTION,
		type: 'int',
		onTrigger:'return',
		bubbleHelp: bhelp.eD_volumetype
	    ]
	],		// FV_pager

	Hbox: [		// sphere radius
	    extendH:1,
	    title:' R:',
	    titleFont: 'mediumFixedBold',

	    Hbox: [
		name: 'eD_R_hbox',
		extendH:1,
		spacingH: 'none',

		Text: [
		    name:'eD_R_t',
		    titleFont: 'mediumFixedBold',
		    type:'real',
		    len: 5,
		    onTrigger:'return'
		],

		Wheel:[
		    name:'eD_R_w',
		    extendH:1,
		    resetButton:0,
		    width:3,
		    // min:-Inf, max:Inf,
		    min:0, max:20,
		    onTrigger:'return'
		],
		Button: [
		    name:'eD_R_set',
		    text: '  ',
		    onTrigger:'return'
		],
		bubbleHelp: bhelp.eD_R_w
	    ],

	    Pager: [
		name:'eD_dist_p',

		Text: [
		    name:'eD_dist',
		    sensitive:0,
		    len:5
		],
		Text: [
		    sensitive:0,
		    len:5
		],
		Text: [
		    name:'eD_dist_error',
		    value: 'Error',
		    sensitive:0,
		    len:5,
		    foreground: icolor 'Dark Gray',
		    bubbleHelp: bhelp.eD_dist_error
		],
		bubbleHelp: bhelp.eD_dist_p
	    ]
	],

	Pager: [
	    name: 'eD_use_sval_p',
	    // flushLeft: 1,
	    title:'  S:',
	    titleFont: 'mediumFixedBold',

	    Label: [ text: ' ' ],			// empty page (non-EHT)
	    Hbox: [					// EHT with Don or Acc
		name: 'eD_sval_hbox',
		extendH: 1,

		Pager: [
		    name: 'eD_svalType_p',
		    Option: [
			name: 'eD_svalType',
			text: ['Acc', 'Don'], type: 'char',
			value: 'Acc',
			// extendH: 1,
			onTrigger: 'return'
		    ],
		    Hbox: [
			spacingH: 'none',
			extendH:1,
			Separator: [shadow: 'none'],
			Label: [
			    name: 'eD_svalType_label',
			    extendH:1,
			    text: 'Acc'
			],
			Separator: [shadow: 'none']
		    ],
		    Text: [ len: 5 ]
		],

#if 1
		Pager: [
		    name: 'eD_useRval_p',

		    Hbox: [			// useRval=0: sval only
			Label: [
			    // bubbleHelp: bhelp.sval_threshold,
			    text: ' > '
			],
			Text:  [
			    name: 'eD_sval',
			    len: 6,
			    type: 'real',
			    min: 0.01, max: 100,
			    value: f100 SVAL_default.Acc,
			    onTrigger: 'return',
			    shortcut: SVAL_MODVAL_SHORTCUT
			],
			bubbleHelp: bhelp.eD_sval
		    ],

		    Hbox: [			// useRval=1: rval&mval
			Pager: [
			    Label: [
				text: ' x ',
				font: 'medium',
				extendH: 1
			    ],
			    Label: [ text: ' > ' ]
			],
			Text:  [
			    name: 'eD_rval',
			    len: 6,
			    type: 'real',
			    min: 0.01, max: 100,
			    value: f100 RVAL_default.Acc,
			    onTrigger: 'return',

			    bubbleHelp: bhelp.eD_rval
			],

			Label: [
			    // bubbleHelp: bhelp.rval_threshold,
			    text: ' > '
			],

			Text:  [
			    name: 'eD_mval',
			    len: 6,
			    type: 'real',
			    min: 0.01, max: 100,
			    value: f100 MVAL_default.Acc,
			    onTrigger: 'return',
			    bubbleHelp: bhelp.eD_mval,
			    shortcut: SVAL_MODVAL_SHORTCUT
			]
		    ]
		]
#endif
	    ]
	]
    ]
];


// !Note!: The 'constrain_*' triggers are detected with "m_findmatch" in the
// main event loop: constrain_type/nfeatures/sourceatoms/select/replace

local function edit_page_dc bhelp = [
    extendH:1,

    Hbox: [
	extendH: 1,
	title: 'Constrain:',

	Hbox: [
	    Radio: [
		name: 'constrain_type',
		columns: 1,
		text: ['Number of Features','Atoms / Projections'],
		onTrigger: 'return',
		type: 'int',
		bubbleHelp: bhelp.constrain_type
	    ],
	    Vbox: [
		extendH: 1,
		uniformCols: 1,
		spacingV: 'none',

		Option: [
		    extendH: 1,
		    name: 'constrain_nfeatures',
		    text: drop [second CTYPE, -2],	// !!!
		    onTrigger: 'return',
		    type: 'int',
		    bubbleHelp: bhelp.constrain_nfeatures
		],
		Option: [
		    extendH: 1,
		    name: 'constrain_sourceatoms',
		    onTrigger: 'return',
		    text: keep [second CTYPE, -2],	// !!!
		    type: 'int',
		    bubbleHelp: bhelp.constrain_sourceatoms
		]
	    ]
	],

	Separator: [
	    extendH: 1,
	    shadow: 'none'
	],
	Vbox: [
	    Button: [
		extendH: 1,
		flushLeft: 1,
		name: 'constrain_select',
		text: 'Select',
		font: 'mediumBold',
		onTrigger: 'return',
		bubbleHelp: bhelp.constrain_select
	    ],
	    Button: [
		extendH: 1,
		flushLeft: 1,
		name: 'constrain_replace',
		text: 'Replace',
		font: 'mediumBold',
		onTrigger: 'return',
		bubbleHelp: bhelp.constrain_replace
	    ]
	]
    ],

    Checkbox: [
	name: 'eC_ignore',
	text: 'Ignore',
	value: 0,
	type: 'int',
	onTrigger: 'return',
	bubbleHelp: bhelp.eC_ignore
    ]


#ifnot SHOW_DC_OPTION

#else

    , Hbox: [
	Pager: [
	    name: 'eC_show_p',
	    // flushLeft: 1,
// !!! #ifnot SHOW_DC_CONES
#if SHOW_DC_CONES
	    Option: [
		name: 'eC_show',
		title: 'Show:',
		text: ['None', 'Lines', 'Cones'],
		type: 'int',
		onTrigger: 'return'
	    ],
#else
	    Checkbox: [
		name: 'eC_show',
		text: 'Show',
		onTrigger: 'return',
		bubbleHelp: CONSTRAINT_SHOW_HELP
	    ],
#endif
	    Label: []
	]
    ]
#endif

];

const EPAGE_DUMMIES		= 1;
const EPAGE_CONSTRAINTS		= 2;
const EPAGE_EMPTYQUERY		= 3;
const EPAGE_NOSPHERES		= 4;
const EPAGE_EMPTYSEL		= 5;
const EPAGE_MANYCONSTRAINTS	= 6;
const EPAGE_MIXEDCONSVOLS	= 7;
const EPAGE_DIVERSESEL		= 8;
const EPAGE_NONE		= 9;

local function edit_page bhelp = [
    name:'edit_page_p',
    flushLeft:1,
    extendH:1,

    Vbox: edit_page_dd bhelp,	// EPAGE_DUMMIES: Edit spheres (features&vols)

    Vbox: edit_page_dc bhelp,	// EPAGE_CONSTRAINTS: Edit feature constraints

    Label: [ center:1, text:	// EPAGE_EMPTYQUERY: Query is empty
#	token
	The query is empty.  Press "Open" to read in an
	existing query. Press "Consensus" to calculate
	query features from aligned molecules.  Use the
	"New" buttons to manually create new features.\
#   ],

    Label: [ center:1, text:	// EPAGE_NOSPHERES: Query is empty
	'The query does not contain any features\n'
	'or volumes.  Press "Feature", "Volume" or\n'
	'"Union" to add features and volumes.'
    ],

    Label: [ center:1, text:	// EPAGE_EMPTYSEL: Selection is empty
	'No list items are selected.\n'
	'Select list items to be edited.'
    ],

    Label: [ center:1, text:	// EPAGE_MANYCONSTRAINTS: Too many constraints
	'Two or more constraints are selected.  Select\n'
	'only the single constraint to be edited.'
    ],

    Label: [ center:1, text:	// EPAGE_MIXEDCONSVOLS: Mixed const's & vol's
	'Selected list items contain constraints and\n'
	'volumes.  Remove either the constraints or\n'
	'the volumes from the selection.'
    ],

    Label: [ center:1, text:	// EPAGE_DIVERSESEL: Selection is too diverse
	'Selected list items are too diverse to be\n'
	'edited.  Change selection to only a single\n'
	'item or to several compatible items.'
    ]
];

local function down_arrow []
    local grob = gr_create [size: [8,16], units:'pt'];
    local color = 'foreground';
    local xy = [[1.5,6.5,4], [10.5,10.5,5]];
    gr_curve [grob, [0, xy, [0, 0], 1, color, 0, 0, color]];
    return grob;
endfunction;

local function set_edit_page;

local function ph4que_chain;

const CREATE_VLIG_HELP =
#   token
    Create new query ligand shapes from selected ligand atoms
    and/or template annotations in MOE, or from the entire ligand
    if none selected.  If Centroid is on, a single sphere positioned
    at the centroid of the atoms and annotations is created,
    otherwise a sphere is created per selected atom or annotation.
    Each shape has an associated atom expression; for a
    successful match to a ligand shape, any query atoms
    matching the expression must be found inside the shape.\
#;

const CREATE_VREC_HELP =
#   token
    Create new query excluded volumes from selected receptor
    atoms and/or template annotations in MOE, or from the entire
    receptor if none selected.  If Centroid is on, a single sphere
    positioned at the centroid of the atoms and annotations is
    created, otherwise a sphere is created per selected atom or
    annotation.  Each volume has an associated atom expression;
    for a successful match to an excluded volume, no query atoms
    matching the expression are permitted inside the volume.\
#;

const CREATE_VOCC_HELP =
#   token
    Create new query occupied volumes from selected receptor
    atoms and/or template annotations in MOE, or from the entire
    receptor if none selected.  If Centroid is on, a single sphere
    positioned at the centroid of the atoms and annotations is
    created, otherwise a sphere is created per selected atom or
    annotation.  Each volume has an associated atom expression;
    for a successful match to an occupied volume, the volume must
    contain at least one heavy atom matching the expression.\
#;

local function create_constraint;

// volume_popup display a popup for different volume types to create.
// The result is sent to the main event loop as the value of trigger
// 'trig_volume': 1=Excluded, 2=Ligand Shape, 3=Occupied

local function volume_popup [pkey, location]
    local bhelp = ph4_edit_bhelp [];

    function create_X k = cat [ Button: [
	name:		V_OPTION(k),
	extendH:	1,
	type:		'modint',
	modmask:	WMOD_SHIFT,
	onTrigger:	'return',
	text:		V_OPTION(k),
	bubbleHelp:	bhelp.volume_popup(k)
    ]];

    local wkey = WindowCreate [
	name: 'whichvol',
	mode: 'popup', location: location, mouseoutUnmap: 0,

	create_X(1),	// Excluded
	create_X(2),	// Ligand Shape
	create_X(3)	// Occupied
    ];

    WindowShow wkey;
    local [val, trig] = WindowWait wkey;
    local k = -sgn [indexof [trig, V_OPTION], bitand [val.(trig), WMOD_SHIFT]];
    WindowTrigger [pkey, [trig_volume: k]];
    exit[];
endfunction

// comment_popup: Puts up popup for editing comment.
//	Saves the edited comment into DS_comment.
// Returns: nothing

local function comment_popup [pkey, location]
    local wkey = WindowCreate [
	name: 'ph4_comment_shell',
	mode: 'popup', location: location, mouseoutUnmap: 0,
	foreground: 'textForeground',

	Edit: [
	    name: 'comment',
	    title: 'Comment:',
	    value: string DS_comment,
	    len:10,
	    width:50,
	    bubbleHelp:
		'Edits will only take effect after either '
		'OK or Apply is pressed.'
	],

	Button: [
	    name: 'action',
	    flushLeft: 1, extendH: 1,
	    text: ['OK', 'Cancel'],
	    font: 'mediumBold',
	    onTrigger: 'return', type: 'char',
	    bubbleHelp: [
		'Set the comment field of the query to the displayed\n'
		'text and close the window.',
		'Close the window without changing the comment field of '
		    'the query.'
	    ]
	]
    ];
    WindowShow wkey;

    loop
	local [v,trig] = WindowWait wkey;

	if trig == 'action' then
	    if v.(trig) == 'OK' then
		// !!! WT: edit widget returns token, not string!
		local str = string v.comment;
		WindowTrigger [pkey, [trig_comment: str]];
	    endif
	    break;
	endif
    endloop

    WindowDestroy wkey;
    exit[];
endfunction

static ico_eye;

const KEY_TRIGGER = [
    'Up','Down','Del',
    'Shift+Up','Shift+Down','Shift+Del',
    'Ctrl+Z', 'Ctrl+Y',
    'Ctrl+A', 'ESC'
];

local function create_ph4q_panel []
    local bhelp = ph4_edit_bhelp [];

    if isnull WIN_QUE_NAME then
	local base = 'Pharmacophore Editor';
	local i, wname = base;

	for i = 2, 99 loop
	    if not WindowKey wname then break; endif
	    wname = tok_cat [base, ' (', totok i, ')'];
	endloop

	WIN_QUE_NAME = WIN_QUE_TITLE = wname;
	task_settitle [-1, wname];
    endif

    local function mk_icon fn = gr_icon [fn, 'medium', 'foreground'];

    local ico_config	= mk_icon 'config.ico';
    local ico_left	= mk_icon 'fsb_go_left.ico';
    local ico_right	= mk_icon 'fsb_go_right.ico';
    local ico_up	= mk_icon 'arrow_top.ico';
    local ico_down	= mk_icon 'arrow_bottom.ico';
    local ico_delete	= mk_icon 'cancel.ico';
    local ico_meter	= mk_icon 'distmeter.ico';
    local ico_render	= mk_icon 'sysman_atomstyle_cpk.ico';
    ico_eye = app mk_icon [
	'eye.ico',
	'eye_cross.ico',
	'eye_check.ico',
	'eye_toggle.ico'
    ];

#if 1
    local Button_Q = [Button: [
	extendV: 1,
	extendH: 1,
	minWidth: 1,
	text: 'Q',
	name: 'que',		// default: on
	type: 'modint',
	modmask: WMOD_SHIFT,
	font: 'mediumBold',
	onTrigger: 'return',
	bubbleHelp: bhelp.que
    ]];
#endif

    // const TOO_FEW_FEATURES = 'Use abs.positions';
    // const TOO_FEW_FEATURES = 'Less than 3';
    const TOO_FEW_FEATURES = '<3 features ';

    local SEARCH_MESSAGE_1 = cat [ Hbox: [
	extendH: 1,
	Separator: [shadow: 'none'],

	Pager: [
	    extendH: 1,
	    name: 'msize_p2',
	    Label: [],				// 1
	    Hbox: [
		extendH: 1,
		Separator: [shadow: 'none'],
		Label: [
		    text: 'Full match ',	// 2
		    bubbleHelp:
			'The partial match requires all features\n'
			'to be matched; i.e. it is not "partial".'
		]
	    ],
	    Hbox: [
		extendH: 1,
		Separator: [shadow: 'none'],
		Label: [
		    text: 'Empty match OK ',	// 3
		    bubbleHelp:
			'The query admits hits of zero size,\n'
			'with NO matching features.\n'
			'This makes sense only for searching\n'
			'in "Absolute Positions" mode.'
		]
	    ],
	    Hbox: [
		extendH: 1,
		Separator: [shadow: 'none'],
		Label: [
		    text: 'No match ',		// 4
		    bubbleHelp:
			'The query admits hits of zero size,\n'
			'with NO matching features.\n'
			'This makes sense only for searching\n'
			'in "Absolute Positions" mode.'
		]
	    ],
	    Hbox: [
		extendH: 1,
		Separator: [shadow: 'none'],
		Label: [
		    text: 'No features ',	// 5
		    bubbleHelp:
			'The query contains no features.\n'
			'This makes sense only for searching\n'
			'in "Absolute Positions" mode.'
		]
	    ],
	    Hbox: [
		extendH: 1,
		Separator: [shadow: 'none'],
		Label: [
		    text: 'Illegal value ',	// 6
		    foreground: 'baseRed',
		    bubbleHelp:
			'The requested match size of the'
			' open query is illegal'
		]
	    ],
#if SHOW_ABSPOS_WARNING
	    Hbox: [
		extendH: 1,
		Separator: [shadow: 'none'],
		Label: [
		    text: TOO_FEW_FEATURES,	// 7
		    bubbleHelp:
			'The query minimum size is less than 3.\n'
			'This makes sense only for searching\n'
			'in "Absolute Positions" mode.'
		]
	    ],
#endif
	    foreground: 'baseBlue',
	    page:  2
	]
    ]];

    local SEARCH_MESSAGE_2 = cat [ Hbox: [
	extendH: 1,
	Separator: [shadow: 'none'],
	Pager: [
	    name: 'msize_p3',
	    Label: [],				// 1
	    Label: [
		text: 'No features ',		// 2
		bubbleHelp:
		    'The query contains no features.\n'
		    'This makes sense only for searching\n'
		    'in "Absolute Positions" mode.'
	    ],
#if SHOW_ABSPOS_WARNING
	    Label: [
		text: TOO_FEW_FEATURES,		// 3
		bubbleHelp:
		    'The query size is less than 3.\n'
		    'This makes sense only for searching\n'
		    'in "Absolute Positions" mode.'
	    ],
#endif
	    foreground: 'baseBlue',
	    page:  2
	]
    ]];

    local wkey = WindowCreate [
	name: 'shell',
	windowName: WIN_QUE_NAME,
	// title: WIN_QUE_TITLE,

	    // The top of the panel is for visualization of annotations
	    // on the template ligand/receptor molecules in MOE from
	    // which the query features and volumes will be created.

	Hbox: [
	    extendH: 1,
	    spacingH: 'small',

	    Hbox: [
		spacingH: 'small',

		Option: [
		    name: 'scheme',
		    extendH: 1,
		    title: 'Scheme:',
		    // text: cat app call sym_find_f 'ph4_scheme_*',
		    text: SCHEME_list,
		    onTrigger:'return',
		    bubbleHelp: bhelp.scheme
		],

		Button: [
		    name: 'scheme_info',
		    text:'Show...',
		    font: 'mediumBold',
		    type: 'modint',
		    modmask: WMOD_SHIFT,
		    extendH: 1,
		    bubbleHelp: bhelp.scheme_info
		],

		    // Rec button has special action on
		    // Click: annotate active site only
		    // Shift-click: annotate all atoms

		Hbox: [
		    spacingH: 'none',
		    uniformCols: 1,
		    Button: [
			name: 'rec',	// default: off
			text: 'R',
			font: 'mediumBold',
			foreground: 'black',
			type: 'modint',
			modmask: WMOD_SHIFT,
			sensitive: 0,
			minWidth: 1,
			extendH: 1,
			bubbleHelp: bhelp.rec
		    ],
		    Button: [
			name: 'sol',	// default: on
			text: 'S',
			font: 'mediumBold',
			foreground: 'black',
			type: 'modint',
			modmask: WMOD_SHIFT,
			sensitive: 0,
			minWidth: 1,
			extendH: 1,
			bubbleHelp: bhelp.sol
		    ],
		    Button: [
			name: 'lig',	// default: on
			text: 'L',
			font: 'mediumBold',
			foreground: 'black',
			type: 'modint',
			modmask: WMOD_SHIFT,
			sensitive: 0,
			minWidth: 1,
			extendH: 1,
			bubbleHelp: bhelp.lig
		    ]
		]
	    ],
#if QUE_BUTTON_ON_TOP
	    Hbox: [cat Button_Q],
#endif
	    Separator: [
		shadow: 'none',
		extendH: 1
	    ],

	    Pager: [
		name: 'sval_useRec_pager',

		Label: [ text: ' ' ],

		Checkbox: [
		    text: 'R-Strength',
		    name: 'sval_useRval',
		    value: SVAL_useRval,
		    onTrigger: 'return',
		    type: 'int',
		    bubbleHelp: bhelp.sval_useRval
		]
	    ]

#if USE_ISMATCH
	    , Separator: [
		shadow: 'none',
		extendH: 1
	    ],
	    Text: [
		name: 'ismatch',
		flushLeft: 1,
#if 0
		title: 'Matches:',
		titleFont: 'medium',
#endif
		len: 3,
		sensitive: 0,
		bubbleHelp:
		    'The number of annotated chains in MOE\n'
		    'that match the current query.'
	    ]
#endif


	],

	Separator: [
	    vertical: 0, extendH: 1, flushLeft: 1
	],

	    // Below the separator line is the section for
	    // specifying the query features.

	Hbox: [
	    extendH: 1,
	    flushLeft: 1,

	    Text: [
		name:'que_title',
		emptyText: '  Title',
		flushLeft: 1,
		extendH: 1,
		len: 20,
		onTrigger: 'return',
		bubbleHelp: bhelp.que_title
	    ],

	    Pager: [
		name:'commentP',
		Button: [
		    name:'comment',
		    extendH:1,
		    text: 'Comment',
		    onTrigger: 'return',
		    bubbleHelp: bhelp.comment
		],
		Button: [	// for alignment only
		    text: 'Consensus...',
		    font: 'mediumBold'
		]
	    ]
	],

	Hbox: [
	    flushLeft: 1,
	    extendH: 1,

	    Hbox: [
		spacingH: 'none',
		Button: [
		    name: 'undo',
		    graphics: ico_left,
		    onTrigger: 'return',
		    bubbleHelp: bhelp.undo
		],
		Button: [
		    name: 'redo',
		    graphics: ico_right,
		    onTrigger: 'return',
		    bubbleHelp: bhelp.redo
		]
	    ],

	    Hbox: [
		    extendH: 1,
		    Button: [
			name:'create_F',
			text:'Feature',
			type: 'modint',
			modmask: WMOD_SHIFT,
			onTrigger: 'return',
			bubbleHelp: bhelp.create_F
		    ],

		    Button: [
			name: 'constrain',
			text: 'Constraint',
			onTrigger: 'return',
			bubbleHelp: bhelp.constrain
		    ],

		    Button: [
			name:'create_volume',
			text:'Volume ',	// ' ' needed for WT on win (fix WT!)
			graphics: down_arrow[], grPosition: 'right',
			onTrigger: 'return',
			bubbleHelp: bhelp.create_volume
		    ]
	    ],

	    Button: [
		name: 'consensus',
		text:'Consensus...',
		font: 'mediumBold',
		onTrigger: 'return',
		bubbleHelp: bhelp.consensus
	    ]

	],

	Hbox: [
	    extendH:1,
	    flushLeft:1,
	    extendV:1,

	    Listbox: [
		name:'mainlist',
		onTrigger:'return',
		keyTrigger: KEY_TRIGGER,
		keyNavigation: 0,
		flushLeft:1,
		extendH:1,
		extendV:1,
		multiSelect:2,
		type:'int',
		len: LIST_DEFLEN,
		width: 10,
		header: select [' ID Prop Expression', '', USE_LISTHEADER]
	    ],

	    Vbox: [
		spacingV: 'medium',

		Vbox: [
		    extendH: 1,
		    Button: [
			name:'button_up',
			graphics: ico_up,
			extendH: 1,
			bubbleHelp: bhelp.button_up
		    ],

		    Button: [
			name:'button_down',
			graphics: ico_down,
			extendH: 1,
			bubbleHelp: bhelp.button_down
		    ],

		    Button: [
			name:'button_delete',
			graphics: ico_delete,
			type: 'modint',
			modmask: WMOD_SHIFT,
			extendH: 1,
			bubbleHelp: bhelp.button_delete
		    ]
		],

		Button: [
		    name:'button_meters',
		    graphics: ico_meter,
		    extendH: 1,
		    onTrigger: 'return',
		    bubbleHelp: bhelp.button_meters
		],

		Vbox: [
		    extendH: 1,
		    Button: [
			name: 'eD_hidefeat',
			graphics: ico_eye(1),
			extendH: 1,
			onTrigger: 'return', type: 'int',
			bubbleHelp: bhelp.eD_hidefeat(1),
			type: 'modint',
			modmask: WMOD_SHIFT
		    ],
		    Button: [
			name: 'button_render',
			graphics: ico_render,
			extendH: 1,
			onTrigger: 'return',
			bubbleHelp: bhelp.button_render
		    ],
#if 1
#ifnot QUE_BUTTON_ON_TOP
		    cat Button_Q,
#endif
#else
		    Button: [
			extendV: 1,
			extendH: 1,
			minWidth: 1,
			text: 'Q',
			name: 'que',		// default: on
			type: 'modint',
			modmask: WMOD_SHIFT,
			font: 'mediumBold',
			onTrigger: 'return',
			bubbleHelp: bhelp.que
		    ],
#endif
		    Button: [ // !!! ?move into the eD subpanel for volumes?
			name:'button_group',
			text:'+V', font: 'mediumBold',
			extendH: 1,
			onTrigger: 'return',
			bubbleHelp: bhelp.button_group
		    ]

		]
	    ]
	],

	Pager: edit_page bhelp,

	Separator: [
	    flushLeft: 1,
	    extendH: 1
	],

	Hbox: [
	    extendH: 1,
	    title: 'Search:',
	    // spacingH: 'medium',

	    Hbox: [
		extendH: 1,
		Checkbox: [
		    name: 'msize_nonzero',
		    onTrigger: 'return',
		    text: 'Partial Match',
		    bubbleHelp: bhelp.msize_nonzero
		],

		Pager: [
		    extendH: 1,
#if PARTIAL_MATCH_P
		    name:'msize_p',
#endif
		    Hbox: [
			extendH: 1,
			Option: [
			    name: 'msize_sign',
			    onTrigger: 'return',
			    extendH: 0,
			    type: 'int',
			    text: ['At Least', 'All But']
			],
			Text: [
			    name:	'msize',
			    type:	'int',
			    // allowBlank: 0,
			    // emptyText: '0',
			    len:	5,
			    value:	0,
			    // min:	0,
			    onTrigger:	'return'
			    // onTrigger:	'validate'
			],
			SEARCH_MESSAGE_1
		    ],
		    SEARCH_MESSAGE_2
		],
		bubbleHelp: bhelp.partial_match
	    ],
#if USE_GEAR
	    Hbox: [
		Button: [
		    name: 'config',
		    flushLeft: 1,
		    graphics: gr_icon ['config.ico', 'small', 'foreground'],
		    extendV: 1
		]
	    ]
#else
	    Data:[]
#endif
	],	// Hbox 'Search:'

	Data: [ name: 'search_tid' ],  // task ID of the PH4 Search panel
	Data: [ name: 'search_wkey' ], // w.key of the PH4 Search panel
	Data: [name: 'eD_ignore', value: 0],	// !!!
	Data: [name: 'eC_type'],
	Data: [name: 'eD_hidden', value: 0],

	Data: [name: 'rsl'],	// [R=0/1/2, S=0/1/2, L=0/1/2]

	text: ACTION,
	bubbleHelp: bhelp.shell

    ];

    tval_init [wkey, [
	eD_sval: 1, eD_rval: 1, eD_mval: 1, eD_R_t: 1,		// flt.pt.
#if USE_ISMATCH
	ismatch: 0,
#endif
	msize: 0, eD_type: 0					// other
    ]];
    update_ph4title wkey;

    return wkey;
endfunction

#if USE_GEAR
// config processes the configuration popup (cog wheel)

local function config [wkeyParent, location]
    task_settitle [-1, '! config popup'];

    local scheme_widgets = [];

    if SCHEME_svalOK then
	scheme_widgets = [
	];
    endif


    local wkey = WindowCreate cat [
	[
	    name: 'shell',
	    mode: 'popup', location: location, mouseoutUnmap: 0,

#if 1
	    Label: [
		centerH: 1,
		text: 'Settings',
		font: 'mediumBold'
	    ],

	    Separator: [
		flushLeft: 1,
		extendH: 1
	    ],
#endif

	    Checkbox: [
		name: 'abspos',
//		title: 'Search Settings:', titleTop: 1,
		text: 'Use Absolute Coordinates',
		value: LIG_abspos,
		onTrigger: 'return',
		bubbleHelp:
		    'Perform matching at the absolute\n'
		    'feature positions.'
	    ],

	    Checkbox: [
		name: 'use_Hs',
		text: 'Use Hydrogen Positions',
		value: LIG_use_Hs,
		onTrigger: 'return',
		bubbleHelp:
		    'Use positions of explicit hydrogens\n'
		    'and lone pairs when computing projected\n'
		    'features.  Used in matching.'
	    ]
	],
	scheme_widgets
    ];

    WindowShow wkey;

    loop
	local [v, trig] = WindowWait wkey;
	local k = tonum trig;
	local wdata = tag [trig, v.(trig)];

	if trig == 'use_Hs' then
	    WindowTrigger [wkeyParent, [trig_use_Hs: v.(trig)]];
	elseif trig == 'abspos' then
	    WindowTrigger [wkeyParent, [trig_abspos: v.(trig)]];
	endif

	WindowSetAttr [wkey, [shell: [mouseoutUnmap: 1]]];
    endloop
endfunction
#endif


// Update field(s) that relate to the query in the given (independent)
// search window

local function update_search_window skey	// (M2)
    static last_state;
    local state = [
	skey, DS_title, SCHEME_svalOK
    ];
    if eqL [last_state, last_state = state] then return; endif
    if allfalse WindowKey skey then return; endif	// safety (not needed)
#if 0
    WindowSetData [skey, [qtitle: DS_title]];
    WindowSetAttr [skey, [
	rscore_ok: [value: SCHEME_svalOK],
	rscore_p1: [page: inc SCHEME_svalOK],
	rscore_p2: [page: inc SCHEME_svalOK]
    ]];
#else
    WindowTrigger [skey, [trig_editor_update: [
	qtitle: DS_title,
	rscore_ok: SCHEME_svalOK
    ]]];
#endif
    //  !!! later, change to:
    // if WIN_SEARCH_key = WindowKey WINSEARCH_key then return; endif
    // info = ...
    // WindowCall [WIN_SEARCH_key, ...info...]
endfunction

// _qdata_Get collects query info from DD_*/DS_* statics and returns it
// in the form a tagvector in the q2008 format. _qdata_Get and qdata_Get
// return the same result. While _qdata_Get always recalculates the value,
// qdata_Get the value cached in QUE_qdata (which is ensured to be up to date).

local function _qdata_Get []
    local k, data = [];

	// Collect scheme etc.

    data.S = [
	scheme:		SCHEME_name,
	matchsize:	DS_matchsize,
	use_Hs:		LIG_use_Hs,
	abspos:		LIG_abspos,	// init.val for ph4 search
	title:		DS_title,
	useRval:	SVAL_useRval,	// init.val when loaded
	comment:	DS_comment
    ];

    if SCHEME_svalOK then
	data.S.svalXxx = SVAL_Xxx;
    endif

    // local smask = SCHEME_mask.(SCHEME_name);
    // !!! if length smask then data.S.smask = smask; endif
    // if anytrue smask then data.S.smask = smask; endif

    local mat   = bitand [first GMaterialTSGB DD_gkey, 0xffffff];
    local trans = bitand [first GTransparency DD_gkey, 0xff];
    local DD_m  = bitor [bitshl [trans, 24], mat];

	// Collect features

    k = igen DF_count;
    data.F = [
	expr:	DD_expr[k],
	color:	DD_color[k],
	m:	DD_m[k],
	x:	DD_x[k],
	y:	DD_y[k],
	z:	DD_z[k],
	r:	DD_r[k],
	ebits:	DD_ebits[k],
	gbits:	DD_gbits[k]
    ];

    if SCHEME_svalOK then
	// if neL [SVAL_Xxx, ['Acc', 'Don']] then E_BUG[]; endif // !!! HACK
	local Xxx;
	data.FS = [];
	ensure_Xxx [];
	for Xxx in SVAL_Xxx loop
	// !!! DD_mval DD_rval
	    data.FS.(tok_cat['sval', Xxx]) = DD_sval.(Xxx)[k];
	    data.FS.(tok_cat['rval', Xxx]) = DD_rval.(Xxx)[k];
	endloop
    endif

	// Collect constraints

    data.C = [
	expr:	DC_expr,
	ebits:	DC_ebits,
	ids:	DC_ids
    ];

#if SHOW_DC_OPTION
    if anytrue DC_gbits then data.C.gbits = DC_gbits; endif
#endif

	// Collect volumes

    k = iadd [DF_count, igen DV_count];

    data.VS = [
	x:	cat DD_x[k],
	y:	cat DD_y[k],
	z:	cat DD_z[k],
	r:	cat DD_r[k]
    ];

    data.V = [
	size:	app length DD_r[k],
	expr:	DD_expr[k],
	color:	DD_color[k],
	m:	DD_m[k],
	ebits:	DD_ebits[k],
	gbits:	DD_gbits[k]
    ];

    return data;
endfunction

// === Undo ============================================================

// vecshare ensures that components of A that are identical in value to
// components from B are also identical in their storage.  This lowers
// the resources needed for future storage and comparison of A and B.

#if 0
global function vecshare [A, B] = A;
#elseif 1
global function vecshare [A, B]
    if eqL [A, B] then return B; endif
    local k = indexof [A, B];
    // PR [vecshare_k: k];
    return mput [A, k, B[pack k]];
endfunction
#else
// !!! not yet
local function _vecshare [A, B]
    if isflat A then return A; endif
    if isflat B then return A; endif

    local mA = not app isflat A, mB = not app isflat B;
    if anytrue mA then
	local segA = app length (A|mA), segB = app length (B|mA);
	A | mA = app cat (A | mA);
	A = _vecshare [A, put [B, mB, app cat (B | mB)]];
	A | mA = apt split [A | mA, segA];
    endif

    local k = indexof [A, B];
    // PR [vecshare_k: k];
    return mput [A, k, B[pack k]];
endfunction

global function vecshare [A, B]
    if eqL [A, B] then return B; endif
    return _vecshare [A, B];
endfunction
#endif

// qdata_Sync ensures that QUE_qdata stores the current contents of DD_*,
// SCHEME_* etc statics.

local function qdata_Sync []
    if isnull QUE_qdata then QUE_qdataOK = 0; endif
    if not QUE_qdataOK then
	QUE_qdata = _qdata_Get[];
	QUE_qdataOK = 1;
	QUE_changed = 0;			// !!!
	if WIN_SEARCH_key then update_search_window WIN_SEARCH_key; endif
    endif
endfunction

// qdata_Get returns the current contents of the query (in q2008 tagvector).

local function qdata_Get []
    qdata_Sync [];
    return QUE_qdata;
endfunction

local function load_qdata, update_ph4title;
local function setall_from_DDnDC;
local function setattr_ligrec;
local function check_query;

// undo_dbg sets/unsets/returns the value of UNDO_dbg.
// When UNDO_dbg is set, we print debugging info on every undo/redo/usnap.
//
// If x=1/0, we set/unset UNDO_dbg and return its previous value.  Otherwise,
// we return the current value of UNDO_dbg.
//
// The function can be called from CLI with:
//   WindowCall[wkey, 'UndoCtrl', ['Dbg', x]]
// For example:
//   WindowCall[ph4_EditorKey '*editor*', 'UndoCtrl', ['Dbg', 1]]

local function undo_dbg x
    if m_diff [[x], [0,1]] then return UNDO_dbg; endif
    return first [UNDO_dbg, UNDO_dbg = x];
endfunction

// undo_hint controls visual hints given to the user when undo/redo changes
// values of properties that are not otherwise visible on the screen, such as
// the "comment" field.  If the current value of such a property is diffent
// from the its value in the state on top of the undo stack, we change the
// appearance of the related widget, e.g. by switching foreground to red.
// (The widgets will switch back to their default look with the nearest
// non-undo/redo change of state.)
//
// The "cmd" controls the action:
//	on:  start showing the hint
//	off: stop showing the hint
//	up:  update value of the hint

local function undo_hint cmd
    static TOP;
    static hstate;
    if isnull hstate then hstate = 0; endif

    if cmd == 'on' then
	if hstate then return; endif
	hstate = 1;
	TOP.comment = DS_comment;

    elseif cmd == 'off' then
	if not hstate then return; endif
	hstate = 0;
	TOP = [];

    elseif cmd == 'up' then
	local cmark = hstate and neL [TOP.comment, DS_comment];
	local ccolor = select [DARK_RED, 'none', cmark];
	local cbhelp = DS_comment_bhelp(inc cmark);
	WindowSetAttr [WIN_key, [
	    comment: [foreground: ccolor, bubbleHelp: cbhelp]
	]];

    else
	E_BUG[];
    endif
endfunction


// The undo stack stores states 1..UNDO_N, where (1..UNDO_I) are the undo
// states and (UNDO_I+1..UNDO_N) are the redo states.  The max.# undos is
// UNDO_NMAX.  When the limit is reached, the oldest undo states are (silently)
// removed.

// Each state is composed of essential components, stored in qdata, and
// non-essential components, stored in oth.  The non-essential components
// (e.g. listbox selection state) are restored with the undo/redo actions,
// but they are ignored when we decide whether or not the state has changed
// and a new snapshot needs to be stored.

// If UNDO_USE_OFS=1, the undo states are stored in a circular buffer, starting
// at position UNDO_OFS+1.  When UNDO_NMAX is reached, the offset moves.
// If UNDO_USE_OFS=0, the undo states are stored starting from the first
// position.  When UNDO_NMAX is reached, we rotl the buffer (expensive!).

// The undo states are 1..UNDO_I.  The redo states are UNDO_I+1..UNDO_N.

local function undo_len []	= UNDO_N;	// #undos + #redos + 1
local function undo_pos []	= UNDO_I;	// #undos + 1

local function undo_OK []	= UNDO_I > 1;		// #undos > 0
local function redo_OK []	= UNDO_I < UNDO_N;	// #redos > 0
local function redo_none []	= null (UNDO_N=UNDO_I);	// set #redos = 0

#ifnbif mod1p
local function mod1p [x, N] = inc mod [dec x, N];	// return [1..N]
#endif

// undo_sidx returns the position in the undo state buffer UNDO_S that is
// used to store the i-th state of the undo stack.

#if UNDO_USE_OFS
local function undo_sidx i	= mod1p [UNDO_OFS + i, UNDO_NMAX];
#else
local function undo_sidx i	= i;
#endif

// undo_cur[] returns the buffer index of curent system state.
// UNDO_S(undo_cur[]) is the state is used to determine whether or not
// there have been any changes to the system.

local function undo_cur []	= undo_sidx UNDO_I;

// undo_dec[] decrements the index of the current system state.
// When "Undo" is executed, the system chg to state UNDO_S(undo_dec[]).

local function undo_dec []	= undo_sidx (UNDO_I = max [1, dec UNDO_I]);

// undo_inc[] increments the index of the current system state.
// When "Redo" is executed, the system chg to state UNDO_S(undo_inc[]).

local function undo_inc []
    if UNDO_I < UNDO_N then		// there are redos available
	UNDO_I = inc UNDO_I;
    elseif UNDO_N < UNDO_NMAX then	// no redos: append new undo
	UNDO_I = UNDO_N = inc UNDO_N;	// there is more room in the buffer
    else				// no room left: repl oldest undo
#if UNDO_USE_OFS
	UNDO_OFS = mod [inc UNDO_OFS, UNDO_NMAX];
#else
	UNDO_S = rotl UNDO_S;
#endif
	if UNDO_dbg then write 'NMAX reached\n'; endif
    endif

    return undo_sidx UNDO_I;
endfunction

// undo_pr_diff is a debugging utility that prints the differences between
// undo states s1 and s2.

local function undo_pr_diff [s1, s2]
    local [d1, oth1] = s1;
    local [d2, oth2] = s2;
    local X;

	// Print changes in the essential components of the query state
	// (positions, colors etc).

    for X in tags diff [d2,d1] loop
	local dX1 = d1.(X), dX2 = d2.(X);

	    // Print changes in #features and #volumes.

	if m_join [X, ['C','F','FS','V','VS']] then
	    local nX1 = l_length tagvals dX1, nX2 = l_length tagvals dX2;
	    if neL [nX1, nX2] then
		write ['\tn{} = {} --> {}\n', X, nX1, nX2];
		continue;
	    elseif not nX2 then
		write ['\tn{} = 0\n', X, nX1, nX2];
		continue;
	    endif
	endif

	    // Print changes in individual properties of d.(X).

	local y, Y1 = tags dX1, Y2 = tags dX2;
	for y in diff [Y2, Y1] loop
	    write ['\t    {}.{}: {v}\n', X, y, dX2.(y)];
	endloop
	for y in diff [Y1, Y2] loop
	    write ['\tdel {}.{}: {v}\n', X, y, dX1.(y)];
	endloop
	for y in join [Y1, Y2] loop
	    if eqL [dX1.(y), dX2.(y)] then continue; endif
	    write ['\tchg {}.{}: {v}\n', X, y, dX2.(y)];
	endloop
    endloop

	// Print changes in the non-essential components of the query
	// state (list selection etc).

    local z, Z1 = tags oth1, Z2 = tags oth2;
    for z in join [Z1, Z2] loop
	if eqL [oth1.(z), oth1.(z)] then continue; endif
	write ['\tchg oth.{}: {v} --> {v}\n', z, oth1.(z), oth2.(z)];
    endloop

endfunction

// undo_pr_stack is a debugging utility that prints the contents of the buffer
// of undo states.

local function undo_pr_stack msg
    if isnull msg then msg = 'UNDO STACK:'; endif
    local N = undo_len[], I = undo_pos[], OFS = '';
#if UNDO_USE_OFS
    OFS = twrite [', OFS={}', UNDO_OFS];
#endif
    write ['\n{} {}/{}{}\n', msg, I, N, UNDO_OFS];

    if N == 0 then write '  <EMTPY>\n'; return; endif

    local i, s1, s2 = UNDO_S(undo_sidx(1));
    if I == 1  or anytrue s2(3) then
	write ['{}_1: {}\n', select ['  >>', '__', eqL[i,I]], s2(3)];
    endif

    for i = 2, N loop
	[s1, s2] = [s2, UNDO_S(undo_sidx(i))];
	write ['{}_{}: {}\n', select ['  >>', '__', eqL[i,I]], i, s2(3)];
	undo_pr_diff [s1, s2];
    endloop
endfunction

static UNDO_qdata_last, UNDO_oth_last, UNDO_ename_last;

// undo_setstate resets the state of the query and the panel using
// the state info s.

local function undo_setstate s
    if UNDO_dbg then write 'UndoSetState\n'; endif

    local [qdata, oth] = s;

    load_qdata [WIN_key, qdata];
    if anytrue oth.fn then
	QUE_fname = oth.fn;
	QUE_fplus = 0;
	update_ph4title WIN_key;
    endif
    DD_sel	= oth.DD_sel;
    DC_sel	= oth.DC_sel;
    DD_usel	= oth.DD_usel;
    // !!! set smask
    setall_from_DDnDC WIN_key;
    QUE_changed = 0;
    // !!! set oth
    [UNDO_qdata_last, UNDO_oth_last] = s;
endfunction

// usnap examines changes to the query and stores them in the UNDO_S stack.
// The function should be called after every event that changes essential
// components of the query and given the event name as the argument.
//
// 1) If the last state was stored in response to the same event, we
//    "telescope" the event and don't extract or store the new state.
// 2) Otherwise, if extract the new state and compare its essential components
//    to those of to the last state stored.  If there are no essential changes
//    we do nothing.
// 3) Otherwise, we add the current state to the stack.

local function usnap ename

	// If the event type, ename, is not empty, telescope the event:
	// Don't store subsequent events of the same type (e.g. when
	// dragging the radius "R:" wheel.)  If the event type is empty,
	// we always store the state (unless it is already stored).

    if isnull UNDO_ename_last then	// no telescoping for empty ename
    elseif redo_OK[] then		// no telescoping on an undone state
    elseif anytrue UNDO_ename_last and eqL [ename, UNDO_ename_last] then
	if UNDO_dbg then write ['(Telescoping {})\n', ename]; endif
	return;
    endif

	// Extract the current state.  Store its essential components
	// in qdata and its non-essential components in oth.

    local qdata = qdata_Get[];
    local oth = [
	DD_sel: DD_sel,
	DC_sel: DC_sel,
	DD_usel: DD_usel,
	smask: scheme_mask SCHEME_name,
	fn: QUE_fname
    ];

	// Determine how much has changed.
	// 1) Major change: If there is a change in the essential components,
	//    append a new state to the stack.
	// 2) Minor change: If there is a change only the non-essential
	//    components, only update the last state on the stack.  (The old
	//    values of non-essential components are simply lost.)
	// 3) Exception to 2) above: If a minor change happens in the middle
	//    of undo, treat it as a major change (and kill the redo).
	// 4) If there is no change, do nothing.

    local msg;
    local update_state = neL [oth, UNDO_oth_last];
    local append_state = neL [qdata, UNDO_qdata_last];

    if update_state then if redo_OK[] then
	append_state = 1;
    endif endif

    if append_state then
	UNDO_qdata_last = vecshare [qdata, UNDO_qdata_last];
	undo_inc[];
	msg = 'Add new snapshot';
    elseif update_state then
	msg = 'Update last snapshot';
    else
	if UNDO_dbg then write '(No change)\n'; endif
	return;
    endif

	// If there is change, store both the essential and non-essential
	// components on the stack.  (The event type, ename is stored, but
	// for debugging purposes only.)

    UNDO_oth_last = vecshare [oth, UNDO_oth_last];
    UNDO_ename_last = ename;
    UNDO_S(undo_cur[]) = [UNDO_qdata_last, UNDO_oth_last, UNDO_ename_last];

    if UNDO_dbg then
	msg = twrite ['({} {})', msg, undo_cur[]];
	undo_pr_stack [msg, undo_cur[]];
    endif

	// If the state changed, prevent any redos and stop any hints.

    redo_none[];
    undo_hint 'off';
    undo_hint 'up';

	// Adjust the sensitivity of "Undo" and "Redo".

    // print_undo_sens[];
    WindowSetAttr [WIN_key, [
	undo: [sensitive: undo_OK[]],
	redo: [sensitive: redo_OK[]]
    ]];
endfunction

// undo sets the query to its previous state or, if "redo" was used and
// there were no changes since then, to the state before the last "redo".

local function undo []
    if UNDO_dbg then write '\n===  Undo START:\n'; endif
    usnap[];
    if undo_OK[] then
	if not redo_OK[] then undo_hint 'on'; endif
	undo_setstate UNDO_S(undo_dec[]);
    elseif UNDO_dbg then
	undo_pr_stack 'No Undo';
    endif
    WindowSetAttr [WIN_key, [
	undo: [sensitive: undo_OK[]],
	redo: [sensitive: redo_OK[]]
    ]];
    undo_hint 'up';
    if UNDO_dbg then write '\n===  Undo DONE:\n'; endif
endfunction

// undo reset the query to the state before the last "undo".

local function redo []
    if UNDO_dbg then write '\n===  Redo START:\n'; endif
    if redo_OK[] then
	undo_setstate UNDO_S(undo_inc[]);
	if not redo_OK[] then undo_hint 'off'; endif
    elseif UNDO_dbg then
	undo_pr_stack 'No Redo';
    endif
    WindowSetAttr [WIN_key, [
	undo: [sensitive: undo_OK[]],
	redo: [sensitive: redo_OK[]]
    ]];
    undo_hint 'up';
    if UNDO_dbg then write '\n===  Redo DONE:\n'; endif
endfunction

// UndoCtrl is a WindowCall method of external control of the UNDO stack.

local function UndoCtrl [wkey, [cmd, arg]]
    const CMD = ['Snapshot', 'Undo', 'Redo', 'Print', 'Dbg'];
    local FCN = [#usnap, #undo, #redo, #undo_pr_stack, #undo_dbg];
    local k;
    if k = indexof [[cmd], CMD] then return call [FCN(k), arg]; endif
endfunction

local function mem_read RC
    local str = string GetRC [RC, ''];
    return tag sreadb_tbl [str, ['t', 'ix']];
endfunction

local function mem_write [RC, mem]
    local str = swriteb_tblLF[['t','ix'], untag mem];
    str | str == last str = " ";	// replace LF by SPC
    SetRC [RC, token str];
endfunction

#if SHOW_QUERY_BITS
local function DD_needed_bits []
    static state, bits;
    if eqL [state, state = [SCHEME_name, DD_expr]] then return bits; endif
    return bits = bitor ph4_ExprNeededBits [DD_expr, SCHEME_name];
endfunction
#endif

// === Undo ============================================================

// Create a panel with pharmacophore type information
// Generate one line per type for all types of the ph4 scheme

local function scheme_info_window [pkey, ptrig]
    local wtitle = token swrite ['{} Info', SCHEME_name];
    local wname = tok_cat ['[', WIN_QUE_NAME, '] ', wtitle];

    if WindowShow [wname, 1] then return; endif
    local prio = task_prio 0;

    function FF [name, color, info] = [
	Separator: [shadow:'none'],
	Checkbox: [
	    name: tok_cat ['smask_', name],
	    minWidth:1,
	    onTrigger: 'return'
	],
	Label: [ minWidth:1, background:color ],
	Label: [ title:tok_cat [' ',name,': '], text:info, font:'medium' ],
	Separator: [shadow:'none']
    ];


    const BHELP_SHOW =
	'Change the selection of shown annotation types.\n'
	'Default: Show only the default annotation types.\n'
	'All: Show all annotation types.\n'
#if SHOW_QUERY_BITS
	'None: Show no annotation types.\n'
	'Query: Show annotation types used by the query.';
#else
	'None: Show no annotation types.';
#endif

    const BHELP_MEM =
	'Memory register that stores a named selection.\n'
	'Load: The current selection is replaced.\n'
	'Store: The current selection is saved.\n'
	'Erase: The memory register is eliminated.';

    const ALLREC_HELP =
	'If on, annotate all atoms of the receptor\n'
	'surface.  Otherwise, annotate only in the\n'
	'receptor surface cavities.';

    local bhelp = ph4_edit_bhelp [];


    local SCHEME_info = ph4_SchemeFdesc SCHEME_name;
    local SCHEME_color = ph4_SchemeBitsColor [SCHEME_name, SCHEME_tcode];

    local sval_sliders = [];
    local sval_isolate_acc = [];
    local sval_isolate_don = [];
    local ico_reset = gr_icon ['refresh.ico', 'small', 'foreground'];

    local function svalSliders []
	local hbox = [], i;
	for i = 1, length SVAL_Xxx loop
	    local Xxx = SVAL_Xxx(i);
	    hbox(i) = cat [ Hbox: [
		extendH:1,
		flushLeft: 1,
		Label: [ minWidth:1 ],
		Hbox: [
		    extendH:1,
		    flushLeft: 1,
		    spacingH: 'none',

		    Pager: [
			Label: [ text: tok_cat [Xxx, ' > '] ],
			Label: [ text: 'Acc > ' ],	// reserve width
			Label: [ text: 'Don > ' ]	// reserve width
		    ],
		    // !!! XXX
		    Scale: [
			name: tok_cat ['svalMin.Val.', Xxx],
			extendH: 1, len: 5, width: 5,
			range: [1, 300, 0.01],
			value: LIG_svalMin.(Xxx),
			onTrigger: 'return'
		    ],
		    Button: [
			name: tok_cat ['svalMin.Def.', Xxx],
			graphics: ico_reset,
			sensitive: neL [LIG_svalMin.(Xxx), SVAL_default.(Xxx)],
			bubbleHelp:
			    'Reset the minimum strength to its default value',
			onTrigger: 'return'
		    ],
		    bubbleHelp: twrite [
			'Minimum strength of displayed {|/} annotation points',
			SVAL_XxxYyy.(Xxx)
		    ]
		],
		Label: [ minWidth:1 ]
	    ]];
	endloop

	return hbox;
    endfunction

	// !!! The following should come from the scheme!

    if SCHEME_svalOK then
	sval_sliders = svalSliders [];
    endif

    local P = [
	name: 'ph4_annotations_shell',
	mode: 'popup', location: [pkey, ptrig, 71], mouseoutUnmap: 0,

	title: wtitle,
//	windowName: wname,

	Vbox: [
	    extendH:1,
	    extendV:1,
	    shadow:'rounded-in',
	    spacingV: 'none',

	    bubbleHelp: 'Show only the selected annotation types.',

	    Mbox: [
		columns: 1,
		extendH: 1,
		flushLeft: 1,

		Hbox: [
		    title: 'Show:',
		    uniformCols: 1,
		    extendH: 1,
		    spacingH: 'none',

		    Button: [
			name: 'show_default',
			minWidth: 4,
			extendH: 1,
			text: 'Default'
		    ],

		    Button: [
			name: 'show_all',
			extendH: 1,
			text: 'All'
		    ],

		    Button: [
			name: 'show_none',
			extendH: 1,
			text: 'None'
		    ],

#if SHOW_QUERY_BITS
		    Button: [
			name: 'show_query',
			extendH: 1,
			text: 'Query'
		    ],
#endif
		    bubbleHelp: BHELP_SHOW
		],

		Hbox: [
		    title: 'Memory:',
		    name: 'mem_box',
		    shadow:'none',
		    extendH: 1,

		    Text: [
			name: 'mem_t',
			extendH: 1,
			onTrigger: 'return'
		    ],

		    Hbox: [
			uniformCols: 1,
			spacingH: 'none',

			Button: [
			    name: 'mem_load',
			    text: 'Load'
			],

			Button: [
			    name: 'mem_store',
			    text: 'Store'
			],

			Button: [
			    name: 'mem_erase',
			    text: 'Erase'
			]
		    ],

		    bubbleHelp: BHELP_MEM
		]
	    ],

	    Vbox: cat [
		[flushLeft: 1, extendH:1],
		[Separator: [ flushLeft: 1, extendH: 1 ]],
		sval_sliders
	    ],

	    Mbox: cat [
		[ title: ' ', columns:5, center:0 ],
		// sval_isolate_acc,
		// sval_isolate_don,
		cat apt FF [SCHEME_type, SCHEME_color, SCHEME_info],
		[
		    Separator: [shadow:'none'],
		    Label: [ minWidth:1 ],
		    Label: [ minWidth:1, background: DV_DEFCOLOR ],
		    Label: [
			title: ' V: ',
			text: 'Volume constraint',
			font:'medium'
		    ],
		    Separator: [shadow:'none']
		],
		[
		    Separator: [shadow:'none'],
		    Checkbox: [
			name: 'show_pvectors',
			value: LIG_pvectors,
			onTrigger: 'return',
			type: 'int',
			bubbleHelp: 'Display projecting vectors as lines.'
		// 'If ON, lines will be drawn between the annotation points\n'
		// 'on projecting atoms and the projected annotation points,\n'
		// 'e.g. between a Don atom and the projected Don2.',
		    ],
		    Label: [ minWidth:1 ],
		    Label: [
			flushLeft: 1,
			text: 'Projecting Vectors',
			font:'medium',
			bubbleHelp: 'Display projecting vectors as lines.'
		    ],
		    Separator: [shadow:'none']
		],
		[
		    Separator: [shadow:'none'],
		    Checkbox: [
			name: 'allrec',
			onTrigger: 'return',
			type: 'int',
			value: LIG_allrec,
			bubbleHelp: ALLREC_HELP
		    ],
		    Label: [ minWidth:1 ],
		    Label: [
			flushLeft: 1,
			text: 'Entire Receptor Surface',
			font:'medium',
			bubbleHelp: ALLREC_HELP
		    ],
		    Separator: [shadow:'none']
		]
	    ],

	    Separator: [shadow:'none', extendV:1]
	],

	text: 'Close',
	onTrigger: 'exit'
    ];


    local SCHEME_notes = ph4_SchemeNote SCHEME_name;

    if length SCHEME_notes then
	P = cat [P, [Hbox: [
	    extendH:1,
	    extendV:1,
	    center:1,
	    title: '',

	    Separator: [ shadow: 'none', extendV:1 ],
	    Vbox: [
		extendV: 1,
		spacing:'none',

		Separator: [ shadow: 'none', extendV:1 ],
		Label: [ text: 'Notes    ', font:'mediumBold', center: 1 ],
		Label: [
		    center: 1,
		    text: token SCHEME_notes
		],
		Separator: [ shadow: 'none', extendV:1 ]
	    ],
	    Separator: [ shadow: 'none', extendV:1 ]
	]]];
    endif

    local swkey = WindowCreate P;
    local scheme = SCHEME_name, tcode = SCHEME_tcode, stype = SCHEME_type;

    local sshow = notnot bitand [tcode, scheme_mask scheme];
    local sshow_def = notnot bitand [tcode, ph4_SchemeDefmask scheme];
    WindowSetData [swkey, tag [tok_cat ['smask_', stype], sshow]];

    local RC = tok_cat [RC_MEMPFX, scheme];
    // local mem = tag sreadb_tbl [string GetRC [RC, ''], ['t', 'ix']];
    local mem = mem_read RC;
    const MEM_NONE = '<none>';
    WindowSetData [swkey, [mem_t: MEM_NONE]];
    WindowSetAttr [swkey, [mem_t: [shortcut: tags mem]]];

    WindowShow swkey;
    local mname = '', battr_last = [];
    local nbits = [];
    local A;

    loop
	// local [v, t] = window_wait [swkey, [], 0.1];
	local [v, t] = window_wait [swkey, [timeout: 0.1]];

	    // On timeout, update sensitivity of the memory buttons only

	if isnull t then
	    v = WindowGetData [swkey, 'mem_t'];
#if SHOW_QUERY_BITS
	    if neL [nbits, nbits = DD_needed_bits[]] then
	    elseif eqL [mname, mname = v.mem_t] then continue;
	    endif
#else
	    if eqL [mname, mname = v.mem_t] then continue; endif
#endif
	    // Note: 'smask_*' widgets are checkboxes created by FF that
	    // control visibility of individual ann.types

	elseif m_findmatch ['smask_*', t] then
	    local name = tok_drop [t, tok_length 'smask_'];
	    local k = indexof [name, stype];
	    if not k then continue; endif
	    sshow(k) = v.(t);

	elseif t == 'show_pvectors' then
	    LIG_pvectors = v.show_pvectors;
	    draw_lig_pvectors[];

	elseif m_findmatch ['show_*', t] then
	    if t == 'show_default' then
		SCHEME_mask.(scheme) = [];
	    elseif t == 'show_all' then
		SCHEME_mask.(scheme) = -1;
	    elseif t == 'show_none' then
		SCHEME_mask.(scheme) = 0;
#if SHOW_QUERY_BITS
	    elseif t == 'show_query' then
		SCHEME_mask.(scheme) = DD_needed_bits[];
#endif
	    endif

		// Show all (equivalent to strength >= 0).

// !!! SCHEME_mask.(scheme) = bitor select [0, tcode, sshow];
	    sshow = notnot bitand [tcode, scheme_mask scheme];
	    WindowSetData [swkey, tag [tok_cat ['smask_', stype], sshow]];

	elseif m_findmatch ['svalMin*', t] then	// svalMin.Def.Acc
	    local Xxx = fext t;			// Acc
	    local wVal = tok_cat ['svalMin.Val.', Xxx];
	    local wDef = tok_cat ['svalMin.Def.', Xxx];
	    local svalCur = v.(wVal), svalDef = SVAL_default.(Xxx);

	    A = [];
	    if m_findmatch ['*.Def.*', t] then
		A.(wVal).value = svalCur = svalDef;
	    endif
	    A.(wDef).sensitive = neL [svalCur, svalDef];
	    WindowSetAttr [swkey, A];
	    WindowTrigger [pkey, [trig_sinfo: ['svalMin', Xxx, svalCur]]];

	elseif t == 'allrec' then
	    WindowTrigger [pkey, [trig_allrec: v.(t)]];

	elseif m_findmatch ['mem_*', t] then
	    if isspace v.mem_t or v.mem_t == MEM_NONE then
		if v.(t) === 'Store' then
		    Warning 'Missing name of the memory register.\n'
			'Type in the name of the current selection.';
		else
		    Warning 'Missing name of the memory register.\n'
			'Type in the name of an existing register.';
		endif
	    // !!! update_lig_annotation 2;
		continue;

	    elseif not isalnum v.mem_t then
		Warning 'Illegal name of the memory register.\n'
		    'Use letters and digits only.';
		continue;

	    elseif t == 'mem_store' then
		if isnull mem.(v.mem_t) then	// new register
		elseif eqL [mem.(v.mem_t), SCHEME_mask.(scheme)] then // same
		elseif not YesNo twrite ['Rewrite register "{}"?', v.mem_t] then
		    continue;
		endif
		mem.(v.mem_t) = SCHEME_mask.(scheme);
		mem_write [RC, mem];
		WindowSetAttr [swkey, [mem_t: [shortcut: tags mem]]];
		// continue;

	    elseif isnull mem.(v.mem_t) then
		Warning twrite ['Memory register "{}" does not exist.',v.mem_t];
		continue;

	    elseif t == 'mem_t' or t == 'mem_load' then
		SCHEME_mask.(scheme) = mem.(v.mem_t);

	    elseif t == 'mem_erase' then
		if not YesNo twrite ['Delete register "{}"?', v.mem_t] then
		    continue;
		endif
		mem.(v.mem_t) = [];
		mem = taguniq mem;
		mem_write [RC, mem];
		WindowSetAttr [swkey, [mem_t: [shortcut: tags mem]]];
		WindowSetData [swkey, [mem_t: MEM_NONE]];
		// continue;
	    endif

	    sshow = notnot bitand [tcode, scheme_mask scheme];
	    WindowSetData [swkey, tag [tok_cat ['smask_', stype], sshow]];
	endif

	if length t then
	    local smask = bitor select [tcode, 0, sshow];
	    // SCHEME_mask.(scheme) = bitor select [tcode, 0, sshow];
	    SCHEME_mask.(scheme) = smask;
	    update_lig_annotation 2;
	    if anytrue WindowKey CONS_wkey then
		WindowTrigger [CONS_wkey, [SCHEME_update: [scheme, smask]]];
	    endif
	    WindowSetAttr [swkey, [ph4_annotations_shell: [mouseoutUnmap: 1]]];
	endif

	    // Update the sensitivity and color of action buttons

	local msens, mcolor = rep ['none', 3];
	local mbhelp = BHELP_MEM;

	if isspace v.mem_t or v.mem_t == MEM_NONE then	// empty name
	    msens = [0, 0, 0];
	    mbhelp = tok_cat [BHELP_MEM,
		'\n\nWARNING: The name of the memory register is\n'
		'missing.  Type in the name of an existing register.'
	    ];
	elseif not isalnum v.mem_t then			// bad name
	    msens = [0, 0, 0];
	    mbhelp = tok_cat [BHELP_MEM,
		'\n\nWARNING: The name of the memory register is\n'
		'not valid.  Use letters and digits only.'
	    ];
	elseif isnull mem.(v.mem_t) then		// not found
	    msens = [0, 1, 0];
	elseif eqL [mem.(v.mem_t), SCHEME_mask.(scheme)] then // no change
	    msens = [1, 1, 1];
	    mcolor = ['baseBlue', 'baseBlue', 'none'];
	else						// new contents
	    msens = [1, 1, 1];
	endif

	local scolor = select ['baseBlue', 'none', [
	    sshow_def === sshow, alltrue sshow, allfalse sshow
#if SHOW_QUERY_BITS
	,   sshow === notnot bitand [tcode, DD_needed_bits[]]
#endif
	]];

	if neL [battr_last, battr_last = [msens, mcolor, scolor, mbhelp]] then
	    WindowSetAttr [swkey, [
		mem_load: [sensitive: msens(1), foreground: mcolor(1)],
		mem_store: [sensitive: msens(2), foreground: mcolor(2)],
		mem_erase: [sensitive: msens(3), foreground: mcolor(3)],
		mem_box: [bubbleHelp: mbhelp],
		show_default: [foreground: scolor(1)],
#if SHOW_QUERY_BITS
		show_query: [foreground: scolor(4)],
#endif
		show_all: [foreground: scolor(2)],
		show_none: [foreground: scolor(3)]
	    ]];
	endif

    endloop
    WindowDestroy swkey;
    task_prio prio;
endfunction

// Draw contours around a set of spheres, given screen coordinates [x,y,z]
// and a mask of spheres do draw.  If do_sel is nonzero, current selection
// is used as the mask.

// local function draw_contour [x, y, z, do_sel];
local function draw_contour do_sel;
#if NEW_AFF
    local A = ViewAffData[];
#else
    local [y,z] = GOBJ_QUE_ViewOrientation;
    local x = rot3d_vCross GOBJ_QUE_ViewOrientation;
#endif

    local m_contour = bitand [0x87, DD_gbits] == 2;	// 0x07=2 && 0x80=0

    // local use_stereo = neL [Stereo[], 'parallel'];

	// Get the selection color

    static selcolor;
    if isnull selcolor then
	selcolor = (ViewSetup[]).atom_selected_color;
    endif

	// Calculate unit circle in the plane of the screen
	// The number of point in the circle (circle density) is
	// adjusted according to the radius of the resulting sphere.
	// The circle densities are bucketed and memoized for faster
	// retrieval in case where the contours of many similar spheres
	// must be drawn.  Note: Contours are redrawn with every
	// change of the ViewOrientation, so they must be much faster
	// to draw than 3D spheres.

    static C_pos = [], C_angle = [];	// reset for each call of draw_contour
    local function get_cpos rad
	// local k = minE [maxE [1, round (log inc abs rad * 2)], 20];
	// local n = k * 10;
	local k = round (inc abs rad * 20) * 2;	// ensure even number of pts
	local n = k;

	if isnull C_pos(k) then
	    local angle = 2*PI/n * igen n;
	    local [cx, cy] = [cos angle, sin angle];
#if NEW_AFF
	    C_pos(k) = AffV2W [A, [cx, cy, 0.1]];
#else
	    C_pos(k) = [cx] * x + [cy] * y + 0.1 * z;
#endif
	    C_angle(k) = angle(1);
	endif

	return [C_pos(k), C_angle(k)];
    endfunction

    local ofs = select [0.1, 0.01, do_sel];
    local i, j;

	// Draw a contour around selected features and volumes

    local color = selcolor;
    for i = 1, length DD_expr loop
	if not do_sel then			// Use mask: check mask
	    if not m_contour(i) then continue; endif
	    color = DD_color(i);		// Use sphere color (not sel.)
	elseif not DD_umask(i) then		// Check single-sphere selection
	    if not DD_sel(i) then continue; endif
	else					// Check multiple-sph.sel.
	    if not DD_usel(i) and allfalse DD_sel(i) then continue; endif
	endif

	local cpos, spos, spos_xy, cidx;

	    // Draw a circle around a single sphere

	if not DD_umask(i) then
	    if do_sel then if not DD_sel(i) then continue; endif endif
	    [cpos] = get_cpos DD_r(i);
	    cidx = igen l_length cpos;
	    spos = cpos * (DD_r(i) + ofs) + [DD_x(i), DD_y(i), DD_z(i)];
	    GVertex [GOBJ_QUE_key2, 2, cidx, color, spos];
	    continue;
	endif

	    // Skip unions that are not in any way selected

	if do_sel then if allfalse [DD_usel(i), DD_sel(i)] then
	    continue;
	endif endif

	local m_sel = m_id DD_r(i);
	if do_sel then m_sel | not DD_usel(i) and not DD_sel(i) = 0; endif

	    // Project the centers of the spheres of the union
	    // into the plan of the screen

	local px = DD_x(i) | m_sel;
	local py = DD_y(i) | m_sel;
	local pz = DD_z(i) | m_sel;
	local rad = DD_r(i) | m_sel;
#if 1
#if NEW_AFF
	local ppos = AffW2V [A, [px, py, pz]];
#else
	local ppos = matmul [[x,y,z], [px, py, pz]];
#endif
#if CONTOUR_MAXZ
	ppos(3) = max ppos(3);
#endif
#if NEW_AFF
	[px, py, pz] = AffV2W [A, ppos];
#else
	[px, py, pz] = matmul [tr [x,y,z], ppos];
#endif
	local posx = ppos(1), posy = ppos(2);
#else
	local posx = add (pos * x);
	local posy = add (pos * y);
#endif

	    // Initiate a proxy object to clip vertices that fall
	    // within the intersection of the drawn circles

	local m, n, k, im, ss, seg, j1, j2, r2, idx;
	const EPS_2D = 0.01;
	local smallr = maxE [0, rad + ofs - EPS_2D];
	local pkey = prox_open [max [0.5, max smallr], [posx,posy], smallr];

	[seg, j2, r2] = prox_find [pkey, [posx,posy], 0];
	j1 = stretch [x_id smallr, seg];
	r2 = sqrt r2;

	    // Remove subcircles and near duplicates

	m = leE [0, smallr[j2]-smallr[j1], 0.2];	// nearly same radius
	m = m and j1 < j2 and leE [0, r2, 0.2] or	// near duplicate
	    not m and smallr[j1] + r2 < smallr[j2];	// j1 inside j2

	if anytrue m then
	    m = put [m_id rad, pack j1 | m, 0];
	    [px, py, pz, rad] = [px, py, pz, rad] || [m];
	    [posx, posy, smallr] = [posx, posy, smallr] || [m];
	    prox_close pkey;
	    pkey = prox_open [max [0.5, max smallr], [posx,posy], smallr];
	endif

	    // Draw a partial circle around selected spheres of a union
	    // and a full contour around unions with selected headers

	const STORE_D = 0;	// store intervals for further processing
#if STORE_D
	local jpos = [], jidx = [], jxy1 = [], jcdist = [], jxy2 = [];
	local jk=0;
#endif
	local angle, cdist = 0;

	    // For each sphere of the union, generate points of its contour
	    // and remove those points that intersects other spheres of the
	    // union.

	// for j in x_pack m_sel loop
	for j = 1, length rad loop
	    [cpos, angle] = get_cpos rad(j);
	    cdist = angle * rad(j);

		// Extend contour points, cpos, at radius rad(j) around the
		// j-th sphere, center.  Project the resulting contour poins,
		// spos, to the screen plane.

#if NEW_AFF
	    spos = cpos*(rad(j)+ofs)+[px(j),py(j),pz(j)];
	    spos_xy = droplast AffW2V [A, spos];
#else
	    spos = cpos*(rad(j)+ofs)+[px(j),py(j),pz(j)];
	    spos_xy = app add [spos * x, spos * y];
#endif

		// im is the mask of visible contour points that do NOT
		// intersect any other contour circles of the union.

	    [ss] = prox_find [pkey, spos_xy, 0];
	    im = not ss;
#if CONTOUR_LINES
		// If all points of the j-th contour circle are visible, draw
		// then now.

	    if alltrue im then
		GVertex [GOBJ_QUE_key2, 2, igen l_length cpos, color, spos];

		// If the j-th contour circle partially partially visible and
		// partially hidden, do further processing.

	    elseif anytrue im then

		    // Split the j-th contour circle in to intervals of
		    // consecutive visible points.

		m = im and not rotr im;	// m marks the start of each interval
		local d = apt rot [cat [[im,m], spos, spos_xy], 1-x_max m];
		d(2) = pscan d(2);
		d = dropfirst d || [first d];
		d = tr apt split [dropfirst d, [btoc first d]];

		    // Ensure that each interval has even number of points.

		for k = 1, length d loop
		    n = l_length d(k);
		    if n < 2 then continue; endif
		    if odd n then d(k) = app droplast d(k); n = dec n; endif
#if STORE_D
			// Store each interval in jpos(jk).

		    jpos(jk = inc jk) = keep [d(k), 3];
		    jidx(jk) = i;
		    local xy = drop [d(k), 3];
		    jxy1(jk) = app first xy;
		    jxy2(jk) = app last xy;
		    jcdist(jk) = cdist;
#else
			// Draw the visible interval.

		    GVertex [GOBJ_QUE_key2, 2, igen n, color, keep [d(k), 3]];
#endif
		endloop
	    endif
#else
	    cidx = igen iadd im;
	    local arg = [GOBJ_QUE_key2, 1, cidx, color, spos || [im]];
	    GVertex arg;
#endif
	endloop
	prox_close pkey;
    endloop
endfunction

local function make_longlabel;

// draw_que_features draws all query features and volumes from the values
// of DD_xxx variables.

local function draw_que_features force	// (M1)
    if DBG then event 'que_update_gobj'; endif
    static last_spheres, last_view, last_tstate;
    if anytrue force then last_spheres = last_view = last_tstate = []; endif

	// Prevent reentrant execution:  If a new A is reentering
	// a running B, let B do the A's work in an extra loop iteration.

    static running;
    if anytrue running then running = 2; return; endif	// force extra iteration
    running = 1;					// one iteration
    loop	// SPECIAL USE: loop body not nested!

	// First time in, generate precomputed spheres

    static TEXT_COLOR;
    if isnull TEXT_COLOR then
	TEXT_COLOR = (ViewSetup[]).text_color;
    endif

	// Reset the last-drawn-view value (to avoid being called again
	// if the view does not change).

    GOBJ_QUE_ViewOrientation = ViewOrientation[];

	// If there is no text to be drawn, make sure that the gobj is empty
	// and return immediately.

    if isnull DD_expr then
	if length last_spheres then
	    GClearVertexData [DD_gkey, GOBJ_QUE_key1, GOBJ_QUE_key2];
	    GClearTextData [DD_gkey, GOBJ_QUE_key1, GOBJ_QUE_key2];
	    last_spheres = [];	// avoid (re)creating gobj next time around
	endif
	continue;
    endif

	// Avoid redrawing the same data (unless the graphics object
	// was destroyed).  !Note!: this will fail to detect any changes
	// that done externally, directly (programmatically) to the gobj.

    local function text_state []
	local rstate = 0;
	if QUE_textmode == 3 then
	    rstate = [DD_rval, DD_sval, SVAL_useRval, SCHEME_svalOK];
	endif

	return [
	    QUE_textmode, rstate,
	    DD_expr, DD_gbits, DF_count, DV_count,
	    QUE_gtextcolored
	];
    endfunction
    local text_changed = neL [last_tstate, last_tstate = text_state []];

    local view_changed = neL [last_view, last_view =
	GOBJ_QUE_ViewOrientation
    ];

    local spheres_changed = neL [last_spheres, last_spheres = [
	QUE_scaled_density, DF_count, DV_count,
#if SHOW_DC_OPTION
	DD_expr, DD_ebits, DC_expr, DC_ids, DC_ebits, DC_gbits,
#elseif SHOW_DC_SAMEAIDX
	DD_expr, DD_ebits, DC_expr, DC_ids, DC_ebits,
#endif
	DD_gbits, DD_color, DD_x, DD_y, DD_z, DD_r, DD_sel, DD_usel, DD_umask
    ]];

	// !!! Future fix: do not redraw spheres when nothing changed
	// except view orientation; !!! process force_text

    if allfalse [text_changed, view_changed, spheres_changed] then
	continue;
    endif

	// Destroy previous gobj and create a new one.
	// NOTE: each editor instance uses a separate unique name.

    GClearVertexData GOBJ_QUE_key2;
    GClearTextData GOBJ_QUE_key2;
    if DBG then event 'que_draw_gobj'; endif	// new gobj --> redraw

	// Calculate the plane of the screen in the current view

    local y = first GOBJ_QUE_ViewOrientation;
    local z = second GOBJ_QUE_ViewOrientation;
    local x = rot3d_vCross GOBJ_QUE_ViewOrientation;
    local diag = rot3d_vNormalize (x+y);
    draw_contour 1;	// draw selection

	// Memoize sphere(type=i)(density=j):
	// If the sphere of the given type and density has been
	// previously requested, fetch it directly from the table.
	// Otherwise, calculate the sphere and store it in the table.

    local function get_sphere [i, j]
	static SPHERE;
	if isnull SPHERE(i)(j) then
	    if i == 3 then
		SPHERE(3)(j) = G_Sphere [0x0, 0, 1, dec j];
	    else
		SPHERE(1)(j) =
		SPHERE(2)(j) = G_WireSphere [0x0, 0, 1, dec j];
		SPHERE(1)(j)(1) = 1;
		SPHERE(1)(j)(2) = igen l_length SPHERE(1)(j)(4);
	    endif
	endif
	return SPHERE(i)(j);
    endfunction

	// Prepare to generate spheres and text

    DD_r = maxE [0, DD_r];

	// Generate spheres, as required.
	// gbits: 0x80=hidden
	// mask 0x07: 0=line, 1=dot, 2=contour, 3=solid, 4=none
	// mask 0x700: 0=min, 1=low, 2=med, 3=high, 4=max


    // local dd_hidden = bitand [DD_gbits, 0x80];

	// Dynamically adjust sphere density to compensate
	// for bigger radii
	// sidx = sum_K {rad > threshold(K)}

    const RAD_THRESHOLD = [0, 2.5, 6.5];
    // local sidx = iadd ([app max DD_r] >= RAD_THRESHOLD);	// sphere idx
    local sidx = iadd ([DD_r] >= RAD_THRESHOLD);	// sphere idx
    sidx | DD_umask = 1;

	// Adjust individual spheres for custom rendering

    local m = bitand [0x07, DD_gbits];		// rendering mode
    local si1 = [2,1,-1,3,0,0,0,0][inc m];	// line,dot,contour,solid,none
    local si2 = bitand [0x700, DD_gbits];	// density = 0x0..0x7 << 8
    si2 = minE [maxE [1, bitshr [si2, 8]], 5];	// density = 1..5

	// If scaled density is turned on, adjust the density according
	// to the radius

    local sofs;

	// Option 1: Scaled low, med, and high densities

#	if 1
	if SCALED_DENSITY == 0 then
	    // don't scale
	elseif SCALED_DENSITY == 1 then
	    sofs = dec dec iadd ([DD_r] >= RAD_THRESHOLD);
	    m = not ltE [1, si2, 5];	// low, med, high
	    sofs | m = zero (sofs | m);
	    si2 = minE [maxE [1, iadd [si2, sofs]], 5];
	elseif QUE_scaled_density then
	    sofs = dec dec iadd ([DD_r] >= RAD_THRESHOLD);
	    si2 = minE [maxE [1, iadd [si2, sofs]], 5];
	endif

	// Option 2: Use per-sphere setting of scaled density (gbit 0x800)

#	else
	m = bitand [0x800, DD_gbits];	// scaled density
	if anytrue m then
	    local sofs = dec dec iadd ([DD_r|m] >= RAD_THRESHOLD);
	    si2|m = minE [maxE [1, iadd [si2|m, sofs]], 5];
	endif
#	endif

	// Strip hidden spheres

    m = bitand [DD_gbits, GBIT_HIDDEN];	// hidden spheres
    sidx | m = 0;
    si1 | m = 0;

	// Draw spheres that are in contour mode gbits: 0x07=2 && 0x80=0

    draw_contour 0;

	// Generate spheres
	// Note: spheres are memoized in table SPHERE(type)(density),
	// where type:1=dot,2=line,3=solid and density:1=min,..5=max

    local i, j, k, maxr, smallr, pkey;
    const EPS_3D = 0.02;	// max. allowed overlap

    local gdata = [], ngdata = 0;

// !!! intersecting triangles of all solid-surfaces should be retriangulated!
// !!! for 2014: merge back and debug code from ph4_intersection.svl (MARK #)
    if spheres_changed then
// PR '--- draw_que_features -----------------------------';
	for i = 1, length DD_expr loop
	    local sphere, arg;
	    if si1(i) <= 0 then continue; endif		// none or contour

	    sphere = get_sphere [si1(i), si2(i)(1)];

		// Draw the sphere of a feature or a single-sphere volume

	    local do_single = not DD_umask(i);
#if NEW_VOLSURF
	    if do_single and si1(i) == 2 then
		do_single = max DD_r(i) < 2;	// big line spheres with msurf
	    endif
#endif

	    if do_single then
// !!! dot-spheres should be generated with Fibonacci spheres
		arg = cat [DD_gkey(i), sphere];
		arg(4) = DD_color(i);
		arg(5) = arg(5) * DD_r(i) + [DD_x(i), DD_y(i), DD_z(i)];
		gdata(ngdata = inc ngdata) = arg;
		continue;
	    endif

		// Draw the spheres of a multiple-sphere volume.
		// The intersection of the spheres is calculated with proxy_.
		// Points/lines/triangles with vertices that fall into
		// the intersection (plus tolerance) are discarded.

	    local seg, idx;
// MARK 1
// MARK 2
	    local use_msurf = 1;
	    if use_msurf then if maxR DD_r > 20 then use_msurf = 0; endif endif

	    if not use_msurf then
		smallr = maxE [0, DD_r(i) - EPS_3D];
		maxr = max [0.5, max smallr];
		pkey = prox_open [maxr, [DD_x(i),DD_y(i),DD_z(i)], smallr];
		for j = 1, length DD_r(i) loop
		    if SCALED_DENSITY == 0 then
		    elseif SCALED_DENSITY == 1 then
			sphere = get_sphere [si1(i), si2(i)(j)];
		    elseif QUE_scaled_density then
			sphere = get_sphere [si1(i), si2(i)(j)];
		    endif
		    arg = cat [DD_gkey(i), sphere];

			// a2 ... segment vector (3 for triangles)
			// a5 ... vertices of j-the sphere of (i-NF)-th volume

		    arg(4) = DD_color(i);
		arg(5) = arg(5)*DD_r(i)(j) + [DD_x(i)(j),DD_y(i)(j),DD_z(i)(j)];
// MARK 3
		    local a2 = arg(2), a3 = arg(3), a5 = arg(5);

			// Keep only triangles that are outside all spheres.
			// seg>0 marks points that are inside another sphere.
			// iidx are indices of vertices that should be removed.
			// im is the mask of items that will be kept.

		    [seg, idx] = prox_find [pkey, arg(5), 0];
		    if allfalse seg then // sphere does not intersect any other
			gdata(ngdata = inc ngdata) = arg;
			continue;
		    endif
		    local iidx = x_pack not seg;
		    // local im = app andE split [m_join [a3, iidx], a2];
		    local nv = s_add [m_join [a3, iidx], a2];	// #vt per tri
		    local im = nv == a2;			// full tri's
		    if allfalse im then	// sphere fully inside the union
			continue;
		    endif
// MARK 4
		    arg(3) = a3 | stretch [im, a2];;

// MARK 5
		    gdata(ngdata = inc ngdata) = arg;
		endloop
		prox_close pkey;

	    else
		local gpos = [DD_x(i), DD_y(i), DD_z(i)];
		local grad = minE [DD_r(i), 20];
		local spacing = select [0.8, 0.3, si1(i) == 2];
		local [isoidx, vcolor, vpt, vnrm] = msurf_MolecularSurface [
		    gpos, grad, 0, gpos, grad + 1.0, [
			type:	'VDW',
			spacing:	spacing,
			minspacing:	spacing
		    ]
		];
		local vidx = reverse grid_isoidx_emit [isoidx, si1(i), -1];
		arg = [DD_gkey(i), si1(i), vidx, DD_color(i), vpt, -vnrm];
		gdata(ngdata = inc ngdata) = arg;
	    endif
	endloop
// !!! update each DD_gkey(i) separately!
	GClearVertexData DD_gkey;

	app GVertex gdata;
    endif

#if SHOW_DC_SAMEAIDX
    // const DC_COLOR = 0xff4040;
    // const DC_COLOR0 = 0xe040a0;
    static DC_COLOR, DC_COLOR0;
    static LAST_state, DD_proj1, DD_proj2, DD_proj;

    if neL [LAST_state, [SCHEME_name, DD_expr]] then
	LAST_state = [SCHEME_name, DD_expr];
	DC_COLOR = GetRCNumber [RC_DC_COLOR, 0xff4040];
	DC_COLOR0 = GetRCNumber [RC_DC_COLOR0, 0xe040a0];
#if 1
	DD_proj = ph4_ExprProjectedBits [DD_expr, SCHEME_name];
#else
	local DD_sbits = ph4_ExprNeededBits [DD_expr, SCHEME_name, 1];
	DD_proj = ph4_SchemeBitsProjected [SCHEME_name, DD_sbits];
#endif
    endif

    GClearVertexData GOBJ_QUE_key1;
    for i = 1, DC_count loop
	if DC_expr(i) <> 'SAMEAIDX' then continue; endif
	if bitand [DC_ebits(i), EBIT_IGNORED] then continue; endif
	local ids  = DC_ids(i);
	local m_ok = not bitand [DD_ebits[ids], EBIT_IGNORED];
	if add m_ok < 2 then continue; endif

#	if SHOW_DC_OPTION
	    local gtype = bitand [DC_gbits(i), 0x3];
	    if gtype == 0 then continue; endif
#	endif

	    // Find mask of all features considered "projected".

	local m_proj1 = DD_proj[ids] < 0;
	local m_proj2 = DD_proj[ids] > 0;
	local center = [];

	if add m_proj1 == 1 and add m_proj2 >= 1 then
	    local jcenter = x_pack m_proj1;
	    if not m_ok(jcenter) then continue; endif
	    center = apt peek [[DD_x,DD_y,DD_z], ids(jcenter)];
	    ids = ids | m_ok and m_proj2;
	else
#	    if SHOW_DC_CONES
		gtype = 1;	// can do lines but not cones
#	    endif
	    ids = ids | m_ok;
	endif

	local xyz = apt get [[DD_x, DD_y, DD_z], [ids]];
	local pt = tr xyz;
#if 0
#else
	local pt1, pt2;
	local shown = not bitand [DD_gbits[ids], GBIT_HIDDEN];
#endif

	    // If there is no "projecting" feature, fit a plane, order
	    // the features by their y/x angle in that plane, and connect
	    // the features in that order with lines.

	if isnull center then
	    local p = xyz - app add xyz * invz l_length xyz;
	    local M = split [app add cat (nest p - app nest p), 3];
	    local [e,Q] = symeigensystem M;
	    Q(3) = vcross keep [Q,2];
	    p = matmul [Q, p];
#if 0
	    pt = pt[x_sort atan2 [p(2), p(1)]];
	    GLine cat [GOBJ_QUE_key1, DC_COLOR0, tr pt, tr rotl pt];
#else
	    local kk = x_sort atan2 [p(2), p(1)];
	    pt = pt[kk];
	    shown = shown[kk];
	    pt1 = pt; pt2 = rotl pt;
	    [pt1, pt2] = [pt1, pt2] || [shown or rotl shown];
	    GLine cat [GOBJ_QUE_key1, DC_COLOR0, tr pt1, tr pt2];
#endif

	    // Display 3d-arrows (cones) centered at center, with
	    // endpoints at pt[1..#ids].

#	if SHOW_DC_CONES
	elseif gtype == 2 then
	    for j = 1, length ids loop
		local pt0 = pt(j);
		local pt1 = center + (pt0 - center) * 0.5;
		const r1 = 0.3, r2 = 0.5, q = 2;
		local d;
		if length ids > 1 then
		    d = G_Sphere [DC_COLOR, center, r1, q];
		else
		    d = G_Circle [DC_COLOR, center, center-pt0, r1, q];
		endif
	// GClearVertexData GKey [DD_gkey, GOBJ_QUE_key1];
	// GClearTextData GKey [DD_gkey, GOBJ_QUE_key1];
		GVertex cat [GOBJ_QUE_key1, d];
		d = G_Cylinder [DC_COLOR, center, pt1-center, r1, q];
		GVertex cat [GOBJ_QUE_key1, d];
		d = G_Circle [DC_COLOR, pt1, pt1-pt0, r2, q];
		GVertex cat [GOBJ_QUE_key1, d];
		d = G_Cone [DC_COLOR, pt1, pt0-pt1, r2, q];
		GVertex cat [GOBJ_QUE_key1, d];
	    endloop
#	endif

	    // Display lines connecting the center with points pt[1..#ids].

	else
	    local eps = (xyz - center) * 0.1;
#if 0
	    GLine cat [GOBJ_QUE_key1, DC_COLOR, center+eps, xyz-eps];
#else
	    pt1 = (center+eps) || [shown];
	    pt2 = (xyz - eps)  || [shown];
	    GLine cat [GOBJ_QUE_key1, DC_COLOR, pt1, pt2];
#endif
	endif
    endloop
#endif

	// Calculate the top-right sphere in each union of spheres

    local rad = DD_r | DD_umask;		// radii of union spheres
    local pos = [DD_x, DD_y, DD_z] || [DD_umask]; // pos's of union spheres
//  [rad, center, normal] = AffSphereHorizon [A, rad, center];
//  local top_right = ...
    k = app x_max (add (pos*diag) + rad);	// indices of top-right spheres
    k = app x_id rad == k;			// convert indices to a mask
    rad = mput [DD_r, DD_umask, rad || k];
    pos(1) = mput [DD_x, DD_umask, pos(1) || k];
    pos(2) = mput [DD_y, DD_umask, pos(2) || k];
    pos(3) = mput [DD_z, DD_umask, pos(3) || k];

	// Generate text, as required.
	// fidx: text: 1=none, 2=short, 3=long

    local fidx = rep [minE [inc QUE_textmode, 3], length rad];
    m = bitand [DD_gbits, GBIT_HIDDEN];
    fidx | m = 1;					// hidden text

	// !!!
	// Suffix each type label in que.feature expression with its
	// corresponding sval.
	// Note: que.feature "sval" is the minimum strength value of a matching
	// ann.pt.  It may be a combination of rval extracted from the receptor,
	// query-wide EHB and per-feature mval offset.

	// !!! Always compute full expression, to put into list.

    local expr = DD_expr;

// !!! verify make_longlabel implementation!
    // fidx = lhs [minE [inc QUE_textmode, 3], fidx];
    if QUE_textmode == 3  and SCHEME_svalOK then
	expr = make_longlabel [];
    endif

	// Generate text, as required (cache for speed).
	// fidx: 0=none, 1=short, 2=long

    static last_fidx, last_text;
    if text_changed or neL [last_fidx, last_fidx = fidx] then
	last_text = app token apt swrite [
	    ['', '{}{}', '{}{}{}{}'][fidx],	// 1:none, 2:short, 3:long
	    stretch [['F', 'V'], [DF_count, DV_count]],
	    cat [igen DF_count, igen DV_count],
	    select [':', '', tok_length expr],
	    expr
	];
    endif

	// If all text hidden, just clear the gobj.

    m = tok_length last_text;
    if allfalse m then
	GClearTextData GOBJ_QUE_key2;
	continue;
    endif

	// Set the text color

    local color = DD_color;
    if allfalse QUE_gtextcolored then color = TEXT_COLOR; endif	// obsolete
    local text = last_text;

	// Remove hidden text.

    if neL m then
	[color, rad, pos, text] = [color|m, rad|m, pos||[m], text|m];
    endif

	// Draw the visible text.
	// Note: GClearText must be close to GText to minimize flicker.

// !!! needed better perspective transform!
//  [rad, center, normal] = AffSphereHorizon [A, rad, center];
//  local top_right = ...
    rad = (rad + 0.1) * 1.03;
    pos = pos + [rad+0.1] * diag;
    GClearTextData GOBJ_QUE_key2;
    GText cat [GOBJ_QUE_key2, [color], pos, [text]];

    until not (running = dec running) endloop
endfunction


// Return 1 iff the chain of query annotation dummies, CHAIN_QUE_key, is valid.

local function ph4que_chain_ok []	// (M2)
    // if isnull CHAIN_QUE_key then	(coldinit)
    if neL [oType CHAIN_QUE_key, 'chain'] then
    elseif neL [cTag CHAIN_QUE_key, CHAIN_QUE_tag] then
    else return 1;
    endif
    return 0;
endfunction


// ensure_que_dummies ensures existence and proper state of dummy atoms needed
// to represent DD_* properties.  (Note: since private chains are no longer
// displayed in SE, we no longer set or check properties of dummy residues.)
// full_check: 0=DD_atom key valid, 1=DD_atom aProperties valid, 2=redraw all

local function ensure_que_dummies full_check	// (M1)
    local redraw = full_check === 2;

	// Verify the query chain.  (Create/recreate if not valid.)

    if not ph4que_chain_ok[] then
	if DBG then event 'que_create_c'; endif
	redraw = 1;
	loadstore_view 1; // Reset view parameters to values before Close[]

	CHAIN_QUE_key = oCreate 0;
	cSetName [CHAIN_QUE_key, CHAIN_QUE_NAME];
	cSetTag [CHAIN_QUE_key, CHAIN_QUE_tag];
	cSetHeader [CHAIN_QUE_key, DS_title];
    endif

    local [chain] = CHAIN_QUE_key;
    local r = cat oChildren chain;

	// Sync the number of chain residues with DD_xxx.
	// Destroy excess residues, without destroying their atoms
	// (if possible).  Create missing residues.
	// !!! later: put all dummy atoms belonging to the same union
	// in the same residue (i.e. 1 res/union, and not 1 res/sphere)

    local usize = 1;
    local do_seg = not isflatnum DD_sel;	// !!! same as DD_umask
    if do_seg then usize = app length DD_sel; endif

    local a = cat DD_atom;
    local n = length a;
    local n_missing_res = n - length r;
    local r2;

    if n_missing_res < 0 then	// too many residues: drop the last few
	if DBG then event 'que_destroy_r'; endif
	full_check = 1;
	r = r[x_sort not oChildCount r];	// empty res's to the end
	r2 = keep [r, n_missing_res];		// residues to destroy
	if n then oReparent [cat oChildren r2, r(1)]; endif // keep their atoms
	oDestroy r2;				// destroy residues (now empty)
	r = keep [r, n];			// keep n res's (& all atoms)
    elseif n_missing_res > 0 then // too few residues: create a few new ones
	if DBG then event 'que_create_r'; endif
	full_check = 1;
	r2 = oCreate rep [chain, n_missing_res]; // new residues
	r = cat [r, r2];
    endif

	// Destroy excess dummies (dummies not in DD_atom).

    local cur_atoms = cat oChildren r; // dummies currently in the DD chain
    local m;

    if anytrue (m = m_diff [cur_atoms, a]) then	// excess dummies
	if DBG then event 'que_destroy_a'; endif
	full_check = 1;
	redraw = 1;
	oDestroy (cur_atoms | m);	// destroy excess dummies
	cur_atoms = cur_atoms | not m;	// update the list
    endif

	// Create missing dummies (DD_atom's without dummies).

    a[x_diff [a, cur_atoms]] = 0;	// set handles of missing dummies to 0
    // a | not m_uniq a = 0;// duplicated dummies (!doesn't occur!)
    if anytrue (m = not a) then		// missing dummies
	if DBG then event 'que_create_a'; endif
	redraw = 1;
	a | m = oCreate (r | m);	// create missing dummies
	aSetInert [a | m, 1];
	aSetElement [a | m, 'LP'];
	aSetColorBy [a | m, 'rgb'];
	aSetPos [a | m, app cat [DD_x,DD_y,DD_z] || [m]];
#ifnot APOS_IS_DOUBLE
	// Make sure that (float)DD_xyz === (double)DD_xyz (aPos[] vs. SVL)
	local pos = aPos (a | m);
	if do_seg then	// split xyz into unions
	    DD_x = split [mput [cat DD_x, m, pos(1)], usize];
	    DD_y = split [mput [cat DD_y, m, pos(2)], usize];
	    DD_z = split [mput [cat DD_z, m, pos(3)], usize];
	else				// no unions present (simpler)
	    DD_x | m = pos(1);
	    DD_y | m = pos(2);
	    DD_z | m = pos(3);
	endif
#endif
	aSetSelected [a | m, cat DD_sel | m];
    endif

    DD_atom = a;
    if do_seg then
	DD_atom = split [DD_atom, usize];
    endif

	// If any atoms changed, we redraw the graphics objects
	// and force a full check

    if redraw then
	// !!! should be done explicitly by the caller (if needed)
	// draw_que_features[];
	full_check = 1;
    endif

	// If only a minimum checking is requested, we are done.
	// (The DD_atom are now all valid, even though they may be
	// of wrong color, wrong type or belong to wrong residues...)

    // if allfalse full_check then return; endif
    if allfalse full_check then return; endif

	// Verify indices of dummy atoms.  Reparent if necessary.

    m = oIndex oParent a == x_id a;
    if anyfalse m then oReparent [a, r]; endif

	// Mask of spheres rendered in the contour mode:
	// The centers will be drawn as transparent black points
	// to make them usable for meters yet invisible.

    local cmask =
	bitand [DD_gbits, 0x07] == 2			// contour
	and x_id DD_gbits > DF_count;			// volume

	// Set common atomic properties (avoid redraw if possible)

    local look = 'small-sphere';
    look | cmask = 'point';
    look = stretch [look, usize];

    if anyfalse (aElement a == 'LP') then aSetElement [a, 'LP']; endif
    if anyfalse (aInert a == 1) then aSetInert [a, 1]; endif
    if anyfalse (aColorBy a == 'rgb') then aSetColorBy [a, 'rgb']; endif
    if anyfalse (aNucleusLook a == look) then aSetNucleusLook [a, look]; endif

	// Calculate values of individual atomic properties

    const i10 = ['0','1','2','3','4','5','6','7','8','9'];
    const oF = dropfirst cat tok_cat ['F', put [i10,1,''], [i10]];
    const oV = dropfirst cat tok_cat ['V', put [i10,1,''], [i10]];
    local oname = cat [resize [oF, DF_count], resize [oV, DV_count]];
    oname = stretch [oname, usize];

    local color = DD_color;
// !!! there is somewhere a needless update of this!
//     PR [color: [length DD_color, length cmask]];
    color | cmask = 0xff000000;	// fully transparent black
    color = stretch [color, usize];

    local hidden = notnot bitand [DD_gbits, GBIT_HIDDEN];
    hidden = stretch [hidden, usize];

	// Set individual atomic properties (avoid redraw if possible)

    if neL [aName a, oname] then aSetName [a, oname]; endif
    if neL [aRGB a, color] then aSetRGB [a, color]; endif
    if neL [aHidden a, hidden] then aSetHidden [a, hidden]; endif

    loadstore_view 0;	// Store view parameters to be restored on Close[]
endfunction

// update_dist measures and diplays distance between selected volume(s)
// and the nearest visible atom(s).  The distance is measured as
// center-to-center minus probe radius.  (The atom radius is ingored.)
// This could be a high-frequency update, so draw only when necessary.
// Note: update dist should be called when:
// - atom visibility or atom positions change
// - volume selection changes
// - expressions on (selected) volumes change
// - positions of (seleceted) volume spheres change

local function update_dist [wkey, force]	// (M1)
    if DBG then event 'que_dist'; endif

    local function set_page [wkey, k]
	static last_page;
	if neL [last_page, k] then
	    WindowSetAttr [wkey, [eD_dist_p: [page: (last_page = k)]]];
	endif
    endfunction

	// Get atoms to measure
	// m = mask of DD_ items that correspond to volume spheres

    static last_dist, last_page, last_a, last_v_expr;
    if anytrue force then last_page = -1; endif
    local a = cat LIG_atom;
    a = a | oType a == 'atom';		// safety
    local m = (app anytrue DD_sel or DD_usel) and x_id DD_usel > DF_count;

	// If there is nothing to measure,
	// flip page to hide the distance

    if isnull a or allfalse m then
	set_page [wkey, 2];
	return;
    endif

	// Mask, expressions and ebits of selected volumes

    local v_expr = DD_expr | m;
    local v_ebits = DD_ebits | m;
    static v_aset, k;
    static errcount;

	// For each selected volume, k, calculate a set of atoms,
	// v_aset(k), that match the volume expression.

    if neL [[a, v_expr], [last_a, last_v_expr]] then
	[last_a, last_v_expr] = [a, v_expr];

	v_aset = rep [[], length v_expr];
	local a_heavy = a | aAtomicNumber a > 1;

	errcount = 0;
	for k=1, length v_expr loop
	    if tok_length v_expr(k) then
		// v_aset(k) = uniq cat sm_MatchAtoms [v_expr(k), a];
		local errmsg = ph4_ExprCheckSyntaxV v_expr(k);
// !!! local errmsg = ph4_ExprCheckSyntax [v_expr(k), SCHEME_type, 1];
		if tok_length errmsg then
		    errcount = inc errcount;
		    continue;
		endif
		v_aset(k) = a | ph4_ExprAtomMask [v_expr(k), a];
	    else
		v_aset(k) = a_heavy;
	    endif
	endloop
    endif

	// If no atoms match any volume expression, exit now.

    if anytrue errcount then
	set_page [wkey, 3];
	return;
    elseif allfalse v_aset then
	set_page [wkey, 2];
	return;
    else
	set_page [wkey, 1];
    endif

	// For each selected volume, idx, calculate the distance
	// from the set of atoms that match the volume expression
	// to the volume boundary.

    local v_x  = DD_x | m;
    local v_y  = DD_y | m;
    local v_z  = DD_z | m;
    local v_r  = DD_r | m;
    local d = Inf;

	// Check whether a recalculation is necessary

    local all_apos = aPos uniq cat v_aset;
    local all_vpos = [v_x, v_y, v_z, v_r];
    static last_calc;
    if last_calc === [all_apos, all_vpos, v_ebits] then
	return;
    else
	last_calc = [all_apos, all_vpos, v_ebits];
	all_apos = all_vpos = [];
    endif

	// For each selected volume, determine which of the annotated
	// atoms match the volume expression and calculate the distance
	// between the volume and the atoms.

    for k=1, length v_expr loop
	if isnull v_aset(k) then continue; endif

	    // Get positions to measure.

	local apos_k = aPos v_aset(k);
	local v_pos_k = [v_x(k), v_y(k), v_z(k)];
	local v_rad_k = v_r(k);

	    // Measure the distance to the nearest point.

	local d_k;
	if bitand [v_ebits(k), V_EBIT_ALL] then	// excluded exterior
	    d_k = - max app min (norm (apos_k - app nest v_pos_k) - [v_rad_k]);
	else					// excluded or included
	    d_k = min app min (norm (app nest apos_k - v_pos_k) - v_rad_k);
	    if bitand [v_ebits(k), V_EBIT_ANY] then d_k = -d_k; endif // incl.
	endif
	d_k = round (d_k * 1e5) * 1e-5;		// strip junk bits

	    // Calculate the minimum distance over all selected volumes.

	d = min [d, d_k];
    endloop

	// If it is already shown, do nothing more.
    if eqL [last_dist, d] then return; endif
    last_dist = d;

	// Show the distance (to the boundary of the V sphere)

    local dstr = token swrite ['{n:5.1f}', d];
    if dstr == '  0.0' and d <> 0 then
	dstr = select [' +0.0', ' -0.0', d > 0];
    endif
    WindowSetData [wkey, [eD_dist: dstr]];

	// Show negative distances in red (if atoms inside the V sphere)

    if DIST_COLOR then
	WindowSetAttr [wkey, [eD_dist: [foreground:
	    select ['none', 'baseRed', d > 0]
	]]];
    endif
endfunction


// set_edit_page sets the edit page according to the current selection
// and the current ph4 data, DF_xxx, DC_xxx,

local function update_sval;
local function set_edit_page wkey	// (M3)
    local a, r, l, t, c, m, k;

    local nF = iadd keep [DD_sel, DF_count];
    local nC = iadd DC_sel;
    local nU = iadd DD_usel;
    local nV = iadd drop [app anytrue DD_sel or DD_usel, DF_count];

    local page = EPAGE_DIVERSESEL;
    if (nF or nV) and not nC then page = EPAGE_DUMMIES;
    elseif nC==1 and not nV then page = EPAGE_CONSTRAINTS;
    elseif allfalse [DD_atom,DC_expr] then page = EPAGE_EMPTYQUERY;
    // elseif isnull DD_atom then page = EPAGE_NOSPHERES;
    elseif allfalse [nF,nV,nC] then page = EPAGE_EMPTYSEL;
    elseif nC and not nV then page = EPAGE_MANYCONSTRAINTS;
    elseif nC and nV then page = EPAGE_MIXEDCONSVOLS;
    endif

    // !!! WT: resetting the same page removes the focus
    static last_page;
    if neL [last_page, page] then
	WindowSetAttr [wkey, [edit_page_p: [page: page]]];
	last_page = page;
    endif
    DIST_monitor = 0;
    local bhelp = ph4_edit_bhelp [];

    if page > EPAGE_CONSTRAINTS then	// not an editing page

	// One constraint with some (or no) features and no volumes

    elseif page === EPAGE_CONSTRAINTS then
	local kC = x_max DC_sel;

	    // Ignore bit for constraints

	local dc_ignore = bitand [DC_ebits | DC_sel, EBIT_IGNORED];
	dc_ignore = select [first dc_ignore, 0, eqL dc_ignore];

	local eC_type =	indexof [DC_expr(kC), CTYPE(1)];
	local constrain_type = inc (eC_type > N_CTYPE_NFEAT);
	local nfeatures_x = select [eC_type, 0, constrain_type == 1];
	local sourceatoms_x = select [
	    eC_type - N_CTYPE_NFEAT, 0, constrain_type == 2];

	WindowSetData [wkey, [
	    eC_ignore:			dc_ignore,
	    eC_type:			eC_type,
	    constrain_type:		constrain_type,
	    constrain_nfeatures:	nfeatures_x,
	    constrain_sourceatoms:	sourceatoms_x
	]];

	local xC = sort DC_ids(kC);			// constrained Fs
	local xF = x_pack keep [DD_sel, DF_count];	// selected Fs
	local xEQ = eqL [xC, xF];

	WindowSetAttr [wkey, [
	    // !!! WT: prevent panel width growth with fixed titleFont
	    eC_type: [
		// title:	token swrite ['C{}:', kC]
		title:	token swrite ['{}C{}:', select ['',' ',kC>9], kC]
	    ],
	    constrain_select: [foreground: select ['highlight', 'none', xEQ]],
	    constrain_replace: [sensitive: nF >= 2 and not xEQ],
	    constrain_nfeatures: [sensitive: constrain_type == 1],
	    constrain_sourceatoms: [sensitive: constrain_type == 2]
	]];

#if SHOW_DC_OPTION
#	if SHOW_DC_CONES
	    local showv = inc bitand [0x3, DC_gbits(kC)];
#	else
	    local showv = notnot bitand [0x3, DC_gbits(kC)];
#	endif
	WindowSetData [wkey, [ eC_show:	showv ]];

	local showp = select [1, 0, DC_expr(kC) == 'SAMEAIDX'];
	WindowSetAttr [wkey, [ eC_show_p: [ page: showp ]]];
#endif

	// Spheres of features and/or volumes have been selected

    elseif page === EPAGE_DUMMIES then

	    // Average radius of all spheres

	m = DD_usel or DD_sel;
	local dd_rad = add (cat DD_r | cat m) * invz iadd cat m;
	local dd_rad_sens = anytrue m;

	    // Either the same color or no color at all

	m = DD_usel or app anytrue DD_sel;
	// local dd_color = '', dd_showcolor = 'background';
	local dd_color = DefaultColorBG[];

	if eqL (DD_color|m) then
	    // dd_showcolor = DD_color(x_max m);
	    if not USE_AUTOBIT then
		dd_color = int_to_color DD_color(x_max m);
	    elseif not eqL bitand [DD_gbits|m, 0x40] then
		dd_color = '';
	    elseif bitand [DD_gbits(x_max m), 0x40] then
		dd_color = AUTOLABEL;
	    else
		dd_color = int_to_color DD_color(x_max m);
	    endif
	endif

	    // Essential bit for features

	const CBCOLOR_NE = 'background';
	const CBCOLOR_EQ = select ['white', 'background', ENABLE_CBCOLOR];
	const BTNCOLOR_EQ_ON = 'baseRed';
	const BTNCOLOR_EQ_OFF = 'foreground';
	const BTNCOLOR_NE = 'darkYellow';

	local dd_ess =
	    bitand [DD_ebits | m and x_id m <= DF_count, EBIT_ESSENTIAL];
	local dd_ess_bg = select [CBCOLOR_EQ, CBCOLOR_NE, eqL dd_ess];

	local dd_ess_sens;		// Allow "Essential" on multi-selection:
	if ESSENTIAL_MODE == 2 then	// At least one feature selected
	    dd_ess_sens = nF;
	elseif ESSENTIAL_MODE == 1 then	// No volumes or unions selected
	    dd_ess_sens = not nV;
	else				// Exactly one feature selected
	    dd_ess_sens = nF == 1;
	endif
	dd_ess_sens = dd_ess_sens and length dd_ess;
	dd_ess = alltrue dd_ess and dd_ess_sens;

	    // Examine the types of the selected volumes, dd_v_ebits.
	    // If all types the same, set option to V_OPTION(dd_voltype=1..3).
	    // Otherwise, use V_OPTION(dd_voltype=4)=''.

	local dd_v_ebits = DD_ebits | (m and x_id m > DF_count);
	local dd_voltype = 4;		// sel.vol.types different
	local dd_voltext = V_OPTION2;	// V_OPTION + 4th elm = ''

	if isnull dd_v_ebits then
	elseif neL (dd_v_ebits = bitand [dd_v_ebits, V_EBITMASK]) then
	elseif not (dd_voltype = indexof [first dd_v_ebits, V_EBITS]) then
	    dd_voltype = 4;
	else
	    dd_voltext = V_OPTION;	// common v.type: dd_voltype=1..3
	endif

	local dd_voltype_sens;
	if VOLTYPE_MODE == 2 then		// At least one vol selected
	    dd_voltype_sens = nV;
	elseif VOLTYPE_MODE == 1 then		// No features selected
	    dd_voltype_sens = not nF;
	else					// Exactly on volume selected
	    dd_voltype_sens = nV == 1;
	endif

	    // Ignore bit for features and volumes

	local dd_ignore = bitand [DD_ebits | m, EBIT_IGNORED];
	local dd_ignore_bg = select [
	    select [BTNCOLOR_EQ_ON, BTNCOLOR_EQ_OFF, alltrue dd_ignore],
	    BTNCOLOR_NE,
	    eqL dd_ignore
	];
	dd_ignore = alltrue dd_ignore;

	    // Hidden bit for features and volumes

	local dd_hidden = bitand [DD_gbits | m, GBIT_HIDDEN];
	local dd_hidden_bg = select [
	    select [BTNCOLOR_EQ_ON, BTNCOLOR_EQ_OFF, alltrue dd_hidden],
	    BTNCOLOR_NE,
	    eqL dd_hidden
	];
	dd_hidden = alltrue dd_hidden;

	    // Either the same expression or no expression at all

	local dd_expr = '';
	if eqL (DD_expr | m) then dd_expr = DD_expr(x_max m); endif
#if USE_ATOMQ
	local dfexpr_list = cat [SCHEME_type, ['AtomQ', 'AtomL']];
#else
	local dfexpr_list = cat [SCHEME_type, 'Any'];
#endif
	const DVEXPR_LIST = null [
	    '[#Q]',
	    'C',
	    '[OX1]=C-[OX1]',
	    '[NQ1]-C-[NQ1]'
	];

	local dd_expr_title = '    ';
	k = x_pack m;
	local dd_expr_sens;
	local faccdon_sens = anytrue nF and allfalse nV;	// feat only

	if EXPR_MODE == 3 then			// Always on
	    dd_expr_sens = 1;
	elseif EXPR_MODE == 2 then		// All features or all volumes
	    dd_expr_sens = neL not [nF,nV];
	elseif EXPR_MODE == 1 then		// Same expression
	    dd_expr_sens = eqL DD_expr[k];
	else					// Exactly one object selected
	    dd_expr_sens = length k == 1;
	endif
	local ddexpr_shortcut = cat [dfexpr_list | nF, DVEXPR_LIST | nV];

	if length k == 1 then
	    k = select [k, isub [k, DF_count], nF];
	    dd_expr_title = token swrite ['{}{}{}:',
		select ['', ' ', k > 9],
		select ['F', 'V', nF],
		k
	    ];
	elseif nV and nF then
	    dd_expr_title = 'FV*:';
	else
	    dd_expr_title = select [' F*:', ' V*:', nF];
	endif

	local dd_expr_bubble = bhelp.eD_type |
	    [nF and not nV, not nF and nV, nF and nV];

	    // If required, check distances

	DIST_monitor = nV > 0;
	update_dist [wkey, 1];

	    // Set data and attributes

	WindowSetAttr [wkey, [
	    eD_R_t:		[sensitive: dd_rad_sens],
	    eD_R_w:		[sensitive: dd_rad_sens],
	    eD_type: [
		title:		dd_expr_title,
		sensitive:	dd_expr_sens,
		shortcut:	ddexpr_shortcut
	    ],
	    eD_type_hbox: [
		bubbleHelp:	dd_expr_bubble
	    ],
	    eD_type_app:	[sensitive: dd_expr_sens],
	    eD_essential:	[
		sensitive: dd_ess_sens,
		background: dd_ess_bg
	    ],
	    eD_ignore:		[ background: dd_ignore_bg ],	// !!!
	    eD_hidden:		[ background: dd_hidden_bg ],	// !!!
	    // eD_hidefeat:	[ foreground: dd_hidden_bg ],
	    eD_volumetype:	[
		text: dd_voltext,
		sensitive: dd_voltype_sens
	    ],
	    FV_pager:		[ page: [
		anytrue dd_ess_sens +
		bitshl [anytrue dd_voltype_sens, 1]
	    ] ]
	]];

	WindowSetData [wkey, [
	    eD_R_w:		dd_rad,
	    eD_essential:	dd_ess,
	    eD_volumetype:	dd_voltype,
	    eD_ignore:		dd_ignore,	// !!!
	    button_ignore:	dd_ignore,
	    eD_hidden:		dd_hidden,	// !!!
	    eD_essential:	dd_ess
	]];
	tval_set [wkey, [
	    eD_R_t:		round (10*dd_rad) * 0.1,
	    eD_type:		dd_expr
	]];

	update_sval wkey;
    endif

	//	#hidden #shown	action	ico	anyT	anyF idx=2*anyT+anyF+1
	//	0	0	default	V	0	0	1
	//	0	>0	hide	X	0	1	2
	//	>0	0	show	V	1	0	3
	//	>0	>0	toggle	T	1	1	4

    m = DD_usel or app anytrue DD_sel;
    if allfalse m then m = m_id m; endif
    local h = bitand [DD_gbits | m, GBIT_HIDDEN];
    local eye_idx = 2 * anytrue h + anyfalse h + 1;

    WindowSetAttr [ wkey, [
	eD_hidefeat:	[
	    graphics:	ico_eye(eye_idx),
	    bubbleHelp:	bhelp.eD_hidefeat(eye_idx)
	],
	eD_use_sval_p: [
	    page: (1 + SCHEME_svalOK)
	],
	eD_use_sval_p: [
	    title: select ['S:', '', SCHEME_svalOK],
	    titleFont: 'mediumFixedBold'
	],
	sval_useRec_pager: [
	    page: (1 + SCHEME_svalOK)
	]
    ]];
endfunction


// Reset all DD_xxx to DD_xxx[k]

local function GetSet_DD k
    DD_atom =	DD_atom[k];
    DD_x =	DD_x[k];
    DD_y =	DD_y[k];
    DD_z =	DD_z[k];
    DD_r =	DD_r[k];

    GOpenKey	DD_gkey[k];
    GClose	DD_gkey;
    DD_gkey =	DD_gkey[k];

    local n = length DD_expr;
    ensure_Xxx n;
    DD_sval	= T_get [DD_sval, k];
    DD_rval	= T_get [DD_rval, k];
    DD_mval	= T_get [DD_mval, k];
    DD_svalXxx = DD_svalXxx[k];

    DD_expr =	DD_expr[k];
    DD_color =	DD_color[k];
    DD_ebits =	DD_ebits[k];
    DD_gbits =	DD_gbits[k];

    DD_sel =	DD_sel[k];

    DD_usel =	DD_usel[k];
    DD_umask =	DD_umask[k];
    DD_ufold =	DD_ufold[k];
endfunction


// Reset all DC_xxx to DC_xxx[k]

local function GetSet_DC k
    DC_expr =	DC_expr[k];
    DC_ids =	DC_ids[k];
    DC_ebits =	DC_ebits[k];
#if SHOW_DC_OPTION
    DC_gbits =	DC_gbits[k];
#endif
    DC_sel =	DC_sel[k];
endfunction

static VOL_groupOK, VOL_ungroupOK;

// set sensitivity of buttons that use list selection according to
// the current value of the list selection

local function set_sens_listbuttons wkey
    local df_sel = keep [DD_sel, DF_count];	// feature spheres
    local dv_sel = drop [DD_sel, DF_count];	// volume spheres
    local du_sel = drop [DD_usel, DF_count];	// union headers
    local anysel = anytrue [df_sel, dv_sel, du_sel]; // listbox lines
    local anyDD  = anytrue [DF_count, DV_count];
    local nDDsel = add df_sel + add cat (dv_sel or du_sel);

    local sel = cat [
	[df_sel],			// features
	[DC_sel],			// constraints
	DD_sel | DD_umask,		// unions
	[drop [select [DD_usel, DD_sel, DD_umask], DF_count]] // volumes
    ];

    local noFC = allfalse [df_sel, DC_sel];
    VOL_ungroupOK = noFC and anytrue (DD_usel or DD_sel | DD_umask);
    VOL_groupOK = noFC and add [
	add (DD_sel | not DD_umask),
	add (DD_umask and (DD_usel or app alltrue DD_sel)),
	add cat (DD_sel | DD_umask and not DD_usel and app anyfalse DD_sel)
    ] > 1;

    local a = cat DD_atom | cat orE [DD_sel, DD_usel];
    a = a | oType a == 'atom';
    a = a | not aHidden a;

    // local c = 'black';
    // if VOL_ungroupOK then c= 'red'; endif
    // if VOL_groupOK then c= 'blue'; endif

    local c = '+V';
    if VOL_ungroupOK then c= '-V'; endif
    if VOL_groupOK then c= '+V'; endif

    WindowSetAttr [wkey, [
	button_delete:	[sensitive: anytrue [DD_sel, DD_usel, DC_sel]],
	button_up:	[sensitive: anytrue (app first sel< app dropfirst sel)],
	button_down:	[sensitive: anytrue (app last sel < app droplast sel)],
	eD_hidefeat:	[sensitive: anyDD],
	button_render:	[sensitive: anyDD],
	button_meters:	[sensitive: nDDsel >= 2],
	button_group:	[
	    sensitive:	VOL_groupOK or VOL_ungroupOK,
	    // text:	select ['-V', '+V', VOL_ungroupOK and not VOL_groupOK]
	    text:	c
	],
	constrain:	[sensitive: length df_sel >= 2]
#if 0
	create_C: [sensitive: allfalse [DC_sel, dv_sel, DD_usel | DD_umask]],
#endif
	// meters:	[sensitive: anytrue [DD_sel, DD_usel]],
    ]];
endfunction

local function setattr_quebutton;

// update_listsel updates the selection of the list widget and related widgets
// from the value of DD_sel, DD_usel, and DC_sel

local function update_listsel wkey	// (M1)
    WindowSetData [wkey, [mainlist: x_pack get_listsel[]]];
    set_sens_listbuttons wkey;
    set_edit_page wkey;
    draw_que_features[];	// highlight selected features in main window
    if SCHEME_svalOK then update_sval wkey; endif
    setattr_quebutton wkey;
endfunction

// check_partialmatch:
// Ensure that if Partial Match is enabled, then the number of
// features allows for the chance of success:
//	At Least: nF - nI >= specified number
//	All But: nF - nI - nEss == specified number
// Set bgcolor if no chance of success.  Set shortcut.
// Return errmsg (token) (used for bubbleHelp on ismatch).

local function check_msize [wkey, nfeat]
    if isnull nfeat then
	local n_ignore = add notnot bitand [DD_ebits, EBIT_IGNORED];
	nfeat = DF_count - n_ignore;
    endif

    local bad		= 0;		// OK
    local msize_p2	= 1;		// no label
    local msize_p3	= 1;		// no label


    if 0 then
    elseif ltE [2, DS_matchsize, nfeat] then		// AtLeast OK
    elseif ltE [-nfeat, DS_matchsize, -2] then		// AllBut OK
    elseif nfeat == 0 then				// No features
	msize_p2 = 5;		// "No features"
	msize_p3 = 2;		// "No features"
    elseif DS_matchsize <= -nfeat then			// empty match OK
	msize_p2 = 3;		// "Empty match OK"
	// errmsg = 'Match size must be at least 1.';
	// errmsg = 'Partial match excludes all features.';
    elseif nfeat < 3 then				// Abspos
	msize_p2 = 7;		// "Use abs.positions"
	msize_p3 = 3;		// "Use abs.positions"
    elseif ltE [0, DS_matchsize, 3] then		// Abspos
	msize_p2 = 7;		// "Use abs.positions"
    elseif leE [nfeat-2, -DS_matchsize, nfeat] then	// Abspos
	msize_p2 = 7;		// "Use abs.positions"
    elseif DS_matchsize == 0 then			// full match
	msize_p2 = 2;		// "Full match"
    elseif DS_matchsize == nfeat then			// full match
	msize_p2 = 2;		// "Full match"
    elseif isnan DS_matchsize then			// special: NaN
	msize_p2 = 6;		// "Illegal value"
    elseif DS_matchsize > nfeat then			// err in At Least
	msize_p2 = 4;		// "No match"
    // errmsg = 'Partial match size is greater than the number of features.';
	bad = 1;
    endif
    WindowSetAttr [wkey, [
	msize_p2: [page : msize_p2],
	msize_p3: [page : msize_p3]
    ]];
    tval_type [wkey, [msize: select [-1, 0, bad]]];
endfunction

local function check_partialmatch wkey
    if not DS_matchsize then		// msize=0: full match
	tval_type [wkey, [msize:0]];
	// return '';
    endif

	// Generate the initial list of 100 shortcut values.
	// Note: it is rare to have #features >100, i.e. SLIST is likely
	// to stay unchanged.

    const _SLIST = cat tok_cat [
	['','1','2','3','4','5','6','7','8','9'],
	[['0','1','2','3','4','5','6','7','8','9']]
    ];
    static SLIST, SMAX;
    if isnull SLIST then SLIST = _SLIST; SMAX = dec length _SLIST; endif

    local n_ignore = add notnot bitand [DD_ebits, EBIT_IGNORED];
    local n_ess    = add notnot bitand [DD_ebits, EBIT_ESSENTIAL];

	// DS_matchsize == 0 if partial match disabled.
	// DS_matchsize > 0 if partial match At Least.
	// DS_matchsize < 0 if partial match All But.
	//
	// For success, require: (n = abs DS_matchsize)
	// At Least: # unignored features >= n
	// All But: # unignored features - n > 0

    local nfeat = DF_count - n_ignore;

	// If the query has more features than labels in shortcut list,
	// SLIST, grow SLIST to a sufficient size.

    local slist	= keep [SLIST, inc nfeat];
    if SMAX < nfeat then
	slist	=
	SLIST	= cat [SLIST, totok drop [igen nfeat, SMAX]];
	SMAX	= nfeat;
    endif
    WindowSetAttr [wkey, [msize: [shortcut: slist]]];

    check_msize [wkey, nfeat];

#if 0 // !!! Don't auto-set the count
    if v.msize > DF_count then
	v.msize = DF_count;
	DS_matchsize = msize_3to1[v.msize_nonzero,v.msize_sign,v.msize];
	WindowSetData [wkey, [msize: v.msize]];
    endif
    sync_tval wkey;
#endif
    return '';
endfunction

// check_constraints:
// Ensure that if have non-ignored constraints with # features,
// that there is chance of success.
// Require:
//	for each C in (nC - nCi) | m_nfeatures
//	    nF - nFi satisfies nfeatures constraint

local function check_constraints wkey
    if not DC_count then return ''; endif

    local mc = not bitand [DC_ebits, EBIT_IGNORED]; // non-ignored constraints

	// !!! Heavily dependent on order of CTYPE.

    local dc_expr = DC_expr | mc;	// CTYPE(1) values
    local dc_x = indexof [dc_expr, keep [CTYPE(1), 7]];
    local m_nf = app anytrue dc_x;

    if allfalse m_nf then
#if 0
	WindowSetAttr [wkey, [ismatch: [background: 'background']]];
#endif
	return '';
    endif		// no # of feature constraints

    dc_x = dc_x | m_nf;

    local dc_ids = (DC_ids | mc) | m_nf;	// feat ids
    local ntotf = app length dc_ids;		// # feat in each constraint

    local m = not bitand [DD_ebits, EBIT_IGNORED];	// non-ignored feat
    local nf = app add apt get [[m], dc_ids];	// # non-ignored feat

    const NUM = [1, 2, 3, 4, 5, 1, 2];

    local errmsg = '';
    local m_ok = app eval apt twrite ['{} >= {}', nf, NUM[dc_x]];

    if anyfalse m_ok then
	local c_ids = ((igen DC_count | mc) | m_nf) | not m_ok;
	errmsg = tok_cat [
	    'Constraint', select ['s ', ' ', length c_ids > 1],
	    tok_drop [tok_cat ['C', totok c_ids, ', '], -2],
	    ' cannot be satisfied.'
	];
    endif
    return errmsg;
endfunction

// check_query: set background color and bubbleHelp of ismatch field
//	if an impossible query due to ignored features is detected.
// Note: check only for ignored features.  Don't do simple check,
// e.g. for minimum of 3 features unless absolute positions.

local function check_query wkey
    local pmsg = check_partialmatch wkey;
    local cmsg = check_constraints wkey;

#if USE_ISMATCH
    local is_err = anytrue [pmsg, cmsg];

    const ISMATCH_HELP =
	'The number of annotated chains in MOE\n'
	'that match the current query.'
    ;

    tval_type [wkey, [ismatch: select [-1, 0, is_err]];
    WindowSetAttr [wkey, [ismatch: [
	bubbleHelp: tok_cat [
	    ISMATCH_HELP,
	    select ['\n\nWarning: ', '', anytrue pmsg],
	    pmsg,
	    select ['\n\nWarning: ', '', anytrue cmsg],
	    cmsg
	]
    ]]];

#if 0
    WindowSetAttr [wkey, [config: [
	background: select ['red', 'background', is_err],
	bubbleHelp: tok_cat [
	    'Configuration settings for searching.  This button is also\n'
	    'used to signal problems with the query.  The button turns\n'
	    'red when the number of available features cannot satisfy\n'
	    'the partial match and/or constraint criteria.',
	    select ['\n\nWarning: ', '', anytrue pmsg],
	    pmsg,
	    select ['\n\nWarning: ', '', anytrue cmsg],
	    cmsg
	]
    ]]];
#endif
#endif

    return [pmsg, cmsg];
endfunction

local function make_longlabel []
    local expr = DD_expr;

    local Xxx, Yyy;
    local n = length DD_expr;
    local m = igen n <= DF_count;
    local sval = [];
    ensure_Xxx n;

    for Xxx in SVAL_Xxx loop
	for Yyy in SVAL_XxxYyy.(Xxx) loop
	    sval.(Yyy) = maxE [0, mput [DD_sval.(Xxx), not m, 0]];
	endloop
    endloop

    local sval_onlyF = tag [tags sval, tagvals sval || [m]];
    expr | m = ph4_ExprAddSval [expr | m, sval_onlyF];
    return expr;
endfunction

// set_mainlist_text resets the contents of the list 'mainlist' using
// DD_expr, DC_expr (and other DD/DC data).  We preserve the selection
// status of items that are present both in the old list and the new list.

local function set_mainlist_text wkey

    if allfalse [DF_count, DC_count, DV_count] then
	WindowSetAttr [wkey, [mainlist: [header: '', text: []]]];
	return;
    endif

	// Generate text for all features and (top level) volumes

    local usize = app length DD_sel;
    local dd_unfold = dec usize and not DD_ufold;

    // local dd_sgn = "  +"[iadd [1, DD_umask, DD_ufold]];
    local dd_sgn = select ['+', ' ', DD_umask and DD_ufold];

    local dd_ID = app token cat [
	apt swrite ['F{} ', igen DF_count],
	apt swrite ['V{} ', igen DV_count]
    ];
    local dc_ID = app token apt swrite ['C{} ', igen DC_count];
    local dx_IDlen = max [0, max tok_length cat [dd_ID, dc_ID]];

    local m_i = bitand [DD_ebits, EBIT_IGNORED];
    local m_h = bitand [DD_gbits, GBIT_HIDDEN];
    local dd_bits = '';
    dd_bits | m_i = 'i ';
    dd_bits | m_h = 'h ';
    dd_bits | m_i and m_h = 'ih ';
    local dc_bits = '';
    dc_bits | bitand [DC_ebits, EBIT_IGNORED] = 'i ';
    local dd_bitslen =
	max [0, max tok_length dd_bits, max tok_length dc_bits];


    local dd_tag = '';
    dd_tag | bitand [DD_ebits, EBIT_ESSENTIAL] = 'Ess   '; // ess. features
    dd_tag | x_id dd_tag > DF_count = 'Excl  ';	// excluded interior
    dd_tag | bitand [DD_ebits, V_EBIT_ALL] = 'Shape ';	// excluded exterior
    dd_tag | bitand [DD_ebits, V_EBIT_ANY] = 'Occ   ';	// included interior
    local dd_taglen = max [0, max tok_length dd_tag];

    if USE_LISTHEADER then
	local hd_prop = select ['Prop  ', '', dd_taglen];
	if not dd_bitslen then
	    dd_taglen = max [dd_taglen, tok_length hd_prop];
	endif
    endif

    // local dd_expr = select [DD_expr, '<Heavy Atoms>', tok_length DD_expr];

    local fmt = tok_cat [
	'{}',
	token swrite ['{{-{}}', dx_IDlen],
	token swrite ['{{-{}}', dd_bitslen],
	token swrite ['{{-{}}', dd_taglen],
	'{}'
    ];
    local list_expr = make_longlabel [];
    local dd_text = apt swrite [fmt, dd_sgn, dd_ID, dd_bits, dd_tag, list_expr];

	// Generate text for constraints

    local dc_expr = CTYPE(2)[maxE [1, indexof [DC_expr, CTYPE(1)]]];
    local dc_text = apt swrite [
	tok_cat [fmt, '{-15} F[{|,}]'],
	' ', dc_ID, dc_bits, '', '', dc_expr, DC_ids
    ];

	// Generate header

    local dx_header = '';
    if USE_LISTHEADER then
	fmt = tok_cat [
	    ' ',
	    token swrite ['{{-{}}', dx_IDlen],
	    token swrite ['{{{}}', iadd [max [0, dec dd_bitslen], dd_taglen]],
	    select [' ', '', dd_bitslen],
	    select ['{-15} Set', '{}', DC_count]
	];
	dx_header = token swrite [fmt, 'ID', hd_prop, 'Expression'];
    endif

	// Generate text for all unfolded unions of volumes
	// and merge it with the top-level text

    local usize2 = usize | dd_unfold;

    local width = iadd [dx_IDlen, dd_bitslen, dd_taglen];
    fmt = token swrite [' :{{+{}}{{}{{}', dec width];
    dd_text = app nest dd_text;
    dd_text | dd_unfold = apt cat [
	dd_text | dd_unfold,
	split [apt swrite [fmt, ' ', 'Sphere ', cat app igen usize2], usize2]
    ];

	// Merge Features&Volumes text with Constraints text and display it

    local dx_text = app token cat [
	cat keep [dd_text, DF_count],
	dc_text,
	cat drop [dd_text, DF_count]
    ];

    WindowSetAttr [wkey, [mainlist: [
	header: dx_header,
	text: dx_text
    ]]];
endfunction

function ph4_ExprAtypes, ph4_ExprSvalControls;

// update_sval updates the bottom "S:" line for EHT features that use
// "Acc" or "Don".
// !!! HACK

local function update_sval wkey
    local m;
    if not SCHEME_svalOK then
	WindowSetAttr [wkey, [eD_use_sval_p: [page: 1]]];
	return;
    endif

    m = DD_usel or app anytrue DD_sel;	// selected items

	// EHB widgets work only on a single feature that contains Acc or Don.
	// Otherwise, don't show the "S:" line.
	// If there are only Acc labels, force Xxx='Acc'.  Similarly for Don.

    local svalOK = 0;
// !!!
local sLabel = '';
    if add m == 1 then
	m | x_id m > DF_count = 0;		// affect features only
	if add m == 1 then
	    local svalCtrl = ph4_ExprSvalControls [DD_expr | m, SVAL_XxxYyy];
	    svalOK = not isnull svalCtrl;		// must be 0 or 1!
	    if (DD_svalXxx|m) == '' then svalCtrl = first svalCtrl; endif
	    if isscalar svalCtrl then sLabel = DD_svalXxx | m = svalCtrl; endif
	endif
    endif

    WindowSetAttr [wkey, [eD_use_sval_p: [sensitive: svalOK]]];

    if not svalOK then return; endif

	// Set the widgets of the "S:" line.

    local Xxx = DD_svalXxx | m;
    if neL [1, m_join [Xxx, SVAL_Xxx]] then E_BUG[]; endif

#if 1
    WindowSetAttr [wkey, [
	eD_svalType_p:		[page: 1 + anytrue sLabel],
	eD_svalType_label:	[text: sLabel],
	eD_svalType:		[value: Xxx]
    ]];
#else
    WindowSetData [wkey, [eD_svalType: Xxx]];	// Acc/Don option
#endif

    WindowSetAttr [wkey, [eD_rval: tag [
	'shortcut',
	select [[SVAL_ACC_SHORTCUT], [SVAL_DON_SHORTCUT], Xxx == 'Acc']
    ]]];

    local sval = DD_sval.(Xxx) | m;
    local rval = DD_rval.(Xxx) | m;
    local mval = DD_mval.(Xxx) | m;

    if anyfalse app isflatnum [sval, rval, mval] then E_BUG[]; endif

    tval_set [wkey, [
	eD_sval: f100 avg sval,
	eD_rval: f100 avg rval,
	eD_mval: f100 avg mval
    ]];
endfunction

// !!!
local function setattr_quebutton;

// setall_from_DDnDC updates the list contents and selection and selection state
// of DD dummy atoms from DD_* and DC_* data.

local function setall_from_DDnDC wkey
    ensure_que_dummies 2;		// ensure DD_atom are all valid
    aSetSelected [cat DD_atom, cat DD_sel]; // select dummies
    local m = DD_umask and not DD_sel and not DD_usel;
    aSetHidden [DD_atom, m];
    set_mainlist_text wkey;		// DD/DC --> list items
    update_listsel wkey;		// update list widget from DD/DC
    // !!! called by update_listsel:
    // draw_que_features[];
    // setattr_quebutton wkey;

    QUE_changed = 1;
    QUE_qdataOK = 0;
    update_ph4title wkey;
    MATCH_update = 1;
    if WIN_SEARCH_key then update_search_window WIN_SEARCH_key; endif // !!!
endfunction


// Change the order of selected items in the list.  The item
// (feature/constraint/volume) keeps its expression, selection state,
// atom handle etc, but its rank relative to other items changes.
// E.g. moving item "F3:Don|Acc" (highlighted on the 3rd line) up will
// cause its atom to be relabeled "F2:Don|Acc" and the item be moved
// on the 2nd line and highlighted.

local function move_up_down [wkey, go_up]
    local step = select [-1, 1, go_up];
    local m, m_src, m_dst, k, mtop, s;

	// Move features and volumes

    m_src = select [DD_usel, DD_sel, DD_umask];
    if anytrue m_src then
	m_dst = split [m_src, [DF_count, DV_count]];
	s = sgn [app anyfalse apt keep [m_dst, -step], step];
	m_dst = cat apt rot [m_dst, s];
	k = unpack [x_pack m_src, x_pack not m_src, m_dst];
	GetSet_DD k;
	if anytrue DC_ids then
	    DC_ids = split [indexof [cat DC_ids,k], app length DC_ids];
	    DC_ids = app sort DC_ids;
	endif
    endif

	// Move spheres within unions

    m_src = DD_sel | DD_umask;
    if anytrue m_src then
	s = sgn [app anyfalse apt keep [m_src, -step], step];
	m_dst = apt rot [m_src, s];
	m_dst = apt rot [m_src, select [0, step, apt keep [m_src, -step]]];
	k = apt unpack [app x_pack m_src, app x_pack not m_src, m_dst];
	DD_sel | DD_umask = apt get [DD_sel | DD_umask, k];
	DD_atom | DD_umask = apt get [DD_atom | DD_umask, k];
	DD_x | DD_umask = apt get [DD_x | DD_umask, k];
	DD_y | DD_umask = apt get [DD_y | DD_umask, k];
	DD_z | DD_umask = apt get [DD_z | DD_umask, k];
	DD_r | DD_umask = apt get [DD_r | DD_umask, k];
    endif

	// Move constraints

    m_src = DC_sel;
    if anytrue m_src then
	s = sgn [anyfalse keep [m_src, -step], step];
	m_dst = rot [m_src, s];
	k = unpack [x_pack m_src, x_pack not m_src, m_dst];
	GetSet_DC k;
    endif

    setall_from_DDnDC wkey;
endfunction


#if CALC_MATCH
// Evaluate the query against the currently loaded molecule(s)

local function update_match [wkey, ph4data]
    static match_disabled;

    local state = SystemNonviewState[];
    if length LIG_atom <= 2*LIG_nrec then
#if SHOW_MATCH_IMPLICIT
	tval_set [wkey, [ismatch: '']];
	tval_type [wkey, [ismatch:0]];
#endif
	match_disabled = 0;
	return;
    endif

// !!! Note: in the future, a 2D sval (emd/ema) will be suplemented by
// a 3D component, which might change the protocol from:
//	cimap = get_cimap(2D mol)
//	find 2D match;  if not found, get next molecule
//	for each conformation loop
//	    loop
//		find 3D match; if not found, get next conformation
//		check constraints; if ok, keep the match
//	    endloop
//	endloop
// to:
//	cimap2 = get_cimap2D(2D mol)
//	find 2D match;  if not found, get next molecule
//	for each conformation loop
//	    cimap = cimap2
//	    find 3D match with cimap2; if not found, get next conformation
//	    cimap3 = get_cimap3D(conformation)
//	    (if possible record dmatch state and restart from that state)
//	    loop
//		find 3D match with cimap3; if not found, get next conformation
//		check constraints; if ok, keep the match
//	    endloop
//	endloop

    if anytrue match_disabled then
	local n = app length [ph4data.F.expr, ph4data.C.expr, ph4data.V.expr];
	if  anytrue n then return; endif
	match_disabled = 0;
    endif

    local [res, code] = task_wfork[errmsg:'ignore'];
    if code == 'child' then
	task_prio 0;		// !!!
	if SystemNonviewState [] <> state then task_return 0; endif
	local qkey = ph4_QueryMatch_Open [ph4data, [timeout:0.2]];
	local k, r = [];
	for k = 1, min [length LIG_atom - 2*LIG_nrec, 15] loop
	    local a = LIG_atom(2*LIG_nrec + k);
	    ph4_QueryMatch_SetMol [qkey, a];
	    r(k) = ph4_QueryMatch_3D [qkey, [aPos a]];
	endloop
	ph4_QueryMatch_Close qkey;
	task_return r;
	exit[];		// safety (not needed)
    elseif code == 'error' then
	match_disabled = 1;
	Warning token swrite [
	    'Query evaluation error:\n\n'
	    '{}\n\n'
	    'Query evaluation disabled.\n'
	    'Clear query or turn off ligand\n'
	    'annotation to re-enable.',
	    res
	];
	res = 0;
    endif
    // !!! apps/ph4_annot,ph4_query tutorial/ph4_tut

#if USE_ISMATCH
    local text = swrite [' {}', iadd res];
    if length text > 2 then text = dropfirst text; endif // drop " " if 2-digit
    WindowSetData [wkey, [ismatch: TVAL.ismatch = token text]];
#endif

    // const COLOR = ['baseRed', 'purple', 'baseBlue', 'baseGreen'];
    res = iadd res * invz length res;
    local cidx = iadd [1,  res > 0, res >= 0.5, res == 1];

#if USE_ISMATCH
#if SHOW_MATCH_IMPLICIT
    WindowSetData [wkey, [ismatch: TVAL.ismatch = token text]];
    // tval_set [wkey, [ismatch: token text]];
    sync_tval wkey;
#endif
#endif
endfunction
#endif


// setattr_ligrec adjusts the visual aspect of the annotation widgets
// according to the annotation state (i.e. annotated set non empty,
// annotation requested, annotation text requested, all receptor surface
// atoms requested).
//
// Color scheme:
// insensitive	-> bg='gray'
// none		-> bg=DarkRed, fg=White
// point	-> bg=allrec?DarkGreen:LightGreen, fg=Gray
// point+text	-> bg=allrec?DarkGreen:LightGreen, fg=allrec?LightGreen:Black

local function setattr_ligrec wkey	// see RSL
    local A = [];

    A.lig.sensitive = LIG_haslig;
    A.sol.sensitive = LIG_hassol;
    A.rec.sensitive = LIG_hasrec;

#if USE_DARKGREEN
    const BG_COLOR = ['none', 'yellow', '0x22bb66', '0x228866'];
    const FG_COLOR = ['none', 'black', 'black', 'white'];
#else
    const BG_COLOR = ['none','yellow','green'];
#endif

    local hasRSL = [LIG_hasrec, LIG_hassol, LIG_haslig];
    local cidx = inc (hasRSL * LIG_rsl);
    A.rec.background = BG_COLOR[cidx(1)];
    A.rec.foreground = FG_COLOR[cidx(1)];
    A.sol.background = BG_COLOR[cidx(2)];
    A.sol.foreground = FG_COLOR[cidx(2)];
    A.lig.background = BG_COLOR[cidx(3)];
    A.lig.foreground = FG_COLOR[cidx(3)];
    // A.rec.text = select ['all', ' ', LIG_allrec * LIG_hasrec * LIG_rsl(1)];

    WindowSetAttr [wkey, A];
endfunction

local function setattr_quebutton wkey	// see RSL
    local A = [];

    local useQ = anytrue DD_expr;
    A.que.sensitive = useQ;

#if USE_DARKGREEN
    const BG_COLOR = ['none', 'yellow', '0x22bb66', '0x228866'];
    const FG_COLOR = ['none', 'black', 'black', 'white'];
#else
    const BG_COLOR = ['none','yellow','green'];
#endif

    local cidx = inc (useQ * QUE_textmode);
    A.que.background = BG_COLOR(cidx);
    A.que.foreground = FG_COLOR(cidx);

    WindowSetAttr [wkey, A];
endfunction

static LAST_msize;

// monitor is the timout callback for WindowWait timeout of the main event
// loop.  Its state is maintained in the dvar opt.  The return value
// determines the delay to the next timeout callback.

local function monitor [wkey, opt]
    const CT_MAX	= 0.5;		// Slowest allowed tick rate
    const CT_CREEP	= 0.005;	// Decrease in tick rate

    local ct, tm_check, tm_slow;

	// Initialize or extract the CB state variables.
	// In each call we increase the delay to the next call, ct.
	// If there is change, the delay gets decreased to a minimal
	// value (depending on the type of change.)

    if isnull *opt then
	ct = 0.3;
	tm_check = tm_slow = clock[];
    else
	[ct, tm_check, tm_slow] = *opt;
	*opt = [];
	ct = min [ct + CT_CREEP, CT_MAX];
	// ct = min [ct + 0.5, 5];
    endif

	// If there is a change in the molecules, expire all update timers.
	// (If ph4 search is in progres, delay the update.)

    static LAST_nonview;
    if neL [LAST_nonview, LAST_nonview = SystemNonviewState[]] then
	tm_check = tm_slow = clock[] - 0.001;
	update_lig_annotation 0;	// check for topology changes
	static last_ligrec;
	if neL [last_ligrec, last_ligrec = [LIG_haslig, LIG_hasrec]] then
	    setattr_ligrec wkey;
	endif
	ct = min [ct, select [1.0, 0.1, dvar_key '__ph4_dbsearch_running']];
    endif

    local tm = clock[];

	// Ensure that dummies reflect values DD_xxx.  Always ensure
	// valid handles in DD_atom.  Non-critical properties (color,
	// type, etc.) are verified only at lower frequency (fast_update=0).

    if tm < tm_check then
	ensure_que_dummies 0;		// ensure DD_atom handles valid

    else
	tm_check = tm + CT_MAX;
	ensure_que_dummies 1;		// ensure DD_atom properties
    endif

	// Update dummy atom positions.

    if not eqL [app cat [DD_x,DD_y,DD_z], aPos cat DD_atom] then
	if DBG then event 'que_pos'; endif

	local dd_atom_seg = app length DD_atom;
	[DD_x, DD_y, DD_z] = apt split [aPos cat DD_atom, [dd_atom_seg]];
	QUE_changed = 1;
	QUE_qdataOK = 0;
	update_ph4title wkey;
	MATCH_update = 1;
	draw_que_features[];	// move features to new positions
	if DIST_monitor then update_dist wkey; endif
	usnap 'pos';

	ct = min [ct, 0.05];
    endif

	// Update displayed text positions according to view orientation

    local curr_vo = ViewOrientation[];
    if neL [curr_vo, GOBJ_QUE_ViewOrientation] then
	ct = min [ct, 0.2];
	if DBG then event 'que_view'; endif
	// [DD_x, DD_y, DD_z] = aPos DD_atom;
	draw_que_features[];	// update positions of labels
				// (sets GOBJ_QUE_ViewOrientation)

	    // Update (reposition) ligand annotation text

	if isnull DL_expr then					    // no pts
	elseif eqL [curr_vo, GOBJ_LIG_ViewOrientation] then	    // no change
#if USE_DARKGREEN
	elseif max LIG_rsl >= 2 then
#else
	elseif max LIG_rsl == 2 then
#endif
	    if DBG then event 'lig_view'; endif
	    ensure_lig_dummies 0;	// update aPos with DL_x/y/z
	    draw_lig_text[];		// sets GOBJ_LIG_ViewOrientation
	endif
    endif

	// If the selection of dummy residues changed, update the
	// update the list selection and the atom selection.
	// (If the list selection changes, the update of the
	// atom selection and the residue selection is done in
	// the event loop.)

// !!! draw que text in front of annotation text!
// !!! multi-line GText

    local a, new_sel;

	// Select dummies at the centers of query features whenever there
	// is an atom selected in nearby.

#if USE_DL_SEL
    local dl_flag = neL [DL_sel, aSelected DL_atom];
    local dd_flag = neL [DD_sel, aSelected DD_atom];

    if dl_flag or dd_flag then
	ct = min [ct, 0.1];

	a = cat cat [DL_atom, DD_atom];
	local pos0 = aPos (a | aSelected a);

	local prox = prox_open [GROUP_RAD, pos0, GROUP_RAD];
	local [seg, idx] = prox_find [prox, aPos a, 0];
	prox_close prox;

	aSetSelected [a, seg > 0];
	DL_sel = aSelected DL_atom;
	// DD_sel = aSelected DD_atom;
    endif
#endif

    a = cat DD_atom;
    if not eqL [cat DD_sel, aSelected a] then
	ct = min [ct, 0.1];
	if DBG then event 'que_sel'; endif
	local last_sel = DD_sel;

	    // Update DD_ and residue selection from atom selection

	local dd_sel_seg = app length DD_sel;
	DD_sel = cat DD_sel;
	local m = DD_sel <> aSelected a;
	DD_sel | m = not (DD_sel | m);
	DD_sel = split [DD_sel, dd_sel_seg];
	m = app anytrue (DD_sel < last_sel);
	DD_usel | DD_umask and m = 0;
	m = app alltrue DD_sel and app anytrue (DD_sel > last_sel);
	DD_usel | DD_umask and m = 1;

	    // Update list selection from DD_ selection

	update_listsel wkey;
	usnap 'sel';
    endif

#if 0	// extend selection to the ann.point of the same group
    a = cat (DL_atom || DL_group);
    new_sel = aSelected a;
    if neL [DL_gsel, new_sel] then
	ct = min [ct, 0.1];
	if isnull DL_gsel then DL_gsel = zero new_sel; endif

	    // Sort atoms by their group number.

	local [k, c] = sac pack cat DL_group;
	last_sel = DL_gsel[k];
	new_sel = new_sel[k];

	    // If an atom became selected or stayed selected,
	    // select all atoms in the same group.

	new_sel | stretch [s_add [new_sel >= last_sel, c], c] = 1;
	new_sel = perm [new_sel, k];

	aSetSelected [a, DL_gsel = new_sel];
    endif
#endif

	// Once a while, update match etc.

    if tm > tm_slow then
	tm_slow = tm + 1.0;
	ct = min [ct, 1.0];
	if DIST_monitor then update_dist wkey; endif

	local v = WindowGetData [wkey, [
	    'msize', 'msize_nonzero', 'msize_sign',
	    'que_title',
	    'eD_sval', 'eD_rval', 'eD_mval', 'eD_R_t', 'eD_type'
	]];

	    // Sync DS_matchsize to the current value of the text widget.

	if not leL [0, v.msize, DF_count] then
	    v.msize	= select [0, DF_count, v.msize < 0];
	    WindowSetData [wkey, [msize: v.msize]];
	    LAST_msize	= [];		// force msize_3to1
	endif

	if neL [LAST_msize, LAST_msize = v.msize] then
	    DS_matchsize = msize_3to1 [v.msize_nonzero, v.msize_sign, v.msize];
	    tval_set [wkey, [msize: v.msize]];
	    check_partialmatch wkey;
	    // tval_type [wkey, [msize: select [-1, 0, v.msize < 0]]];
	endif

	    // Sync DS_title to the current value of the text widget.
	    // Propagate to other windows.

	if neL [DS_title, DS_title = v.que_title] then
	    QUE_qdataOK = 0;
	    if WIN_SEARCH_key then update_search_window WIN_SEARCH_key; endif
	endif

	    // If there are no selected features, check volumes.

	static last_eD_type;

	if neL [last_eD_type, last_eD_type = v.eD_type] then
	    local c, errmsg = '';
	    if allfalse keep [DD_sel, DF_count] then
		c = ph4_ExprCleanupV last_eD_type;
		if anytrue c then
		    errmsg = ph4_ExprCheckSyntaxV c;
		endif

		// If there are no selected volumes, check features.

	    elseif allfalse [drop [DD_sel, DF_count], DD_usel] then
		c = ph4_ExprCleanupF [last_eD_type, SCHEME_type];
		if anytrue c then
		    errmsg = ph4_ExprCheckSyntaxF [c,SCHEME_type,SCHEME_tcode];
		endif
	    endif

	    tval_type [wkey, [eD_type: select [-1, 0, anytrue errmsg]]];
	endif

	tval_sync wkey;

#if CALC_MATCH
	if MATCH_update then
	    MATCH_update = 0;
	    update_match [wkey, qdata_Get[]];
	endif
#endif
    endif

    *opt = [ct, tm_check, tm_slow];
    return ct;
endfunction

// Clear list selection (without updating the widgets)

local function clear_listsel []
    DD_sel = zero DD_sel;		// clear sphere selection
    DD_usel = zero DD_usel;		// clear union header selection
    DC_sel = zero DC_sel;		// clear constraint selection
endfunction


// dominant_spheres returns modified radii of given spheres, so that
// the radii of buried or almost-buried spheres are set to 0 and
// the radii of dominant spheres are increased to cover the almost-buried
// spheres underneath.

local function dominant_spheres [pos, rad]

// !!! ? is this a good idea?
// const MINRAD = 2.4;	// miniumum radius of a cluster
const MINRAD = 0;	// miniumum radius of a cluster

	// Ensure a minimum radius of groups of intersecting spheres.
	// Remove spheres inside other spheres.

    local pkey = prox_open [2*max rad, pos, rad];
    local [seg, idx, r] = prox_find [pkey, pos, rad];
    prox_close[];
    local i1 = stretch [x_id rad, seg];		// index of the q.sphere
    r = sqrt r;					// dist.to intersecting spheres
    local d = r + rad[idx];			// covering radius (per nbr)
    local eps =  s_max [d, seg] < MINRAD;	// clusters too smal
    eps | eps = MINRAD - rad|eps;		// rad.deficit to MINRAD
    local rrank = rank neg rad;		// unique rank by rad.(largest first)

#   if DBG_DOMINANT_SPH_VERB
	write '\n\n';
	// PR [removed_spheres: x_pack not mOK];
	PR [rad_deficit: eps | eps > 0];
	PR 'clusters:';
	local x1 = (rad+eps)[i1];
	local x2 = rad[idx];
	local m1 = x1+0.2 > r+x2;
	local r_i1 = rrank[i1];
	local r_idx = rrank[idx];
	local m2 = r_i1 < r_idx;
	local m3 = m1 and m2;
	write ['{12}\n', [
	    'i1', 'idx', 'rad[i1]+eps', 'r', 'rad[idx]', 'r_i1>r+r_idx',
	    'rrank[i1]', 'rrank[idx]', 'rr_i1 < rr_idx', 'i1 / idx']];
	matpr tr [i1, idx, x1, r, x2, m1, r_i1, r_idx, m2, m3];
#   endif

	// Here we assume that graph E=[idx|m, i1|M] with edges from covered
	// spheres to their covering spheres is a dag (directed acyclic graph).

    local m = (rad+eps)[i1] + 0.2 > r + rad[idx] and rrank[i1] < rrank[idx];
    local mOK = put [m_id rad, idx|m, 0];
    // rad = (rad+eps+0.1) | mOK;
    // pos = pos || [mOK];

#   if DBG_DOMINANT_SPH_VERB
	local n1 = length mOK;
	local n2 = add mOK;
	PR [covering_pairs: x_pack m];
	PR [covered_spheres: x_pack not mOK];
	write ['Buried: rm\'d: {} / {} (n1={}, n2={})\n', n1 - n2, n1, n1, n2];
#   endif

	// DEBUGGING: verify that E is a dag:
	// 1) create a dir.graph E = {(i,j) | sphere i is covered by sphere j}
	// 2) M = adjacency matrix of E (assymetric)
	// 3) calc. connectivity mtx B = B x M + M (iterate n times)
	// 4) verify that there are no cycles, i.e. trace B = 0

#   if DBG_DOMINANT_SPH_DAG
	if anytrue m then
	    local E = [idx, i1] || [m];		// idx:covered, i1: covering
	    local M = graph_adjacency graph_neighbors E, B = M;
	    for length M loop B = matmul [B, M] or M; endloop
	    if anytrue matdiag B then E_BUG[]; endif
	endif
#   endif

    return mput [rad+eps+0.1, not mOK, 0];
endfunction

// Create a new dummy atom.  Set the position to the centroid
// of selected atoms and reset the selection.
//
// sel_atoms: The atoms from which to create a feature; the feature
//	will be created at the centroid of the selected atoms.
// clearsel: flag indicating whether to clear the list selection
//	<>0: clear listsel; ==0, do not clear.

local function _create_feature [wkey, sel_atoms, clearsel]

#if 1
	// Add DL/DD dummies that share the location with the selected
	// atoms to the selection.

    local a0 = sel_atoms, a1, seg;
    local EPS = 0.01;
    local pkey = prox_open [EPS, aPos a0, EPS];

    a1 = diff [cat DD_atom, sel_atoms];	// unselected DD's
    [seg] = prox_find [pkey, aPos a1, 0];
    sel_atoms = cat [sel_atoms, a1 | seg];

    a1 = diff [cat DL_atom, sel_atoms];	// unselected DL's
    [seg] = prox_find [pkey, aPos a1, 0];
    sel_atoms = cat [sel_atoms, a1 | seg];

    prox_close pkey;
#endif
    local pos = oCentroid sel_atoms;
    aSetSelected [sel_atoms, 0];
    if isnull sel_atoms then pos = ViewLookAt[]; endif

    if clearsel then clear_listsel[]; endif

	// Set default label and color

    local expr, color, rad;
    local lig_m = m_join [cat DL_atom, sel_atoms];
    local que_m = x_id DD_expr <= DF_count;
    que_m | que_m = m_join [DD_atom | que_m, sel_atoms];

	// If no annotation points or query features are selected, use
	// the default values.

    if allfalse [lig_m, que_m] then
#if USE_ATOMQ
	expr = 'AtomQ';
#else
	expr = 'Any';
#endif
	color = DF_DEFCOLOR;
	rad = 1.0;

	// If query features are selected, use one of their labels,
	// maximum radius and either a common color or the default color.

    elseif anytrue que_m then
	    [expr, rad, color] = [DD_expr, DD_r, DD_color] || [que_m];

	    expr = sortuniq expr;
	    if not isscalar expr then expr = expr(x_max tok_length expr); endif
	    rad = max rad;
	    color = uniq color;
	    if not isscalar color then color = DF_DEFCOLOR; endif

	// If some annotation points and no query features are selected,
	// construct new type expression from using the bits of the
	// the selected annotation points.

    else
	local bits = cat DL_bits | lig_m;	// sel.bits
	local last_recidx = add keep [app length DL_atom, 2*LIG_nrec];
	local m_isrec = x_pack lig_m <= last_recidx;

	    // If only ligand ann.pts are selected and there are properties
	    // common to all pts, use only those properties.  Otherwise,
	    // keep all bitmasks.

	if allfalse m_isrec then
	    if bitand bits then bits = bitand bits; endif
	    bits = uniq bits;

	    // If there are receptor ann.pts selected, treat each
	    // rec.property (bit) as if it were on a separate ann.pt.

	else
	    local rbits = bits | m_isrec;	// receptor bits
	    rbits = bitor rbits;
	    rbits = pack bitand [rbits, bitshl [1, dec igen bitmsbpos rbits]];
	    bits = uniq cat [bits | not m_isrec, rbits];
	endif

	if not isscalar bits then
	    local bits1 = sort (bits | bitcount bits == 1);
	    local bits2 = bits | bitcount bits > 1;
	    bits2 = sort (bits2 | not bitand [bits2, bitor bits1]);
	    bits2 = bits2[x_sort bitcount bits2];
	    bits = cat [bits1, bits2];
	endif

	bits = uniq ph4_SchemeNewFeatureBits [SCHEME_name, bits];
	expr = ph4_SchemeBitsExpr [SCHEME_name, bits];
	expr = twrite ['{||}', expr];
	rad = max ph4_SchemeBitsRad [SCHEME_name, bits];
	color = uniq ph4_SchemeBitsColor [SCHEME_name, bits];
	if not isscalar color then color = DF_DEFCOLOR; endif
    endif

    local k = inc length DD_expr;
    DD_atom(k) = 0;
    DD_gkey(k) = GOpenQueN 1;
    DD_expr(k) = expr;

	// Extract the rval from the receptor:
	// 1) Find selected DL_atoms that belong to the receptor
	// 2) (later: otherwise, find some that are unselected but closeby)
	// 3) Extract the largets rval from those atoms.
	// 4) If the extracted rval combined with the default mval would
	//    not allow a match of the current LIG_svalMin, lower mval
	//    so that it does.

    ensure_Xxx dec k;
    DD_svalXxx(k) = expr2xxx expr;
    if not SCHEME_svalOK then
	DD_sval = DD_rval = DD_mval = [];
    else
	local Xxx, i;
	for Xxx in SVAL_Xxx loop
	    local rval = -1;
	    for i = 1, LIG_nrec loop
		local m = m_join [DL_atom(i), sel_atoms];
		if allfalse m then continue; endif
		rval = max [rval, max (DL_sval(i).(Xxx) | m)];
	    endloop
	    if rval < 0 then rval = RVAL_default.(Xxx); endif
	    local sval = f100 LIG_svalMin.(Xxx);
	    local mval = f100 MVAL_default.(Xxx);
	    if rval * sval < mval then mval = f100 (rval * sval); endif

	    DD_sval.(Xxx) = append [DD_sval.(Xxx), sval];
	    DD_rval.(Xxx) = append [DD_rval.(Xxx), rval];
	    // DD_rval.(Xxx) = append [DD_rval.(Xxx), RVAL_default.(Xxx)];
	    DD_mval.(Xxx) = append [DD_mval.(Xxx), mval];
	endloop
    endif

    DD_expr(k) = expr;
    DD_x(k) = pos(1);
    DD_y(k) = pos(2);
    DD_z(k) = pos(3);
    DD_r(k) = rad;
    DD_color(k) = color;
    DD_ebits(k) = 0;		// 1=essential
    // DD_gbits(k) = GOBJ_DEFDENSITY;	// low density, line, long offset text
    DD_gbits(k) = RTYPE_GBITS(DF_DEF_RTYPE);
    DD_sel(k) = 1;
    DD_usel(k) = 0;
    DD_ufold(k) = 0;
    DD_umask(k) = 0;
    GetSet_DD cat [igen DF_count, rotr drop [x_id DD_x, DF_count]];
    DF_count = inc DF_count;

    ensure_que_dummies 0;		// ensure DD_atom handles valid
    aSetSelected [DD_atom(DF_count), 1];

	// Update windows widgets (list & buttons) and 3D query rendering
	// If the Query Rendering window is open, update the
	// set of diplayed parameters for the "Selected" items.

    setall_from_DDnDC wkey;
endfunction

// !!! USE_NEW_LAYOUT
local function create_feature [wkey, at_centroid]
    local sel_atoms = SelectedAtoms[];
    if at_centroid then
	_create_feature [wkey, sel_atoms, 1];
	return [];
    endif

    if isnull sel_atoms then
	_create_feature [wkey, [], 1];
	return [];
    endif

    local pos = aPos sel_atoms;

	// Collect the ann.pts., atoms, and features that
	// are in close proximity (overlaid), and create a
	// single feature at their centroids.

#if 0
    local EPS = 0.01;
#else
    local EPS = 0.5;
#endif
// cluster
    local pkey = prox_open [EPS, pos, EPS];
    local [seg, idx, r2] = prox_find [pkey, pos, 0];
    prox_close pkey;
// PR [sel_atoms: sel_atoms];
// PR [seg: seg, r:sqrt r2];
// PR [idx: split [idx, seg]];

	// atom_x is segmented vector of indices into sel_atoms, with
	// each segment storing indices of (very) nearby atoms.

    local atom_x = uniq app sort split [idx, seg];

   

	// Create a feature at the centroid of each cluster
	// of ann. pts.  In the list, select all newly created features,
	// i.e. the last length atom_x features (i.e. in the list,
	// starting from DF_count - length atom_x to DF_count).

    local atoms;
    local isfirst = 1;
    sel_atoms = apt get [[sel_atoms], atom_x];
    for atoms in sel_atoms loop
	_create_feature [wkey, atoms, isfirst];
	isfirst = 0;
    endloop

#if 1
	// If exactly 2 features and one is the projection of the other,
	// then automatically create a shared-atom constraint.
	// !!! Current implementation is very simplistic: looks merely
	// for the presence of annotation points inside the features
	// that are a head and tail pair.

    if length atom_x == 2 then

	    // Search for a head/tail atom in each of the sel_atom
	    // clusters.

	local i;
	for i = 1, length DL_atom loop	// look through each molecule
#if 1
	    local x_sel = apt indexof [sel_atoms, [DL_atom(i)]];

		// x_sel is a 2-vector in which each element is a list
		// of indices into DL_atom(i).  Compare these indices
		// against the head and tail indices.
		// N.B. Directional, check both head-tail and tail-head.

	    if andE app anytrue apt m_join [x_sel, [DL_head(i), DL_tail(i)]] then
		break;
	    endif
	    if andE app anytrue apt m_join [x_sel, [DL_tail(i), DL_head(i)]] then
		break;
	    endif
#else

// !!! better concept, but non-yet working
	    local m1 = m_join [DL_atom(i), sel_atoms(1)];
	    local m2 = m_join [DL_atom(i), sel_atoms(2)];
	    local m  = m1[DL_head(i)] and m2[DL_tail(i)];

	    if anytrue m then break; endif
#endif
	endloop

	if i > length DL_atom then return []; endif

	    // Create constraint.

	create_constraint wkey;

	    // Set the constraint type to 'Same atom(s)'.

	local share_an_atom_x = indexof ['SAMEAIDX', first CTYPE];
	WindowSetData [wkey, [eC_type: share_an_atom_x]];
	WindowSetData [wkey, [
	    constrain_type: 2,	// !!!
	    constrain_sourceatoms: 1
	]];
	WindowSetAttr [wkey, [
	    constrain_nfeatures: [sensitive: 0],
	    constrain_sourceatoms: [sensitive: 1]
	]];

	DC_expr | DC_sel = CTYPE(1)(share_an_atom_x);
	setall_from_DDnDC wkey;
    endif
#endif
endfunction

#if 0
local function create_volume [wkey, opt]

	// Set default position to the centroid of selected atoms,
	// or to the center of the screen, if no atoms are selected

    local sel_atoms = SelectedAtoms[];
    if isnull sel_atoms then
	if anytrue opt.Ligand then
	    sel_atoms = Atoms[] | aClassRLS Atoms[] == 'lig';
	elseif anytrue opt.Receptor then
	    sel_atoms = Atoms[] | aClassRLS Atoms[] == 'rec';
	endif
    endif

    local pos = oCentroid sel_atoms;
    if isnull sel_atoms then
	pos = ViewLookAt[];
    endif

    aSetSelected [sel_atoms, 0];
    clear_listsel[];

	// Set default label and color
	// If any ligand atoms have been selected, modify defaults

    local expr, color, rad;
    rad = 2.4;
    expr = DV_DEFLABEL;
    color = DV_DEFCOLOR;

    local k = inc length DD_expr;
    DD_atom(k) = 0;
    DD_gkey(k) = GOpenQueN 1;
    DD_expr(k) = expr;

    ensure_Xxx dec k;
    DD_svalXxx(k) = '';
    DD_sval = T_poke [DD_sval, k, 0];
    DD_rval = T_poke [DD_rval, k, 0];
    DD_mval = T_poke [DD_mval, k, 0];

    DD_expr(k) = expr;
    DD_x(k) = pos(1);
    DD_y(k) = pos(2);
    DD_z(k) = pos(3);
    DD_r(k) = rad;
    DD_color(k) = color;
    // !!! essential bit on Volume is set but ignored
    DD_ebits(k) = 1;	// 1=essential
    // DD_gbits(k) = GOBJ_DEFDENSITY;	// low density, line, long offset text
    DD_gbits(k) = RTYPE_GBITS(DV_DEF_RTYPE);
    DD_sel(k) = 1;
    DD_usel(k) = 0;
    DD_ufold(k) = 0;
    DD_umask(k) = 0;
    DV_count = inc DV_count;

    ensure_que_dummies 0;		// ensure DD_atom handles valid
    aSetSelected [DD_atom(k), 1];

	// Update windows widgets (list & buttons) and 3D query rendering
	// If the Query Rendering window is open, update the
	// set of diplayed parameters for the "Selected" items.

    setall_from_DDnDC wkey;
endfunction
#endif

// Cluster atoms by their proximity.
// (Process atoms from largest to smallest.)
// For each atom not already in a cluster:
// - collect nearby atoms in a cluster
// - set the cluster center as the weighted avg. pos. of atom centers,
//   weighted by atom radii
// - set the cluster radius as the circumsphere of all atom spheres

local function cluster_spheres [pos, rad]
    local pkey = prox_open [0.2, pos, 0.2];	// 0.2 = max.dist. to c.center
    local mOK  = m_null rad;
    local cpos = tr pos;			// cpos(i): i-th cluster cntr
    local crad = rad;
    local i, r;

    // for i = 1, length mOK loop
    for i in x_sort -rad loop
	local [seg, idx] = prox_find [pkey, cpos(i), 0];
	if seg <= 1 then mOK(i) = 1; continue; endif	// no nearby atoms
	if anytrue mOK[idx] then continue; endif	// already represented
	mOK(i)= 1;				// mark i as a cluster center
	r = rad[idx];				// rad.of spheres in the cluster
	local w = r * invz add r;		// weigh spheres by their radius
	local cpos_idx = cpos[idx];		// centers of spheres in the c.
	cpos(i) = add (cpos_idx * w);		// use w.average position
	r = r +					// increase radii by the dist
	    app norm (cpos_idx - [cpos(i)]);	//   to the cluster center
	crad(i) = max r;			// set cluster radius
    endloop
    prox_close[];

    crad | not mOK = 0;
    return [cpos, crad];
endfunction

// ebits = 0:excluded 0x2:lig.shape(exterior), 0x4:occupied(included)

local function create_union [wkey, ebits, do_centroid]

	// Set default position to the centroid of selected atoms,
	// or to the center of the screen, if no atoms are selected

    local atoms = SelectedAtoms [];

    if isnull atoms then
	atoms = Atoms[];
	atoms = atoms | not aHidden atoms;
	if ebits == 0 then		// Excluded
	    atoms = Atoms[] | aClassRLS Atoms[] == 'rec';
	elseif ebits == V_EBIT_ALL then	// Ligand Shape
	    atoms = atoms | aClassRLS atoms == 'lig';
	elseif ebits == V_EBIT_ANY then	// Occupied
	    atoms = [];
	endif
    endif

    const RAD_C = 1.85;
    local rad = el_VDW_Radius aElement atoms;

	// Set volume sphere radius for ligand dummies (carbon).

    local cname = cName aChain atoms;
    local m_lig = cname == CHAIN_LIG_NAME;
    rad | m_lig = RAD_C;

	// Set volume sphere radius for query dummies (que.feature rad).

    local m_que = cname == CHAIN_QUE_NAME;
    rad | m_que = RAD_C;	// default for dummies from another ph4.editor
    local h = indexof [atoms, cat DD_atom];
    rad | h = (cat DD_r)[pack h];	// dummies from this ph4.editor

	// Sort atoms/dummies by their (assigned) radius, largest first.

    h = x_sort neg rad;
    rad = rad[h];
    atoms = atoms[h];

	// Prepare positions and radii for clustering the selected atoms.

    local pos = aPos atoms;	// (possible) cluster centers
    rad = maxE [0.1, minE [rad, 100]];	// max 100A rad of any sphere

    local mOK = m_null rad;		// mask of (real) cluster (ie. leaders)
    local do_cluster = 0;

	// If no atoms are selected, use center of the view.

    if isnull rad then
	pos = ViewLookAt[];
	rad = 2.4;
	mOK = 1;

	// If do_centroid, create a circumsphere centered at the centroid of
	// the sel.atoms that contains all the atoms including their radii.

    elseif do_centroid then
	local center = app add pos * invz l_length pos;
	rad = max (norm (pos - center) + rad);
	pos = center;
	mOK = 1;

    else
	do_cluster = 1;
    endif

	// Cluster atoms by their proximity.

#if 0
    if do_cluster then
	local pkey = prox_open [0.2, pos, 0.2];	// 0.2 = max.dist. to c.center
	local cpos = tr pos;			// cpos(i): i-th cluster cntr
	local i, r;

	// for i = 1, length mOK loop
	for i in x_sort -rad loop
	    local [seg, idx] = prox_find [pkey, cpos(i), 0];
	    if seg <= 1 then mOK(i) = 1; continue; endif// no nearby atoms
	    if anytrue mOK[idx] then continue; endif	// already represented
	    mOK(i)= 1;				// mark i as a cluster center
	    r = rad[idx];			// rad.of spheres in the cluster
	    local w = r * invz add r;		// weigh spheres by their radius
	    local cpos_idx = cpos[idx];		// centers of spheres in the c.
	    cpos(i) = add (cpos_idx * w);	// use w.average position
	    r = r +				// increase radii by the dist
		app norm (cpos_idx-[cpos(i)]);	//   to the cluster center
	    rad(i) = max r;			// set cluster radius
	endloop
	prox_close[];

	pos = tr (cpos | mOK);			// strip non-leaders
	rad = rad | mOK;
    endif
#else
    if do_cluster then
	local [cpos, crad] = cluster_spheres [pos, rad];
	mOK = crad > 0;			// mask of (real) cluster (ie. leaders)
	pos = tr (cpos | mOK);		// strip non-leaders
	rad = rad | mOK;
    endif
#endif

#   if DBG_CLUSTER_SPH_VERB
    if do_cluster then
	write '\n\n';
	local n1 = length mOK;
	local n2 = add mOK;
	write ['Clustering: rm\'d: {} / {} (n1={}, n2={})\n', n1-n2,n1,n1,n2];
	PR [removed_spheres: x_pack not mOK];
    endif
#   endif

    rad = dominant_spheres [pos, rad];
    mOK = rad > 0;
    rad = rad | mOK;
    pos = pos || [mOK];

    local n = length rad;
    if not n then return; endif	// safety

    clear_listsel[];

	// Set default label and color
	// If any ligand atoms have been selected, modify defaults

    local k = inc length DD_expr;
    DD_atom(k) = rep [0, n];
    DD_x(k) = pos(1);
    DD_y(k) = pos(2);
    DD_z(k) = pos(3);
    DD_r(k) = rad;
    DD_sel(k) = rep [1, n];

    DD_gkey(k) = GOpenQueN 1;

    ensure_Xxx dec k;
    DD_svalXxx(k) = '';
    DD_sval = T_poke [DD_sval, k , 0];
    DD_rval = T_poke [DD_rval, k , 0];
    DD_mval = T_poke [DD_mval, k , 0];

    DD_expr(k) = '';
    DD_color(k) = DV_DEFCOLOR;
    DD_ebits(k) = ebits;
    DD_gbits(k) = GOBJ_DEFDENSITY;	// low density, line, long offset text

    local nGT1 = n > 1;
    DD_usel(k) = nGT1;
    DD_ufold(k) = nGT1;
    DD_umask(k) = nGT1;
    DV_count = inc DV_count;

    ensure_que_dummies 0;		// ensure DD_atom handles valid
    aSetSelected [DD_atom(k), 1];
    aSetSelected [atoms, 0];

	// Update windows widgets (list & buttons) and 3D query rendering
	// If the Query Rendering window is open, update the
	// set of diplayed parameters for the "Selected" items.

    setall_from_DDnDC wkey;
endfunction

// Create a new constraint

local function create_constraint wkey
    DC_expr = append [DC_expr, DC_DEFEXPR];
    DC_ebits = append [DC_ebits, 0];
#if SHOW_DC_OPTION
    DC_gbits = append [DC_gbits, 0];
#endif
    DC_ids = append [DC_ids, x_pack keep [DD_sel, DF_count]];
    clear_listsel[];
    DC_sel = append [zero DC_sel, 1];	// Select new constraint
    DC_count = inc DC_count;
    setall_from_DDnDC wkey;
endfunction


// Ungroup spheres of selected groups.  The groups will disappear, the
// list of volumes will (partially) flatten, and the formerly grouped
// spheres will become independent, single-sphere volumes.

local function ungroup_volumes wkey

	// Select headers of unions where all spheres are selected.
	// Select all spheres of unions with selected headers.

    DD_usel = DD_usel or DD_umask and app alltrue DD_sel;
    DD_sel = DD_sel or DD_umask and DD_usel;

	// Move spheres in partially selected unions

    local m1 = DD_umask and not DD_usel and
	app anytrue DD_sel and  app anyfalse DD_sel;
    local m2 = m1 and DD_sel;
    // DD_sel = DD_sel and not m2;		// deselect subspheres
    local mm = app first (m2 | m1);	// first sphere selected

    local function move_subsel X
	local a = X || not m2 | m1;	// not selected
	a = app nest a;			// keep non-selected as a union
	local b = X || m2 | m1;		// selected
	local c = tr [a,b];		// split group into (non-sel,sel)
	c | mm = app reverse (c | mm);	// if first sphere sel., reverse order
	c = app cat c;
	return splice [X, x_pack m1, 1, c];
    endfunction

    DD_atom = move_subsel DD_atom;
    DD_sel = move_subsel DD_sel;
    DD_x = move_subsel DD_x;
    DD_y = move_subsel DD_y;
    DD_z = move_subsel DD_z;
    DD_r = move_subsel DD_r;
    local k = app first move_subsel x_id DD_expr;
    GOpenKey DD_gkey[k];
    GClose DD_gkey;
    DD_gkey = DD_gkey[k];

    ensure_Xxx length DD_expr;
    DD_svalXxx = DD_svalXxx[k];
    DD_sval = T_get [DD_sval, k];
    DD_rval = T_get [DD_rval, k];
    DD_mval = T_get [DD_mval, k];

    DD_expr = DD_expr [k];
    DD_color = DD_color [k];
    DD_ebits = DD_ebits [k];
    DD_gbits = DD_gbits [k];
    DD_umask = app length DD_sel > 1;
    DD_usel = DD_usel [k] and DD_umask;
    DD_ufold = DD_ufold [k] and DD_umask;
    DV_count = length k;

	// Calculate auxiliary access data:
	// m = mask of unselected unions
	// k = indices of features and volumes, where the index of each union
	//	being ungrouped is replicated N times, N = size of the union

    local m = DD_umask and not DD_usel;
    k = stretch [x_id DD_sel, select [app length DD_sel, 1,  DD_usel]];
    DV_count = isub [length k, DF_count];

	// Update nested DD_ vectors

    DD_sel = cat mput [DD_sel, m, app nest (DD_sel | m)];
    DD_atom = cat mput [DD_atom, m, app nest (DD_atom | m)];
    DD_x = cat mput [DD_x, m, app nest (DD_x | m)];
    DD_y = cat mput [DD_y, m, app nest (DD_y | m)];
    DD_z = cat mput [DD_z, m, app nest (DD_z | m)];
    DD_r = cat mput [DD_r, m, app nest (DD_r | m)];

	// Update flat DD_ vectors

    GOpenKey DD_gkey[k];
    GClose DD_gkey;
    DD_gkey = DD_gkey[k];

    ensure_Xxx length DD_expr;
    DD_svalXxx = DD_svalXxx[k];
    DD_sval = T_get [DD_sval, k];
    DD_rval = T_get [DD_rval, k];
    DD_mval = T_get [DD_mval, k];

    DD_expr = DD_expr[k];
    DD_color = DD_color[k];
    DD_ebits = DD_ebits[k];
    DD_gbits = DD_gbits[k];
    DD_usel = (DD_usel and m)[k];
    DD_umask = m[k];
    DD_ufold = (DD_ufold and m)[k];

	// Update windows widgets (list & buttons) and 3D query rendering
	// If the Query Rendering window is open, update the
	// set of diplayed parameters for the "Selected" items.

    setall_from_DDnDC wkey;
endfunction


// group_volumes groups selected volume spheres into unions.
// All selected spheres will be moved to the newly created group volume:
// selected single-sphere volumes will disappear,
// groups containing slected spheres will be trimmed.  If a group is trimmed
// down to one sphere, it will be ungrouped.  If a group is trimmed to zero
// spheres, it will be removed.

local function group_volumes wkey

	// Select all spheres of unions with selected headers
	// Select header of unions with all spheres selected

    DD_sel = DD_sel or DD_umask and DD_usel;
    DD_usel = DD_usel or DD_umask and app alltrue DD_sel;

	// Prepare masks and indices:
	// m	... (nested) mask of all spheres to be grouped
	// m_flat... flat mask of all volumes containing spheres to be grouped
	// usize... number of spheres in the new list of volumes
	// ksrc	... position of the new group in the old list
	// kdst	... position of the new group in the new list

    local m = DD_sel and x_id DD_sel > DF_count;	// sel. vol. spheres
    // if allfalse m then return; endif
    if allfalse m then return; endif
    local m_flat = app anytrue m;			// sel. volumes
    local usize = app iadd not m;
    local ksrc = x_max m_flat;

	// The position of the new group is set to the position of the
	// first selected volume.  If the first selected volume starts
	// with unselected spheres, we position the new group after the
	// first selected volume (which is reduced, but preserved).

    local kdst = isub [ksrc, iadd not keep [usize, dec ksrc]];
    if length m(ksrc) > 1 and not m(ksrc)(1) then kdst = inc kdst; endif

	// Reset nested DD_ vectors.

    local function splice_nested vec
	= splice [vec || not m | usize, kdst, 0, [[cat (vec || m)]]] ;

    DD_sel =	splice_nested DD_sel;
    DD_atom =	splice_nested DD_atom;
    DD_x =	splice_nested DD_x;
    DD_y =	splice_nested DD_y;
    DD_z =	splice_nested DD_z;
    DD_r =	splice_nested DD_r;

	// Reset flat DD_vectors.  Note: Select and fold the new group
	// and ungroup groups of size 1.

    local function splice_flat vec
	= splice [vec | usize, kdst, 0, [[vec(ksrc)]]] ;

    local old_gkey = DD_gkey;
    DD_gkey =	splice_flat DD_gkey;
    GOpenKey	DD_gkey;
    GClose	old_gkey;

    ensure_Xxx length DD_expr;
    DD_expr =	splice_flat DD_expr;
    DD_svalXxx = splice_flat DD_svalXxx;
    DD_sval = tag [tags DD_sval, app splice_flat second untag DD_sval];
    DD_rval = tag [tags DD_rval, app splice_flat second untag DD_rval];
    DD_mval = tag [tags DD_mval, app splice_flat second untag DD_mval];

    DD_color =	splice_flat DD_color;
    DD_gbits =	splice_flat DD_gbits;
    DD_ebits =	splice_flat DD_ebits;
    DD_usel =	splice [DD_usel | usize, kdst, 0, 1];
    DD_umask =	app length DD_sel > 1;
    DD_ufold =	splice [DD_ufold | usize, kdst, 0, FOLD_NEW_GROUPS];

	// Update the volume count

    DV_count = isub [length DD_expr, DF_count];

	// Update windows widgets (list & buttons) and 3D query rendering
	// If the Query Rendering window is open, update the
	// set of diplayed parameters for the "Selected" items.

    setall_from_DDnDC wkey;
endfunction

// Adjust radii so that their average becomes rad.
// If any of the radii is to be set negative, clamp it to 0.

// THE PROBLEM OF CALCULATING THE ADJUSTMENT TO RADII:
// Input:
//	rad >= 0
//	x_1 <= x_2 ... <= x_N
// Problem:
//	find D, such that
//	rad = sum {max (0, x_i-D) | i=1..N} / N
// That is:
//	find k and D, such that
//	x_1 <= x_2 ... x_k <= D <= x_k+1 ... <= x_N
//	rad = sum {x_i - D | i=k+1..N} / N
// Let:
//	crad = sum {x_i | i=1..N} / N
// Solution:
//	(N-k)*D = N*(crad-rad) - X_k, X_k = sum {x_i, i=1..k}
// That is:
//	d(i) = (N*(crad-rad) - X_i)/(N-i)
//	k = max {i | x_i <= d(i)}
//	D = d(k)

local function adjust_radii [arad, rad]
    local crad = add arad * invz length arad;

    if rad <= 0 then
	arad = zero arad;
    elseif min arad + rad - crad >= 0 then
	arad = arad + rad - crad;
    else
	local x = sort arad;
	local n = length x;
	local d = (n * (crad - rad) - pscan x) * invz (n - igen n);
	d = add last (d | d >= x);	// "add" is just a safety
	arad = maxE [0, arad - d];
    endif

    return arad;
endfunction

// adjust_trans returns a set of transparency values, t_new, such that their
// average is tagv_new and their distribution around their average is the
// same (up to clamping) as that of the original values, t_org.

local function adjust_trans [tavg_new, t_org]

	// Calculate the difference between the desired average and
	// the average of the orginal values.  Add the difference to
	// the original values to obtain the new values.

    local tavg_diff = tavg_new - round avg t_org;
    local t_new = t_org + tavg_diff;
    local m = leE [0, t_new, 255];	// !!! don't use neg. transparency

	// If the new values don't need clamping, return them.

    if alltrue m then return t_new; endif

	// If the new values need clamping, clamp the outliers and ajust
	// the values of the remaining elements.

	// !!! this is a hack:
	// Loop until there are no more outliers or there are no elements
	// left to adjusts.

    for 10 while neL m loop
	if eqL m then return t_new; endif
	t_new = maxE [0, minE [t_new, 255]];
	tavg_diff = tavg_new - avg t_new;
	t_new = t_new + round (tavg_diff * length m / add m);
	m = leE [0, t_new, 255];	// !!! don't use neg. transparency
    endloop

    return t_new;
endfunction


function __mdb_molfields;
local function mols_check_file [file, mode]
    local err;

    if isnull file then
	return '';
    elseif eqL [m_findmatch [['*.oeb', '*.oeb.gz'], file], 1] then
	return '';
    elseif anytrue (err = db_CheckFile [file, mode]) then
	return err;
    elseif anytrue (err = db_CheckMolfield file) then
	return err;
    endif

    local [common, packed, unpacked, other] = __mdb_molfields file;
    if allfalse app length [packed, unpacked] then
	return 'Conformation field of wrong type';
    endif

    return '';
endfunction

local function mols_check_common_molfield [file, molfield]
    local err, m;

    if isnull file then
	return '';
    elseif anytrue (m = m_findmatch [['*.oeb', '*.oeb.gz'], file]) then
	if alltrue m then return ''; endif
	return 'OEB and MDB files can\'t be searched at the same time';
    endif

    local [common, packed, unpacked, other] = __mdb_molfields file;

    if anytrue app length [packed, unpacked] then
	return '';

    elseif length common then
	return 'Common molecule fields must be all\npacked or all unpacked';

    else
	return 'Common molecule field not found';
    endif
endfunction



// Start the search panel

local function start_search wkey

	// If the search is reportedly running, but the window key is
	// not valid, something went wrong: kill the search task.
	// (This should not ever happen, but let's be safe.)

    if neL [WIN_SEARCH_key, WIN_SEARCH_key = WindowKey WIN_SEARCH_key] then
	task_kill SEARCH_tid;
	SEARCH_tid = [];

	// If the search is running, bring the search window to the forefront,
	// update its PH4 query-related fields, and update the PH4 search
	// data (stored in the editor panel for the use by the search).
	// Don't start or do anything else.

    elseif WIN_SEARCH_key then
	update_search_window WIN_SEARCH_key;	// update fields
	WindowShow WIN_SEARCH_key;		// show the window
	return;					// do nothing else
    endif

    // if check_matchsize [] then return; endif

	// Start a new task for the FilePrompt and for the cleanup
	// after the search is done

    task_kill SEARCH_tid;	// safety
    const targ1 = [master:'parent', title: '! SEARCH:Cleanup'];
    if 'child' <> second task_fork targ1 then return; endif
    SEARCH_tid = task_id[];

	// Note: if the editor is opened from a DB, start the search on
	// that database.  Otherwise, prompt for a filename.

    // const FILE_FCN = [['db_CheckFile', 'RO'], 'db_CheckMolfield'];
    // const FILELIST_FCN = 'db_CheckCommonMolfield';
    local FILE_FCN = [[#mols_check_file, 'RO']];
    local FILELIST_FCN = #mols_check_common_molfield;
    local PARG = [
	title: 'PH4 Search: Search Database',
	mode: 'open',
	// filter: ['*.mdb','*.oeb'],
	filterList: ['', 'Molecular Databases\t*.mdb,*.oeb,*.oeb.gz'],
	filterIndex: 2,
	name: token first SEARCH_fn,
	checkFileFcn: FILE_FCN,
	checkFileListFcn: FILELIST_FCN,
	allowDuplicates: 1,
	multi: 1
    ];

    local dbfile = TASKENV_dbfilename;

	// Prompt for the database name.  If the database is
	// already being searched, keep prompting until a valid,
	// not-searched database is given or the prompter is canceled.

#if 1
    // if allfalse dbfile then dbfile = FilePrompt PARG; endif
    // if allfalse dbfile then SEARCH_tid = []; exit[]; endif
#else
    loop
	if allfalse dbfile then
	    dbfile = FilePrompt PARG;
	endif
	if allfalse dbfile then
	    SEARCH_tid = [];
	    exit[];
	endif

	local function ph4search_wname fn = tok_cat [
	    'Pharmacophore Search: ', tok_cat sort db_Filename fn
	];
	static wname = ph4search_wname dbfile;

	    // Check if a search window already exist for the database.

	if WindowKey wname then
	    Warning token swrite [
		'Database \'{}\' is already being\n'
		'searched.  Select a different database.',
		dbfile
	    ];
	    dbfile = [];
	endif
    until anytrue dbfile endloop;
#endif
    SEARCH_fn = dbfile;		// remember the file name for the next search

	    // Wait for the "search window ready" signal.

    static sigwind;
    if 'child' == second task_fork [master:'parent'] then
	task_prio 0;
	if 'child' == second task_wfork [master:'parent'] then
	    sigwind = task_id[];
	    sleep Inf;

	    // Catch the "search window ready" signal.

	else
	    WIN_SEARCH_key = (WindowGetData [wkey, 'search_wkey']).search_wkey;
	    SEARCH_tid = (WindowGetData [wkey, 'search_tid']).search_tid;
	    QUE_changed = 0;	// ??? !!!`
	    QUE_qdataOK = 0;
	    update_ph4title wkey;
	    // WindowSetAttr [wkey, [shell: [bubbleHelp: ACTION_HELP2]]];
	endif
	exit[];
    endif
    sleep 0.1;	// make sure that the signal is installed

	// Start the search
	// Wait for the "search died" signal

    if 'child' == second task_wfork [master:'parent'] then
	local data = qdata_Get [];
	run_file [ 'ph4_search.svl', [ dbfile, [], [
	    gui:1,
	    ph4data:data,
	    sigchld: task_id[],		// SIGNAL: child died
	    sigwind: sigwind,		// SIGNAL: window ready
	    edit_wkey: wkey
	]]];
	sleep Inf;

	// Catch the "search died" signal

    else
	task_prio 0;
	WIN_SEARCH_key = 0;	// do not update search panel
	local bhelp = ph4_edit_bhelp [];

	WindowSetAttr [wkey, [shell: [bubbleHelp: bhelp.shell]]];
    endif
    exit [];

endfunction


// Given the index(es) of the selected mainlist items, return the
// (corresponding) index(es) of union header(s) in the DD_umask array (if any).

local function x_union_header k
    local m = split [m_join [igen iadd LIST_seg, k], LIST_seg];
    m = splice [m, inc DF_count, DC_count, [[]]]; // remove constraints
    m = app first m and DD_umask;	// selected union headers
    return x_pack m;			// indices of the selected union header
endfunction

// !!! Sphere/dummies selection sync policy:
// 1) hide DL_atoms that are obscured by overlayed DD_atoms.
// 2) If a listbox selection changes, select all corresponding DD_atoms.

// Update DD_ and DC_ structures based on the new list selection, listval,
// as returned by the widget

local function mainlist_select [wkey, listval]
    local k, m;

	// Convert widget data to DD_ selection vectors.

    k = sort first listval;
    local listsel = m_join [igen iadd LIST_seg, k];
    put_listsel listsel;

	// Copy selection of folded unions to all of their spheres.

    DD_sel = DD_sel or (DD_usel and DD_ufold);
    DD_sel = DD_sel and (not DD_umask or not DD_ufold or DD_usel);

	// Copy list selection to atom selection.

    ensure_que_dummies 0;		// ensure DD_atom handles valid
    aSetSelected [cat DD_atom, cat DD_sel];

	// Update the window widget and query rendering.

    update_listsel wkey;

	// On double click, invert the folded state of
	// the union and select all of its spheres.

    if second listval == 2 then
	if length (k = x_union_header first first listval) then
	    DD_ufold(k) = not DD_ufold(k);
	    DD_sel(k) = one DD_sel(k);
	endif
	// setall_from_DDnDC wkey;
    endif
    setall_from_DDnDC wkey;
endfunction


// Convert a sorted list of integers (ordinal numbers) into
// a list of tokens.  Abbreviate ranges of consecutive numbers.

local function numlist_to_toklist v
    local w = [], i, j = 0;
    local v_lo = v(1), v_hi = v(1);

    if isnull v then return []; endif
    local n1 = inc length v;

    for i=2, n1 loop
	if i < n1 then if v(i) == inc v_hi then
	    v_hi = v(i);
	    continue;
	endif endif

	if v_lo == v_hi then
	    w(j = inc j) = swrite ['{},', v_lo];
	elseif v_lo == dec v_hi then
	    w(j = inc j) = swrite ['{},', v_lo];
	    w(j = inc j) = swrite ['{},', v_hi];
	else
	    w(j = inc j) = swrite ['{}-{},', v_lo, v_hi];
	endif

	if i < n1 then
	    v_lo = v_hi = v(i);
	endif
    endloop

    return app token w;
endfunction

// Generate a warning when deleting query items.

local function cancel_delete []
    local sel = [DD_sel, DD_usel | DD_umask, DC_sel];
    local items = select ['item', 'items', iadd cat cat sel == 1];
    if allfalse sel then
	return 1;
    elseif alltrue sel then
	return not YesNo 'Delete all items?';
    elseif not DELPROMPT_ENUMERATE then
	return not YesNo tok_cat ['Delete selected ', items, '?'];
    endif

    local Fs = x_pack keep [DD_sel, DF_count];
    local Cs = x_pack DC_sel;
    local m = DD_usel and DD_umask or app alltrue DD_sel;
    local Vs = x_pack drop [m, DF_count];
    m = not m and app anytrue DD_sel;
    local S1s = x_pack drop [m, DF_count];
    local S2s = app x_pack (DD_sel | m);
    m = get [cat [one Vs, zero S1s], x_sort cat [Vs, S1s]];
    local list = [];

    if DELPROMPT_ENUMERATE == 1 then
	local count = [length Fs, length Cs, length Vs, length cat S2s];
	local name = ['feature', 'constraint', 'volume', 'sphere'];
	list = apt swrite [
	    ' {} {}{},', count, name, select ['s', '', count <> 1]];

	list = cat ["Delete", droplast cat (list | count), "?"];
    else
	Fs = tok_cat ['F', numlist_to_toklist Fs];
	Cs = tok_cat ['C', numlist_to_toklist Cs];
	Vs = tok_cat ['V', numlist_to_toklist Vs];
	S1s = app token apt swrite ['V{}.', S1s];
	S2s = app numlist_to_toklist S2s;
	list = cat [Fs, Cs, cat unpack [Vs, tok_cat [S1s, S2s], m]];
	
		
	// list = prepend [list, 'Delete', 'selected', items];
	list = prepend [list, 'Delete'];
	list = drop [swriteb_tblLF ['tw', list, -20], -2];
	list = append [list, "?"];
	
    endif

    local msg = token cat list;
    return not YesNo msg;
endfunction


// Deleting selected items from the list: modify DD_... and DC_ structures
// to reflect the change.

local function delete_selected wkey

	// Strip selected constraints

    if anytrue DC_sel then
	GetSet_DC x_pack not DC_sel;
	DC_count = length DC_expr;
    endif

	// Convert constraints to lists of atoms

    local a = keep [DD_atom, DF_count];
    DC_ids = split [a[cat DC_ids], app length DC_ids];

	// Strip spheres inside unions.

    local m = not (DD_sel and DD_umask);
    if anytrue m then
	DD_atom = DD_atom || m;
	DD_x = DD_x || m;
	DD_y = DD_y || m;
	DD_z = DD_z || m;
	DD_r = DD_r || m;
	DD_sel = DD_sel || m;

	    // Ungroup unions that come to contain only a single-sphere.
	    // (Don't touch empty unions.)

	m = app length DD_sel == 1 and DD_umask;
	DD_sel | m = DD_usel | m;
	m = not m and DD_umask;
	[DD_umask, DD_usel, DD_ufold] = [DD_umask, DD_usel, DD_ufold] and [m];
    endif

	// Strip selected features, simple volumes and
	// unions with selected headers.
	// Strip unions that became empty.

    m = select [DD_usel, DD_sel, DD_umask] or app length DD_sel == 0;
    if anytrue m then
    // !!!
	// GClearVertexData DD_gkey[x_pack m];
	GetSet_DD x_pack not m;
	[DF_count, DV_count] = app iadd split [not m, [DF_count, DV_count]];
    endif

	// Strip constraint lists of deleted dummies and
	// convert constraints back to lists of indices

    DC_ids = split [indexof [cat DC_ids, DD_atom], app length DC_ids];
    DC_ids = app sort app pack DC_ids;

	// Update windows widgets (list & buttons) and 3D query rendering
	// If the Query Rendering window is open, update the
	// set of diplayed parameters for the "Selected" items.

    setall_from_DDnDC wkey;
endfunction

// update_svalInfo updates statics and widgets according to info tagvector
// (supplied by the 'SvalInfo' method of the ph4 scheme).
// non-EHT: info = []
// EHT: info = [
//    svalControl: [ Acc:['Acc', 'Acc2'], Don:['Don','Don2'] ],
//    svalDefault: sval_scale [[Acc:MIN_EMA, Don:MIN_EMD], do_water],
//    rvalDefault: sval_scale [[Acc:WATER_EMD, Don:WATER_EMA], -do_water]
//];

local function update_svalInfo [wkey, scheme]
    local info = ph4_SchemeFcn [scheme, 'SvalInfo'];
    SCHEME_svalOK = anytrue info;

	// Set the ann.type controls, e.g.
	//	SVAL_XxxYyy = [Acc: [Acc,Acc2], Don: [Don,Don2]] means that
	//	Acc controls both Acc and Acc2 and simpilarly for Don.
	// The defaults are stored in terms of controls, e.g.
	//	SVAL_default = [Acc: 0.80, Don: 0.60]

    SVAL_XxxYyy = info.svalControl;		// [Acc:['Acc','Acc2', Don:...]
    SVAL_Xxx = tags SVAL_XxxYyy;		// ['Acc', 'Don']

#if 1
// !!! LIG_svalMin should be taken from the "Show..." (scheme info) panel,
// cached similarly to smask (which ann.types are displayed)
// If Show:minAcc/minDon are not set, SVAL_default should be used instead
// RVAL_default
    SVAL_default = info.svalDefault;		// min.displayed
    RVAL_default = info.rvalDefault;
    local Xxx;
    for Xxx in SVAL_Xxx loop
	MVAL_default.(Xxx) = SVAL_default.(Xxx) * RVAL_default.(Xxx);
    endloop
    if neL [SVAL_Xxx, tags SVAL_default, tags RVAL_default] then E_BUG[]; endif
    LIG_svalMin = SVAL_default;
#endif
endfunction

// change_scheme sets SCHEME_name to the given scheme and resets dependent
// widgets and graphics.  The current values of feature expressions could
// become invalid (because a type does not exist any more).
// !!! If that happens, we should issue a warning and mark the invalid
// expression.

local function change_scheme [wkey, scheme]
    SCHEME_name = scheme;
    SCHEME_type = ph4_SchemeLabels scheme;
    SCHEME_tcode = ph4_SchemeBits scheme;

    update_svalInfo [wkey, scheme];

    WindowSetAttr [wkey, [
// !!! AccDon
	eD_svalType: [text: SVAL_Xxx],
	eD_use_sval_p: [page: inc SCHEME_svalOK]
    ]];

	// If the new scheme needs svals (e.g. when changing form Unified
	// to EHT), ensure that DD_[srm]val are present.

    if SCHEME_svalOK then
	local N = length DD_r;
	local m = igen N <= DF_count;
	local Xxx;

	for Xxx in SVAL_Xxx loop
	    if neL [length DD_sval.(Xxx), N] then
		DD_sval.(Xxx) = unpack [SVAL_default.(Xxx), 0, m];
	    endif
	    if neL [length DD_rval.(Xxx), N] then
		DD_rval.(Xxx) = unpack [RVAL_default.(Xxx), 0, m];
	    endif
	    if neL [length DD_mval.(Xxx), N] then
		DD_mval.(Xxx) = unpack [MVAL_default.(Xxx), 0, m];
	    endif
	endloop
    endif

    if not SCHEME_svalOK then if anytrue (LIG_rsl >= 3) then
	LIG_rsl = maxE [LIG_rsl, 2];
	// !!! this should send a trigger instead!
	update_lig_annotation 1;
	setattr_ligrec wkey;
    endif endif

    QUE_changed = 1;
    QUE_qdataOK = 0;
    update_ph4title wkey;
    MATCH_update = 1;

    if WIN_SEARCH_key then update_search_window WIN_SEARCH_key; endif // !!!
    if anytrue WindowKey CONS_wkey then
	local smask = scheme_mask scheme;
	WindowTrigger [CONS_wkey, [SCHEME_update: [scheme, smask]]];
    endif
endfunction

const SVAL_LATER = 0;	// !!! needs work

// Update the SCHEME_... static variables and relevant panel widgets
// according to a new value of scheme (of ph4 types) and return 0.
// If the scheme is not valid, do nothing and return non-0.

local function update_scheme [wkey, data];
#if SVAL_LATER
    local schemes = ph4_SchemeList 1;

    if not istagged data then		E_BUG[]; endif
    if not istagged data.S then		E_BUG[]; endif

    local scheme = data.S.scheme;
    if not isscalartok scheme then	E_BUG[]; endif
    if m_diff [scheme, schemes] then	E_BUG[]; endif
#else
    local scheme = data.S.scheme;
    local schemes = ph4_SchemeList 1;
    if m_diff [[scheme], SCHEME_list] then scheme = 'PCH'; endif
#endif

    SCHEME_name = scheme;
    SCHEME_type = ph4_SchemeLabels scheme;
    SCHEME_tcode = ph4_SchemeBits scheme;

#if SVAL_LATER
    local info = ph4_SchemeFcn [scheme, 'SvalInfo', []];
    SCHEME_svalOK = anytrue info;

	// Set the ann.type controls, e.g.
	//	SVAL_XxxYyy = [Acc: [Acc,Acc2], Don: [Don,Don2]] means that
	//	Acc controls both Acc and Acc2 and simpilarly for Don.
	// The defaults are stored in terms of controls, e.g.
	//	SVAL_default = [Acc: 0.80, Don: 0.60]

    SVAL_XxxYyy = info.svalControl;
    SVAL_Xxx = tags SVAL_XxxYyy;
    SVAL_default = info.svalDefault;
    RVAL_default = info.rvalDefault;
    if neL [SVAL_Xxx, tags SVAL_default, tags RVAL_default] then E_BUG[]; endif
    LIG_svalMin = SVAL_default;
#else
    update_svalInfo [wkey, scheme];
#endif

    return data;
endfunction

// ph4data_load resets the values of DD/DC/etc. statics to represent
// the contents of the given que.data.

local function ph4data_load [wkey, data]
    data = update_scheme [wkey, data];
    local sval_xxx;	// SVAL_Xxx as it was when the query was stored

	// Note: even though SVAL_Xxx is defined by the scheme, we
	// also store it explicitly in the query, so that it could be
	// redefined later without invalidating older .ph4 files.

    if SCHEME_svalOK then
	if isscalarnum data.S.useRval then SVAL_useRval = data.S.useRval; endif
	sval_xxx = data.S.svalXxx;
#if 1
	if isnull sval_xxx then E_BUG[]; endif
	if length sdiff [sval_xxx, SVAL_Xxx] then E_BUG[]; endif
#else
	if length sdiff [sval_xxx, SVAL_Xxx] then sval_xxx = SVAL_Xxx; endif
#endif
    endif

	// Split query into logical blocks (features, inc.volumes, ...)

    local dF = data.F, dC = data.C;
    local dVS = data.VS, dV = data.V;

    [DC_expr, DC_ebits, DC_ids] = [dC.expr, dC.ebits, dC.ids];
#if SHOW_DC_OPTION
#   if SHOW_DC_CONES
	DC_gbits = bitand [dC.gbits, 0x3];
#   else
	DC_gbits = bitand [dC.gbits, 0x1];
#   endif
    if isnull DC_gbits then DC_gbits = m_null DC_ebits; endif
#endif

	// Perform a sanity check to detect illegal queries

    local e = [];

    if anyfalse indexof [cat DC_ids, x_id dF.expr] then
	e = cat [e, "\nGroup constraints include features that do not exist."];
	DC_ids = DC_ids || apt indexof [DC_ids, [x_id dF.expr]];
    endif

    if anyfalse app ltL DC_ids then
	e = cat [e, "\nGroup constraints store features in wrong order."];
	DC_ids = app sort DC_ids;
    endif

    if anyfalse indexof [DC_expr, CTYPE(1)] then
	e = cat [e, "\nGroup constraints include unknown constraint types."];
	DC_expr | m_diff [DC_expr, CTYPE(1)] = CTYPE(1)(1);
    endif

	// Initiate counters

    DC_sel = zero DC_expr;
    DC_count = length DC_expr;

    DF_count = length dF.expr;
    DV_count = length dV.expr;

	// Extract and concatenated properties of features and i&x volumes

    local seg = dV.size;
    DD_x = cat [dF.x, split [dVS.x, seg]];
    DD_y = cat [dF.y, split [dVS.y, seg]];
    DD_z = cat [dF.z, split [dVS.z, seg]];
    DD_r = cat [dF.r, split [dVS.r, seg]];
    DD_color = cat [dF.color, dV.color];
    DD_expr = cat [dF.expr, dV.expr];

    DD_svalXxx = lhs ['', DD_expr];
    DD_sval =
    DD_rval =
    DD_mval = [];

	// Note: Strengths are stored in data.FS.{mval,rval}{Don,Acc,...}.
	// Each of these vectors must be of the same length as data.F.expr.

    if SCHEME_svalOK then
	local dFS = data.FS;
	local m = m_id DD_expr <= DF_count;
	DD_svalXxx | m = expr2xxx DD_expr| m ;
	local Xxx;
	for Xxx in sval_xxx loop
	    local svalXxx = tok_cat ['sval', Xxx];
	    local rvalXxx = tok_cat ['rval', Xxx];
	    if isnull dFS.(svalXxx) then
		dFS.(svalXxx) = rep [SVAL_default.(Xxx), DF_count];
	    endif
	    if isnull dFS.(rvalXxx) then
		dFS.(rvalXxx) = rep [RVAL_default.(Xxx), DF_count];
	    endif
	    DD_sval.(Xxx) = cat [dFS.(svalXxx), m_null dV.expr];
	    DD_rval.(Xxx) = cat [dFS.(rvalXxx), m_null dV.expr];
	endloop

	if neL [sval_xxx, SVAL_Xxx] then
	    DD_sval = tag [SVAL_Xxx, tagget [DD_sval, SVAL_Xxx]];
	    DD_rval = tag [SVAL_Xxx, tagget [DD_rval, SVAL_Xxx]];
	endif

	for Xxx in SVAL_Xxx loop
	    DD_mval.(Xxx) = DD_rval.(Xxx) * DD_sval.(Xxx);
	endloop
    endif

    if isnull dF.m then dF.m = lhs [GOBJ_matDefault, dF.expr]; endif
    if isnull dV.m then dV.m = lhs [GOBJ_matDefault, dV.expr]; endif
    local mat = cat [dF.m, dV.m];

    GClose DD_gkey;
    DD_gkey = GOpenQueN length DD_expr;
    GSetTransparency [DD_gkey, [bitand [bitshr [mat, 24], 0xff]]];
    GSetMaterialTSGB [DD_gkey, [bitand [mat, 0xffffff]]];

    DD_ebits = cat [dF.ebits, dV.ebits];
    DD_gbits = cat [dF.gbits, dV.gbits];

// !!!
	// Strip obsolete text bits

    DD_gbits = bitand [DD_gbits, bitnot RMASK_IGNORE];

	// Initialize atom handles and selection flags

    DD_atom = DD_sel = zero DD_r;
    DD_usel = zero DD_expr;
    DD_umask = DD_ufold = notnot dec app length DD_sel;

#if USE_DL_SEL
    DL_sel = [];
#endif

	// Extract and verify minimum match size

    DS_matchsize	= data.S.matchsize;
    if not isscalarnum DS_matchsize then		// missing: def to 0
	DS_matchsize	= 0;
    elseif leL [-DF_count, DS_matchsize, DF_count] then	// OK: within range
    elseif DS_matchsize >= INT_MAX then			// min #features=N
	DS_matchsize	= DF_count;			// don't complain
    elseif DS_matchsize <= -INT_MAX then		// min #features=0
	// DS_matchsize	= -DF_count;			// don't complain
    elseif DS_matchsize > DF_count then
	DS_matchsize = DF_count;
	e = cat [e, "\nPartial match size requires too many features."];
    else
	DS_matchsize = -DF_count;
	e = cat [e, "\nPartial match size does not require enough features."];
    endif

	// Set title and comment field

    DS_title = token data.S.title;
    DS_comment = string data.S.comment;

	// Reset display of properties

    if length e then
	Warning token cat ["WARNING:", e, "\nQuery data will be adjusted."];
    endif

    return data;
endfunction

// load_qdata replaces the contents of wkey widgets, DD/DL/QUE/LIG/... statics
// main win dummies and gobj's with those representing the given gdata.
// Return 0 on sucess and non-0 on error.

local function load_qdata [wkey, qdata]
    local prio = task_prio 0;
    ph4data_load [wkey, qdata];

    WindowSetAttr [wkey, [commentP: [foreground:
	select ['baseBlue', 'none', anyfalse isspace DS_comment]
    ]]];

    if SCHEME_svalOK then
	SetRCBoolean [RC_USE_RVAL, SVAL_useRval];
	WindowSetAttr [wkey, [
	    eD_useRval_p: [page: inc SVAL_useRval],
	    sval_useRval: [value: SVAL_useRval],
	    eD_svalType: [text: SVAL_Xxx],
	    eD_use_sval_p: [page: inc SCHEME_svalOK]
	]];
    endif

	// If qdata is a valid, but using a newly loaded scheme, reset
	// the list of schemes.

    if m_diff [SCHEME_name, SCHEME_list] then
	SCHEME_list = ph4_SchemeList 1;
	if m_diff [SCHEME_name, SCHEME_list] then E_BUG[]; endif
	WindowSetAttr [wkey, [scheme: [text: SCHEME_list]]];
    endif

	// Set window widgets from the values of statics.

    WindowSetData [wkey, [scheme: SCHEME_name]];
    QUE_changed = 1;
    QUE_qdataOK = 0;
    update_ph4title wkey;
    MATCH_update = 1;

	// (See also msize_1to3, except that here 0 is replaced by DF_count.)


#if 1
    local [msize_nonzero, msize_sign, msize] = msize_1to3 DS_matchsize;
    WindowSetData [wkey, [
	// !!! WT: checkbox widget uses test ">0" instead of "!=0"
	msize_nonzero:	msize_nonzero,
	msize_sign:	msize_sign,
	msize:		msize,
	que_title:	DS_title
    ]];
    tval_set [wkey, [msize: msize]];
#else
    WindowSetData [wkey, [
	// !!! WT: checkbox widget uses test ">0" instead of "!=0"
	msize_nonzero:	notnot DS_matchsize,
	msize_sign:	select [1, 2, DS_matchsize >= 0],
	que_title:	DS_title
    ]];
    tval_set [wkey, [
	msize: select [abs DS_matchsize, DF_count, DS_matchsize]
    ]];
#endif
    // !!! WT: sensitive attribute uses test ">0" instead of "!=0"
    WindowSetAttr [wkey, [
#if PARTIAL_MATCH_P
	msize_p: [page: 2- notnot DS_matchsize],
#endif
	msize_sign: [sensitive: notnot DS_matchsize],
	msize: [sensitive: notnot DS_matchsize]
    ]];

// !!! HACK
    if DS_matchsize <= -INT_MAX then
	WindowSetData [wkey, [msize: 0, msize_sign: 1]];
	tval_set [wkey, [ msize: 0 ]];
    endif

	// If use_Hs is stored explicitly in the query, honor it.

    if isscalarnum qdata.S.use_Hs then
	if neL [LIG_use_Hs, LIG_use_Hs = qdata.S.use_Hs] then
	    update_lig_annotation 1;
	endif
    endif

    setall_from_DDnDC wkey;
    check_query wkey;

    if not SCHEME_svalOK then if anytrue (LIG_rsl >= 3) then
	LIG_rsl = maxE [LIG_rsl, 2];
	update_lig_annotation 1;
	setattr_ligrec wkey;
    endif endif

    update_lig_annotation 2;
    QUE_saved_data = qdata_Get[];
    draw_que_features 1;	// force
    // !!! ? ensure_que_dummies
    task_prio prio;

    if WIN_SEARCH_key then update_search_window WIN_SEARCH_key; endif // !!!

    if anytrue WindowKey CONS_wkey then
	local smask = scheme_mask SCHEME_name;	// !!!
	WindowTrigger [CONS_wkey, [SCHEME_update: [SCHEME_name, smask]]];
    endif

    return 0;
endfunction

// Return the chain of PH4 dummy atoms.  (If the chain does not exist,
// create it and populate it with query dummies.)

local function ph4que_chain []
    if not ph4que_chain_ok[] then ensure_que_dummies 0; endif
    return CHAIN_QUE_key;
endfunction

// === Popups ==============================================================

local function draw_que_features;

const MAT_SAME = 0x1e8de2;	// !!! use RC or system
const MAT_DIFF = 0xff66cc;

const RESET_TO_DEFAULT = 2;	// reset to val: 0=at popup time, 1=when created

const RESET_TO_DEFAULT_1 = RESET_TO_DEFAULT == 1; // "Default" on the bottom
const RESET_TO_DEFAULT_2 = RESET_TO_DEFAULT == 2; // "D" in bottom-right corner

// render_popup: Puts up popup for editing rendering mode
//	of selected list items.
// Returns: nothing

// !!! if  the render_popup panel dies before the query has time
// to re-generate itsef, the update gets permanently crippled
// The calculation needs to be done in a separate (perhaps deletable)
// task that sends it results to the main event loop with a trigger.
// The main event loop then (quickly) updates the gobj's (and the statics?).

local function render_popup [pkey, location]
    local m = DD_usel or app anytrue DD_sel;	// selected items
    if allfalse m then m = m_id m; endif
    // if allfalse m then return; endif
    local bhelp = ph4_edit_bhelp [];

	// Store popup-time rendering properties in val_org.

    local color_org = DD_color | m;
    local trans_org = first GTransparency (DD_gkey | m);
    local mat_org   = first GMaterialTSGB (DD_gkey | m);
    local rbits_org = bitand [RMASK_ALL, DD_gbits | m];	// type+density+txt.offs
    local rtype_org = [2,1,4,3,5][inc bitand [RMASK_TYPE, rbits_org]];
    local val_org = [color_org, trans_org, mat_org, rbits_org];

	// Store default rendering properties in val_def.
	// Note: DD_foo|m|mF = sel.features, DD_foo|m|not mF = sel.volumes

    local mF = (x_id m <= DF_count) | m;
    local color_def = unpack [auto_color (DD_expr | m | mF), DV_DEFCOLOR, mF];
    local trans_def = unpack [DF_DEF_TRANS, DV_DEF_TRANS, mF];
    local mat_def   = unpack [DF_DEF_MAT, DV_DEF_MAT, mF];
    local rtype_def = unpack [DF_DEF_RTYPE, DV_DEF_RTYPE, mF];
    local rbits_def = RTYPE_GBITS[rtype_def];

    local val_def = [color_def, trans_def, mat_def, rbits_def];

	// Define the "cancel" color, used to detect the value of "Cancel"
	// event when the color widget sets colors of several objects that
	// start with different colors.  The "cancel" color is also the
	// start color of the widget.
	//
	// PROBLEM: if the user says "OK" without the changing the color,
	// it will be interpreted as "Cancel" instead.
	//
	// Note: the original colors are stored in color_org.
	//
	// The cancel color is set as the color of the background + 1,
	// to be visually the same, but numerically different from the actual
	// background color.  We don't use statics and recalculate the color
	// every time, in case MOE appearance has been switched (blanc vs noir).

    local colorCancel = inc DefaultColorBG[];

    // wcolor returns the color of the color widget to display colors c:
    // If #c>0 and all c's are the same, use c(1).  Otherwise, use background.

    function wcolor c = select [c[1], colorCancel, length c and eqL c];

    // !!!
    local trans_ismixed = neL round trans_org;

    local que_changed = QUE_changed;

    const ICO = '';	// was: '$MOE/lib/icon/'
    // GUI: ['Type','Line','Dot','Solid','Contour','None']
#if 1
    local ico = apt fcat [ICO, [
	'rtype_dot.ico',
	'rtype_line.ico',
	'rtype_solid.ico',
	'rtype_contour2.ico',
	'rtype_none.ico'
    ]];
#else
    local ico = apt fcat [ICO, [
	'sysman_atomstyle_point.ico',		// dot
	'sysman_atomstyle_line.ico',		// line
	'sysman_atomstyle_cpk.ico',		// solid
	'sysman_ribbonstyle_ribbon.ico',	// contour
	'sysman_atomstyle_hide.ico'		// none
    ]];
#endif
    ico = apt gr_icon [ico, 'medium', 'foreground'];

//    local rtype_help = tok_cat ['Sphere rendering: ', [
//	'Dot', 'Line', 'Solid', 'Contour', 'None'
//    ]];
    local rtype_help = tok_cat ['Sphere rendering: ', RTYPE_NAME];

    local w_button_EQ = [ Pager: [
	Button: [
	    name: 'render_trans_eq',
	    text: '=',
	    font: 'mediumBold',
	    extendH: 1,
	    onTrigger: 'return',
	    bubbleHelp: bhelp.render_trans_EQ
	],
	Button: [graphics: ico(1)]	// space-holder
    ]];

    local rtype_bname = tok_cat ['render_type_', totok igen 5];

    local function w_hbox_Rtype []
	local i, H = [];
	local fg = rep ['none', 5];
	fg[rtype_org] = 'highlight';
	for i = 1, 5 loop
	    H(i) = [ Button: [
		name: rtype_bname(i),
		extendH:1,
		graphics: ico(i),
		foreground: fg(i),
		onTrigger: 'return',
		bubbleHelp: rtype_help(i)
	    ]];
	endloop
	return cat H;
    endfunction

    local wkey = WindowCreate [
	name: 'ph4_render_shell',
	mode: 'popup', location: location, mouseoutUnmap: 0,

	Hbox: w_hbox_Rtype [],

	Hbox: cat [
	    [extendH:1],
	    [flushLeft:1],
	    [Slider: [
		name:'render_trans',
		title: 'T:',
		flushLeft: 1,
		width: 1,
		extendH:1,
		range: [0,255,1],
		value: round (add trans_org * invz length trans_org),
		onTrigger: 'return',
		bubbleHelp: bhelp.render_trans
	    ]],
	    cat select [[w_button_EQ], [[]], trans_ismixed]
	],

	Hbox: [
	    extendH:1,
	    // title: 'Color:',
	    Color: [
		name: 'render_color',
		value: wcolor color_org,
		minWidth: 2,
		extendH: 1,
		transparency: 0,	// put T into material widget
		onTrigger: 'return',
		bubbleHelp: bhelp.render_color
	    ],
#ifnot RESET_TO_DEFAULT
	    Button: [
		name: 'render_color_A',
		text: 'D',
		bubbleHelp: bhelp.render_color_A
	    ],
#endif
	    Material: [
		name: 'render_mat',
		extendH: 1,
		// transparencyEnable: 1,
		// frontbackEnable: 1,
		autoApply: 1,
		value: first mat_org,
		materialColor: select [MAT_SAME, MAT_DIFF, eqL mat_org],
		onTrigger: 'return',
		bubbleHelp: bhelp.render_material
#if RESET_TO_DEFAULT_2
	    ],
	    Pager: [
		Button: [
		    name: 'render_reset',
		    text: 'D',
		    bubbleHelp: bhelp.render_default,
		    font: 'mediumBold',
		    extendH: 1,
		    sensitive: 0,
		    onTrigger: 'return'
		],
		Button: [graphics: ico(1)]	// space-holder
#endif
	    ]
#ifnot RESET_TO_DEFAULT_2
	],
	Button: [
	    name: 'render_reset',
#if RESET_TO_DEFAULT
	    text: 'Default',
	    bubbleHelp: bhelp.render_default,
#else
	    text: 'Reset',
	    bubbleHelp: bhelp.render_reset,
#endif
	    extendH: 1,
	    sensitive: 0,
	    onTrigger: 'return'
#endif
	]
    ];

    // WindowSetData [wkey, [
	// render_color: color
	// render_type: type_x
	// render_type_b: rtype
// !!! material widget settings
    // ]];

    WindowShow wkey;

    local dirty = 0;
#if RESET_TO_DEFAULT
    local val_reset = [rbits_def, color_def, trans_def, mat_def];
#else
    local val_reset = [rbits_org, color_org, trans_org, mat_org];
#endif
    loop
	    // Determine whether or not the current values represent the
	    // values set by render_reset ("D"/"Default"/"Reset") button.

	local val_same = eqL [val_reset, [
	    bitand [RMASK_ALL, DD_gbits | m],
	    DD_color | m,
	    first GTransparency (DD_gkey | m),
	    first GMaterialTSGB (DD_gkey | m)
	]];

	WindowSetAttr [wkey, [render_reset: [
	    sensitive: not val_same
#if RESET_TO_DEFAULT_2
	    , foreground: select ['highlight', 'none', val_same]
#endif
	]]];

	if not val_same then QUE_qdataOK = 0;
	elseif not QUE_qdataOK then qdata_Sync[];
	endif
	QUE_changed = select [que_changed, 1, val_same];
	update_ph4title pkey;

	    // Wait for the next trigger.

	local [v,trig] = WindowWait wkey;
	local k, t;
	local A = [];

	    // External update (from main event loop, after the change
	    // requested by trig_render_popup trigger is done.)

	if trig == 'trig_update' then
	    continue;

	    // Set all selected objects to the (same) given color.

	elseif trig == 'render_color' then
	    local v_color = v.(trig);
	    if v.(trig) == colorCancel then v_color = color_org; endif
	    WindowTrigger [pkey, [trig_render_popup:[wkey,'color',v_color]]];

#ifnot RESET_TO_DEFAULT
	    // Automatic assignment of feature/volume color

	elseif trig == 'render_color_A' then
	    WindowSetData [wkey, [render_color: wcolor color_def]];
	    WindowTrigger [pkey, [trig_render_popup:[wkey,'colorA',color_def]]];
#endif

	    // Change the average value of the (front&back) tranparency of
	    // the sel.objects.  The relative transparency is preserved.
	    // !!! The formula needs fixing.

	elseif trig == 'render_trans' then
	    t = [v.(trig), trans_org];
	    WindowTrigger [pkey, [trig_render_popup: [wkey, 'trans', t]]];

	    // Set the (front&back) tranparency of the sel.objects to
	    // the same value.

	elseif trig == 'render_trans_eq' then
	    t = round avg first GTransparency (DD_gkey | m);
	    WindowTrigger [pkey, [trig_render_popup: [wkey, 'trans_eq', t]]];
	    WindowSetData [wkey, [render_trans: [t]]];
	    WindowSetAttr [wkey, [render_trans_eq: [
		foreground: 'highlight',
		sensitive: 0
	    ]]];
	    WindowSetData [wkey, [render_trans: t]];

	    // Set the (same, front&back) material of the sel.objects.

// Save material property!!!
	elseif trig == 'render_mat' then
	    GSetMaterialTSGB [DD_gkey | m, [first v.(trig)]];
	    WindowSetAttr [wkey, [render_mat: [materialColor: MAT_SAME]]];

	    // Set the rendering type of the sel.objects.

	elseif k = indexof [trig, rtype_bname] then
	    WindowTrigger [pkey, [trig_render_popup: [wkey, 'rtype', k]]];
	    A = tag [rtype_bname, [[foreground:'none']]];
	    A.(rtype_bname(k)).foreground = 'highlight';

	    // Reset all rendering properties of the sel.objects to
#if RESET_TO_DEFAULT
	    // their default values.
#else
	    // their values at the time of the popup.
#endif

	elseif trig == 'render_reset' then
	    local [rbits, color, trans, mat] = val_reset;

	    WindowTrigger [pkey, [trig_render_popup: [wkey, 'reset', [
		m, rbits, color, trans, mat
	    ]]]];

	    A = tag [rtype_bname, [[foreground:'none']]];
	    for k in rtype_org loop
		A.(rtype_bname(k)).foreground = 'highlight';
	    endloop

	    A.render_color.value	= wcolor color;
	    A.render_mat.materialColor	= select [MAT_SAME, MAT_DIFF, eqL mat];
	    A.render_trans.value	= add trans * invz length trans;
	    if neL trans then
		WindowSetAttr [wkey, [render_trans_eq: [
		    foreground: 'none',
		    sensitive: 1
		]]];
	    endif
	endif

	A.ph4_render_shell.mouseoutUnmap = 1;
	WindowSetAttr [wkey, A];
    endloop
endfunction

// === WindowCall Methods ==================================================

// GetQdata returns the current contents of the query.
// It is called from ph4 search and ph4_EditorGetData via WindowCall.

local function GetQdata [wkey, data] = qdata_Get[];

// SetQdata sets the current contents of the query.
// It is called from ph4_EditorSetData via WindowCall.

local function SetQdata [wkey, val]
    local [qdata, err] = ph4_QdataValidate [val];
    if isnull qdata then return [[], err]; endif

    load_qdata [wkey, qdata];
    QUE_changed = 0;
    QUE_fplus = 1;
    update_ph4title wkey;

    return [qdata, err];
endfunction

// getph4data setph4data

// c_overlap finds the overlap between the features of the currently edited
// query and features defined by the "data" argument.  The function returns
// a laminated pairs of indices of overlapping features, [query_ids, data_ids].
// Note: called by "LoadSelected" in Consensus.

local function c_overlap [wkey, data]
    local n = length data.rad;
    if anyfalse [n, DF_count] then return [[],[]]; endif

    local posA = tr data.pos;					// A:consensus
    local radA = data.rad;
    local posB = apt keep [[DD_x, DD_y, DD_z], DF_count];	// B:query
    local radB = keep [DD_r, DF_count];
    local maxrad = max [max radA, max radB, 0.1];

    local pkey = prox_open [maxrad, posA, radA];
    local [seg, idx] = prox_find [pkey, posB, radB];	// #seg=#B, idx:1..#A
    prox_close pkey;

    return [stretch [x_id radB, seg], idx];
endfunction

// c_append appends features defined by the "data" argument
// to the features of the currently edited ph4 query.
// Note: called by "LoadSelected" in Consensus.

local function c_append [wkey, data]
    local n = length data.rad;
    if not n then return[]; endif

    clear_listsel[];
    local pos = tr data.pos;
    local rad = data.rad;
    local expr = data.expr;
    local color = auto_color expr;

    local k = iadd [igen n, length DD_expr];
    DD_atom[k] = 0;
    DD_gkey[k] = GOpenQueN n;

    DD_svalXxx[k] = expr2xxx expr;
    ensure_Xxx length DD_expr;
    DD_sval = T_put [DD_sval, k, 1];
    DD_rval = T_put [DD_rval, k, 1];
    DD_mval = T_put [DD_mval, k, 0];

    DD_expr[k] = expr;
    DD_x[k] = pos(1);
    DD_y[k] = pos(2);
    DD_z[k] = pos(3);
    DD_r[k] = rad;
    DD_color[k] = color;
    DD_ebits[k] = 0;		// 1=essential
    DD_gbits[k] = GOBJ_DEFDENSITY;	// low density, line, long offset text
    DD_sel[k] = 1;
    DD_usel[k] = 0;
    DD_ufold[k] = 0;
    DD_umask[k] = 0;
    GetSet_DD cat [igen DF_count, rot [drop [x_id DD_x, DF_count], n]];
    DF_count = iadd [DF_count, n];

    ensure_que_dummies 0;		// ensure DD_atom handles valid
    aSetSelected [keep [DD_atom, DF_count, -n], 1];

	// Update windows widgets (list & buttons) and 3D query rendering
	// If the Query Rendering window is open, update the
	// set of diplayed parameters for the "Selected" items.

    setall_from_DDnDC wkey;
endfunction


// === Main Panel ==========================================================
// The editor panel control

// Defaults for the editor panel

// RC_scheme
const OPT_DEFAULT = [
    // scheme:	'PCH'
    // scheme:	'Unified'
     //scheme:	'EHT'
    //scheme: 'PCHD'
];

local function query_editor [fn, opt, t1]
    local d = dvar_open[]; dvar_lock d;
    task_send [-t1, d, 2];

    coldinit[];
    opt = tagcat [opt, OPT_DEFAULT];
    local scheme = opt.scheme;
    if not ph4_SchemeOK[] then scheme = first ph4_SchemeList[]; endif // first = Unified, second = EHT

    local qdata = [];
    local err;

	// If fn specifies a query, set fn to qdata of that query.
	// - Null vector means "empty initial query"
	// - A scalar fn should be a valid input to "fread_PH4", i.e.
	//   a file name/handle or an editor name/key or query (API) key.
	// - Otherwise, fn should be in the format of qdata.

    if isnull fn then			// empty initial query
    elseif isscalar fn then		// fn = file name
	if _fdate fn then fn = [fn, [], [header:1]]; endif
	[qdata, err] = task_call ['fread_PH4', fn, [errmsg:'ignore']];
	if tok_length err then
	    Warning twrite ['Input: {}', qdata];
	    fn = qdata = [];
	elseif tok_length (fn = _fname first fn) then
	    QUE_fname = _fenvname fn;
	endif
    else
	qdata = fn;
    endif

	// If the initial query has been specified, validate it.
	// If the query is invalid, complain and then treat it as empty.

    if length qdata then
	[qdata, err] = ph4_QdataValidate [qdata];
	if isnull qdata then
	    Warning twrite ['Input: {}', err];
	else
	    scheme = qdata.S.scheme;
	endif
    endif

	// Ensure that scheme extracted from OPT_DEFAULT/opt/qdata.S
	// is valid.

    if not ph4_SchemeOK scheme then
	if allfalse scheme then
	    exit 'Scheme specification missing';
	else
	    if not isscalartok scheme then scheme = twrite['{v}',scheme]; endif
	    scheme = ftrimname [scheme, 10];
	    exit twrite ['Scheme does not exist: {"\'}', scheme];
	endif
    endif

	// If the initial query has not been specified, set scheme from the opt
	// parameter (with default=PCH)

    if isnull qdata then			// if fn not used
	if isnull scheme then scheme = first SCHEME_list; endif	// safety
	qdata = ph4_QdataInit scheme;
	// qdata = [S:[scheme:scheme]];	// default "empty" qdata
	// [qdata, err] = ph4_QdataValidate [qdata]; // fill missing components
	// if isnull err then E_BUG[]; endif
    endif

	// Create and initialize the main editor panel
	// Attempt to initialize to the requested scheme; if that
	// fails, default to PCH.

    local v, trig, wkey = create_ph4q_panel [];
    WIN_key = wkey;

    WindowSetData [wkey, [
	eD_svalType: 'Acc', // !!! get default from the scheme instead!
	scheme: scheme
    ]];

    WindowSetAttr [wkey, [
	msize_sign: [sensitive: 0],
	constrain_sourceatoms: [sensitive: 0],
	eD_useRval_p: [page: inc SVAL_useRval]
    ]];

	// If the editor is started from a search window (whose key has
	// been passed in opt.search_wkey), initialize the data containers
	// in the search window with the window key and the task id of the
	// the editor and send the "sigwind" signal to the search task to
	// indicate that the editor is up a running.

    if WIN_SEARCH_key = add WindowKey opt.search_wkey then
	WindowSetData [WIN_SEARCH_key, [
	    // edit_tid: task_id[],
	    edit_wkey: wkey
	]];
	task_kill opt.sigwind;
    endif

    if isscalartok opt.dbfile then
	SEARCH_fn = opt.dbfile;	// db file name for ph4 search
    endif

	// Start rendering of the query and the annotation points

    local i, k, m, idx, a, tk, c;
    local rad, arad, crad, matchsize, rfn, wfn;

    task_prio 0;
    load_qdata [wkey, qdata];
    WindowSetAttr [wkey, [eD_useRval_p: [page: inc SVAL_useRval]]];
    setattr_ligrec wkey;
    setattr_quebutton wkey;

    QUE_changed = 0;
    update_ph4title wkey;
    QUE_saved_data = qdata_Get [];

	// If opt.consensus, start with the Consensus panel open.
    if anytrue opt.consensus then WindowTrigger [wkey, [consensus:[]]]; endif

    // sleep 0.05;			// let the update proceed
    WindowShow wkey;
    local waiting_tid = 0, ltcode;
    local val;
    local pmsg, cmsg;
    local tdata;

	// Tell the top-level caller that the editor window is ready.

    dvar_unlock d; dvar_close d;
    local FTBL = [
	GetQdata:	#GetQdata,
	SetQdata:	#SetQdata,
	UndoCtrl:	#UndoCtrl,
	c_overlap:	#c_overlap,
	c_append:	#c_append
    ];

    local tm_opt = dvar_open[];
    local warg = [ftbl: FTBL, timeout: [1.3, #monitor, tm_opt]];

    usnap[];

	// Main event loop

    loop
	const POPT = [master:'parent',statics:'share',creator:'detach',idle:1];
	local tid, tcode, stask, targ;

	[v,trig] = WindowWait [wkey, warg];

	local nF = iadd keep [DD_sel, DF_count];
	local nV = iadd drop [app anytrue DD_sel or DD_usel, DF_count];
	local nC = iadd DC_sel;

	    // Closing the editor: if the query has changed, offer to
	    // save the query first

	if v.(trig) === 'Close' then
#if NO_WIN_QUIT_MSG
	    exit[];
#endif
	    DS_title = v.que_title;
	    if eqL [QUE_saved_data, qdata_Get[]] then exit[];
	    elseif [DD_expr, DC_expr] === [[],[]] then	exit[];
	    endif
	    [tid, tcode] = task_wfork [master: 'parent'];
	    if tcode == 'child' then
		qdata = qdata_Get[];
		if YesNoCancel WIN_QUIT_MSG then
		    wfn = FilePrompt [
			title: 'Write Query File',
			mode: 'saveAs',
			name: token QUE_fname,
			// filter: '*.ph4'
			filterList: ['', 'Pharmacophores (*.ph4)\t*.ph4'],
			filterIndex: 2,
			autoExtension: 'ph4'
		    ];
		    if isnull wfn then
			exit[];	// kill myself -> parent continues
		    else
			exit[];
		    endif
		endif
		QUE_saved_data = qdata;
		QUE_changed = 0;
		task_kill tid;	// kill the parent -> quit
	    endif

	    // Query title

	elseif trig === 'que_title' then
	    cSetHeader [ph4que_chain[], DS_title = v.que_title];
	    if WIN_SEARCH_key then update_search_window WIN_SEARCH_key; endif
	    QUE_changed = 1;
	    QUE_qdataOK = 0;
	    update_ph4title wkey;
	    usnap 'que_title';

	    // Pharmacophore annotation scheme

	elseif trig == 'scheme' then
	    if neL [SCHEME_list, SCHEME_list = ph4_SchemeList 1] then
		WindowSetAttr [wkey, [scheme: [text: SCHEME_list]]];
		if m_diff [v.scheme, SCHEME_list] then
		    v.scheme = first SCHEME_list;
		endif
		WindowSetData [wkey, [scheme: v.scheme]];
	    endif
	    change_scheme [wkey, v.scheme];
	    update_lig_annotation 2;	// Update
// !!!
	    // set_edit_page wkey;		// Update expr. shortcut
	    setall_from_DDnDC wkey;
	    usnap '';	// no telescoping

	    // Click: Create "Show..." popup.
	    // SHIFT-Click: Change the default scheme.

	elseif trig == 'scheme_info' then

		// Unshifted click: open #scheme_info_window popup.

	    if not bitand [v.(trig), WMOD_SHIFT] then
		targ = [master: 'parent', title: '! PH4:SchemeInfo'];
		if second task_fork targ <> 'child' then continue; endif
		scheme_info_window [wkey, trig];
		exit[];
	    endif

		// Note: MOE default scheme ordering:
		// []: current: -1: -std, -2: w/RC:ph4scheme.list.prefix only

	    local ds_user = first ph4_SchemeList 1;	// user's default
	    local ds_moe1 = first ph4_SchemeList -1;	// MOE -std default
	    local ds_moe2 = first ph4_SchemeList -2;	// MOE default

		// If this is the default scheme, tell the user.
		// If the user's default is different from MOE default.

	    if eqL [SCHEME_name, ds_user, ds_moe1] then
		Warning twrite ['{} is the default scheme.', ds_user];
		continue;
	    elseif eqL [SCHEME_name, ds_user] then
		if not NoYes twrite [
		    '{} is your default scheme.\n\n'
		    'MOE default scheme is {}.\n'
		    'Do you wish to change the default\n'
		    'scheme back to {}?',
		    ds_user, ds_moe1, ds_moe1
		] then
		    continue;
		elseif eqL [ds_moe1, ds_moe2] then
		    ph4_SchemeSetDefault '';
		else
		    ph4_SchemeSetDefault ds_moe1;
		endif
	    else
		if not YesNo twrite [
		    'Change the default scheme from {} to {}?',
		    ds_user, SCHEME_name
		] then
		    continue;
		endif
		ph4_SchemeSetDefault SCHEME_name;
	    endif

		// Update window to reflect new default.

	    SCHEME_list = ph4_SchemeList 1;	// 1=force to recalculate
	    WindowSetAttr [wkey, [scheme: [
		text: SCHEME_list,
		value: SCHEME_name
	    ]]];

		// If the current scheme is the new default scheme,
		// highlight it (in red) for a short while (3 sec).

	    if eqL [SCHEME_name, ds_user] then continue; endif
	    WindowSetAttr [wkey, [scheme: [foreground: DARK_RED]]];

	    if second task_fork [] <> 'child' then continue; endif
	    sleep 3;
	    WindowTrigger [WindowKey wkey, [trig_scheme_FG: 0]];
	    exit[];
	    continue;

	elseif trig == 'trig_scheme_FG' then
	    WindowSetAttr [wkey, [scheme: [foreground: 'none']]];

	    // Query comment in popup.

	elseif trig == 'comment' then
	    task_call [#comment_popup, [wkey, [wkey, trig, 31]], POPT];

	    // Respond to trigger on "OK" in #comment_popup.

	elseif trig == 'trig_comment' then
	    local str = v.(trig);
	    if eqL [DS_comment, DS_comment = str] then continue; endif
	    DS_comment = str;
	    QUE_changed = 1;
	    QUE_qdataOK = 0;
	    WindowSetAttr [wkey, [commentP: [foreground:
		select ['baseBlue', 'none', anyfalse isspace DS_comment]
	    ]]];

	    update_ph4title wkey;
	    usnap '';	// no telescoping

	    // QUE_changed = 1;	// search panel unaffected

	elseif trig == 'consensus' then
	    targ = [master: 'parent', title: '! PH4:Consenus'];
	    if second task_fork targ <> 'child' then continue; endif
	    call_consensus [
		editor_wkey:wkey,
		editor_id:EDITOR_id,
		scheme: SCHEME_name,
		scheme_mask: scheme_mask SCHEME_name
	    ];
	    exit[];

	    // Pick up the window key of the consensus panel, sent back
	    // by ph4_consensus as the value of a 'CONS_wkey' trigger.

	elseif trig == 'CONS_wkey' then
	    CONS_wkey = v.(trig);

	    // Undo last change made to the ph4 query.

	elseif trig === 'undo' then
	    // Warning 'Undo not yet implemented';
	    undo[];

	    // Redo last undone change.

	elseif trig === 'redo' then
	    // Warning 'Redo not yet implemented';
	    redo[];

	    // Create query items: feature, constraint, volume, union

	elseif trig === 'create_F' then
	    // create_feature [wkey, 0];	// centroid=0
	    create_feature [wkey, bitand [v.(trig), WMOD_SHIFT]];
	    check_query wkey;
	    usnap '';

	    // Create a volume of specific type.  Use the current machinery:
	    // create a default volume, then set it to the correct type.
	    //  Excluded volume (no matching atoms inside)
	    //  Occupied volume (at least one heavy matching atom inside)
	    // "Ligand shape": Bounding volume (all matching atoms inside)

	elseif trig === 'create_volume' then
	    task_call [#volume_popup, [wkey, [wkey, trig, 71]], POPT];

	elseif trig === 'trig_volume' then
	    k = abs v.(trig);
	    if m_diff [k, [1,2,3]] then E_BUG[]; endif

	    // create_volume [wkey, tag [whichvol, 1]];	// centroid=1
	    // create_union [wkey, tag [whichvol, 1]];	// centroid=0
	    create_union [wkey, V_EBITS(k), v.(trig) < 0];
	    WindowSetData [wkey, [eD_volumetype: v.eD_volumetype = k]];

#if 0
		// Volume type: 0x0 excl, 0x2 bd (lig shape), 0x4 occ

	    m = DD_usel or app anytrue DD_sel;	// selected items
	    m | x_id m <= DF_count = 0;		// affect volumes only
	    DD_ebits | m = bitor [
		bitand [DD_ebits | m, bitnot V_EBITMASK],
		V_EBITS(k)
	    ];
	    setall_from_DDnDC wkey;
#endif
	    usnap '';

	elseif trig === 'constrain' then
	    if add keep [get_listsel[], DF_count] < 2 then
		Warning
		    'Constraints apply only to features.\n'
		    'Select at least 2 features in the list.'
		;
		continue;
	    endif

		// Can't create constraint if have selected volumes.
		// If have a single constraint selected, plus
		// features, then redefine that constraint.

	    if add drop [get_listsel[], DF_count] > 0 then
		if nV > 0 then
		    Warning 'Only features can be constrained.';
		    continue;
		endif

		if nC <> 1 then
		    Warning'Only a single constraint can be edited at at time.';
		    continue;
		endif

		DC_ids | DC_sel = [x_pack keep [DD_sel, DF_count]];
		setall_from_DDnDC wkey;
		continue;
	    endif

#if 0
// XXX
	    v.eC_type = 1;
	    WindowSetData [wkey, [
		eC_type: v.eC_type,
		constrain_type: 1,
		constrain_nfeatures: 1,
		constrain_sourceatoms: 1
	    ]];
	    WindowSetAttr [wkey, [
		constrain_nfeatures: [sensitive: 1],
		constrain_sourceatoms: [sensitive: 0]
	    ]];
#endif

	    create_constraint wkey;
	    check_query wkey;
	    usnap '';

	elseif trig === 'button_group' then
	    if VOL_groupOK then		group_volumes wkey;
	    elseif VOL_ungroupOK then	ungroup_volumes wkey;
	    endif
	    usnap 'group';

	    // The selection in the (main) list.

	elseif trig === 'mainlist' then
	    k = v.mainlist;

		// Processing union header 2xclick:
		// On the first click, we start a new task, waiting_tid.
		// 1) If there is no trigger on 'mainlist' within 0.3 sec,
		//    the tasks will send the selection to 'trig_mainlist_1x'
		//    for processing.
		// 2) If there is a another trigger on 'mainlist' within 0.3s,
		//    we kill waiting_tid (thus ignoring the first click)
		//    and process just the new trigger.

		// If waiting_tid is waiting to process a previous, recent
		// click (0.3 sec), kill the waiting_tid (thus ignore the
		// previous click).

	    if waiting_tid then
		task_kill waiting_tid;
		waiting_tid = 0;
	    endif

		// If this is the first click of a potential double click
		// on a union header, postpone the processing of the click.
		// A separate task, waiting_tid, will wait for 0.3 sec.
		// If there is no 'mainlist' trigger within 0.3 sec, process
		// the first click (send to 'trig_mainlist' for execution).
		// Note: a normal double click lasts < 0.3 seconds.

	    if length k(1) <> 1 then	// not a single item
	    elseif k(2) <> 1 then	// not the first click
	    elseif length x_union_header first first k then
		[waiting_tid, ltcode] = task_fork [master:'parent', prio:0];
		if ltcode <> 'child' then continue; endif
		sleep 0.3;		// double click delay
		WindowTrigger [wkey, [trig_mainlist: k]];
		// mainlist_select [wkey, k];
		exit[];
	    endif

	    mainlist_select [wkey, k];

		// If this is a double click on a constraint,
		// the constraint features are added to the list selection.

	    if k(2) <> 1 then
		if nC==1 and not nV then
		    k = igen DF_count;
		    DD_sel[k] = m_join [k, cat (DC_ids | DC_sel)];
		    setall_from_DDnDC wkey;
		endif
	    endif

	    usnap 'sel';

	    // Process recent 'mainlist' click, postponed by waiting_tid.

	elseif trig === 'trig_mainlist' then
	    k = v.mainlist;
	    if eqL [k, v.(trig)] then		// safety
		mainlist_select [wkey, k];
		usnap 'sel';
	    endif

	    // Process key triggers

	elseif m_join [trig, KEY_TRIGGER] then

	    if v.(trig) === 'mainlist' then
		tdata = [];

		    // List keyboard triggers:
		    // Up:	Change list selection to the item above
		    //		the uppermost currently selected list item.
		    // Down:	Change list selection to the item below
		    //		the lowermost currently selected list item.
		    // Shift+Up: Move the selected item up the list (decrement
		    //		its relative rank.
		    // Shift+Down: Move the selected item down the list.
		    // Ctrl+A:	Select all items.
		    // ESC:	Deselect all items.
		    // Del:	Delete selected items.  Prompt first.
		    // Shift+Del: Delete selected items.  Don't prompt.

		if trig == 'Shift+Up' then		// move item up
		    tdata = [button_up: 0];
		elseif trig == 'Shift+Down' then	// move item down
		    tdata = [button_down: 0];
		elseif trig == 'Del' then		// del item
		    tdata = [trig_delete: 0];	// !!! fix WTrigger&&use btn_del
		elseif trig == 'Shift+Del' then		// del item/no prompt
		    tdata = [trig_delete: WMOD_SHIFT];	// !!! use button_delete
		elseif trig == 'Ctrl+Z' then
		    tdata = [undo: 0];
		elseif trig == 'Ctrl+Y' then
		    tdata = [redo: 0];
		endif

		if anytrue tdata then
		    WindowTrigger [wkey, tdata];
		    continue;
		endif

		local sidx = first v.mainlist;
		local nidx = add LIST_seg;

		if trig == 'Ctrl+A' then	// select all
		    sidx = igen nidx;
		elseif trig == 'ESC' then	// select none
		    sidx = [];
		elseif trig == 'Up' then	// select line above
		    if allfalse sidx then sidx = 1; endif
		    sidx = max [1, dec min sidx];
		elseif trig == 'Down' then	// select line below
		    if allfalse sidx then sidx = nidx; endif
		    sidx = min [nidx, inc max sidx];
		else
		    E_BUG [];
		endif

		WindowSetData [wkey, [mainlist: sidx]];
		mainlist_select [wkey, [sidx,1]];
		usnap '';
	    endif

	    // Reorder items.

	elseif trig == 'button_up' then
	    move_up_down [wkey, 1];
	    usnap 'reorder';

	elseif trig == 'button_down' then
	    move_up_down [wkey, 0];
	    usnap 'reorder';

	    // Delete items: Keyboard delete key or 'X' button.

	elseif trig == 'button_delete' or trig == 'trig_delete' then
	    //if PROMPT_DELETE then
		//if bitand [v.(trig), WMOD_SHIFT] then
		//elseif cancel_delete m then continue;
		//endif
	    //endif
	    delete_selected wkey;

		// If the number of features decreased below the minimum
		// match size, put up warning color.

	    check_query wkey;
	    usnap '';

	    // Create meters between selected items

	elseif trig == 'button_meters' then
	    local _a = cat DD_atom | cat orE [DD_sel, DD_usel];
	    _a = _a | oType _a == 'atom';
	    _a = _a | not aHidden _a;

	    local [M_key, M_type, M_atoms] = Meters[];
	    // !!!
	    m = app andE (oParent oParent M_atoms == ph4que_chain[]);

	    local curr_mkeys = M_key | M_type == 'distance' and m;
	    local curr_meters = Meters curr_mkeys;

		// If there are meters on all the currently selected
		// atoms, then remove all meters.  Else replace the
		// current meters (remove the existing).

	    local meter_atoms = uniq cat last curr_meters;
	    local meter_exists = sort _a ===  sort meter_atoms;

	    if not allfalse meter_atoms and anytrue meter_exists then
		MeterDestroy curr_mkeys;
		continue;
	    endif

	    if length _a < 2 then
		Warning
		    'Meters are drawn between features and volumes.\n'
		    'Select two non-hidden features and/or volumes.'
		;
		continue;
	    endif

	    const TOO_MANY = 5;

	    if length _a > TOO_MANY then
		if not NoYes twrite [
		    'More than {} features and/or volumes are selected.\n'
		    'Meters will be drawn between all pairs.  Continue?',
		    TOO_MANY
		] then
		    continue;
		endif
	    endif

	    MeterDestroy curr_mkeys;

	    // _update_dcsel[];
	    a = cat DD_atom | cat orE [DD_sel, DD_usel];
	    a = a | oType a == 'atom';
	    a = a | not aHidden a;
	    if length a < 2 then continue; endif
	    m = a < [a];			// m_of all pairs (w/o dup-s)
	    MeterCreate ['distance', tr app cat [a || m, [a] || m]];

	    // Feature of volume expression

	elseif m_findmatch ['eD_type*', trig] then
	    c = v.eD_type;

	    local errmsg = '', svalXxx = '';

		// If there are no selected features, check volumes.

	    if allfalse keep [DD_sel, DF_count] then
		c = ph4_ExprCleanupV c;
		errmsg = ph4_ExprCheckSyntaxV c;

		// If there are no selected volumes, check features.

	    elseif allfalse [drop [DD_sel, DF_count], DD_usel] then
		c = ph4_ExprCleanupF [c, SCHEME_type];
		errmsg = ph4_ExprCheckSyntaxF [c, SCHEME_type, SCHEME_tcode];
		if SCHEME_svalOK then if allfalse errmsg then
		    svalXxx = expr2xxx c;
		endif endif

		// If there are selected (both) features and volumes, complain.

	    else
		errmsg = 'Cannot set same expression for '
		    'both features and volumes.';
		continue;
	    endif

	    if tok_length errmsg then
		Warning errmsg;
		continue;
	    endif

	    tval_set [wkey, [eD_type: c]];
	    m = DD_usel or app anytrue DD_sel;
	    DD_expr | m = c;
	    DD_svalXxx | m = svalXxx;
	    if USE_AUTOBIT then
		m | m = bitand [DD_gbits | m, 0x40];
		if anytrue m then	// recolor auto-colored objects
		    DD_color | m = auto_color c;
		endif
	    endif
	    setall_from_DDnDC wkey;
	    usnap 'exprD';

	    // The essential bit of a feature

	elseif trig == 'eD_essential' then
	    m = DD_usel or app anytrue DD_sel;	// selected items
	    m | x_id m > DF_count = 0;		// affect features only
	    // m|m = pack m and bitand [DD_ebits|m, 0x1] <> v.eD_essential;
	    // DD_ebits = bitxor [DD_ebits, m];	// flip the bits
	    m | m =
		not bitand [DD_ebits | m, EBIT_ESSENTIAL] <> not v.eD_essential;
	    DD_ebits | m = bitxor [DD_ebits | m, EBIT_ESSENTIAL];
	    setall_from_DDnDC wkey;
	    usnap 'exprD';

	    // Volume type: 0x0 excl, 0x2 bd (lig shape), 0x4 occ

	elseif trig == 'eD_volumetype' then
	    if v.eD_volumetype > length V_EBITS then continue; endif
	    m = DD_usel or app anytrue DD_sel;	// selected items
	    m | x_id m <= DF_count = 0;		// affect volumes only
	    DD_ebits | m = bitor [
		bitand [DD_ebits | m, bitnot V_EBITMASK],
		V_EBITS(v.eD_volumetype)
	    ];
	    setall_from_DDnDC wkey;
	    usnap 'exprD';

	    // !!! (ms) somebody tried to replace the eD_ignore checkbox with
	    // a set of buttons but did not follow through.  As a result,
	    // the "ignore" checkbox is now called "button_ignore" and
	    // "eD_ignore" is a strange Data widgets.  Needs a cleanup!

	elseif m_join [trig, ['button_ignore','list_button_ignore']] then
	    m = DD_usel or app anytrue DD_sel;	// selected items
	    m | m = not bitand [DD_ebits | m, EBIT_IGNORED] <> v.eD_ignore;

	    DD_ebits | m = bitxor [DD_ebits |m, EBIT_IGNORED];

		// If there were selected features/volumes, then toggle.
		// If there were none, then re-initialize to 0.

	    if anytrue m then
		WindowSetData [wkey, [eD_ignore: not v.eD_ignore]];
	    else
		WindowSetData [wkey, [eD_ignore: 0]];
	    endif

		// If there were selected constraints, then toggle.
		// If there were none, then re-initialize to 0.

	    m = DC_sel;
	    m | m = not bitand [DC_ebits | m, EBIT_IGNORED] <> v.eC_ignore;

	    DC_ebits | m = bitxor [DC_ebits | m, EBIT_IGNORED];

	    if anytrue m then
		WindowSetData [wkey, [eC_ignore: not v.eC_ignore]];
	    else
		WindowSetData [wkey, [eC_ignore: 0]];
	    endif

	    check_query wkey;
	    setall_from_DDnDC wkey;
	    set_edit_page wkey;
	    usnap 'exprD';

	elseif trig == 'eD_hidefeat' then

	    m = DD_usel or app anytrue DD_sel;	// selected items
	    if allfalse m then m = m_id m; endif
	    if bitand [v.(trig), WMOD_SHIFT] then
		DD_gbits | m = bitand [DD_gbits | m, bitnot GBIT_HIDDEN];
	    else
		DD_gbits | m = bitxor [DD_gbits  |m, GBIT_HIDDEN];
	    endif

	    setall_from_DDnDC wkey;
	    // ensure_lig_dummies 1;	// update DL_atom visibility
	    set_edit_page wkey;
	    usnap 'exprD';

	    // Feature/volume color

	elseif trig == 'button_render' then
	    task_call [#render_popup, [wkey, [wkey, trig, 31]], POPT];

// !!! if  the render_popup panel dies before the query has time
// to re-generate itsef, the update gets permanently crippled
// The calculation needs to be done in a separate (perhaps deletable)
// task that sends it results to the main event loop with a trigger.
// The main event loop then (quickly) updates the gobj's (and the statics?).


	elseif trig == 'trig_render_popup' then
	    m = DD_usel or app anytrue DD_sel;	// selected items
	    if allfalse m then m = m_id m; endif
	    local pkey = v.(trig)(1);
	    local cmd = v.(trig)(2);
	    local cval = v.(trig)(3);
	    if cmd == 'color' then
		// !!! update colors of the dummies
		DD_color | m = cval;
	    elseif cmd == 'colorA' then
		if length cval == add m then
		    DD_color | m = cval;
		endif
	    elseif cmd == 'trans' then
		// local t = first GTransparency (DD_gkey | m);
		// GSetTransparency [DD_gkey | m, [t + (cval - round avg t)]];

		if length cval(2) == add m then
		    GSetTransparency [DD_gkey | m, [adjust_trans cval]];
		endif
	    elseif cmd == 'trans_eq' then
		GSetTransparency [DD_gkey | m, [cval]];
	    elseif cmd == 'mat' then
	    elseif cmd == 'rtype' then
		// DD_gbits | m = RTYPE_GBITS(cval);
		DD_gbits | m = bitand [bitnot RMASK_ALL, DD_gbits | m];
		DD_gbits | m = bitor [RTYPE_GBITS(cval), DD_gbits | m];
	    elseif cmd == 'reset' then
		if eqL [cval(1), m] then
		    DD_gbits | m = bitand [bitnot RMASK_ALL, DD_gbits | m];
		    DD_gbits | m = bitor [cval(2), DD_gbits | m];
		    DD_color | m = cval(3);
		    GSetTransparency [DD_gkey | m, [cval(4)]];
		    GSetMaterialTSGB [DD_gkey | m, [cval(5)]];
		endif
	    endif
	    set_edit_page wkey;
	    draw_que_features [];
	    usnap 'render';
	    WindowTrigger [WindowKey pkey, [trig_update: 1]];

	    // !!! update visibility of the dummies
	    // QUE_changed = 1;

#if 0
	    // !!! Material properties need to be saved.

	elseif trig == 'eD_render_mat' then

		// Save material property!!!

		// Set the material properties of the selected items.
		// !!! draw_que_features[] needs to be updated

#endif
#if 0
	    // Automatic assignment of feature/volume color

	elseif trig == 'eD_color_auto' then
	    m = DD_usel or app anytrue DD_sel;	// selected items
	    DD_color | m = auto_color (DD_expr | m);
	    set_edit_page wkey;
	    draw_que_features [];
	    // !!! update colors of the dummies
	    QUE_changed = 1;
#endif


	    // Feature/volume radius

	elseif m_findmatch ['eD_R_*', trig] then
	    m = DD_usel or DD_sel;
	    if allfalse m then continue; endif

		// Synchronize the two coupled widgets (text+wheel)

	    if trig == 'eD_R_set' then
		rad = cat DD_r | cat m;
		if neL rad then
		    rad = add (rad * invz length rad);
		    rad = round (rad * 1e1) * 1e-1;		// round to .1
		    DD_r || m = lhs [rad, DD_r || m ];
		else
		    rad = max rad;
		endif
	    else
		rad = v.(trig);
	    endif

	    if rad < 0 then
		rad = 0;				// clamp neg. to 0
		WindowSetData [wkey, [eD_R_w: rad]];
	    elseif rad > 1e3 then
		rad = 1e3;				// clamp neg. to 0
		WindowSetData [wkey, [eD_R_w: rad]];
	    elseif trig == 'eD_R_w' then
		rad = round (rad * 1e1) * 1e-1;		// wheel: round to .1
	    elseif trig == 'eD_R_t' then
		WindowSetData [wkey, [eD_R_w: rad ]];
	    elseif trig == 'eD_R_set' then
		WindowSetData [wkey, [eD_R_w: rad]];
	    endif
	    tval_set [wkey, [eD_R_t: rad]];

		// Calculate new radii so that their average becomes rad.
		// If any of the radii is to be set negative, clamp it to 0.

	    arad = cat DD_r | cat m;
	    arad = adjust_radii [arad, rad];

		// Adjust the radii of the spheres and show the change

	    DD_r || m = split [arad, app iadd m];
	    if DIST_monitor then update_dist wkey; endif
	    draw_que_features [];
	    QUE_changed = 1;
	    QUE_qdataOK = 0;
	    update_ph4title wkey;
	    MATCH_update = 1;
	    if WIN_SEARCH_key then update_search_window WIN_SEARCH_key; endif
	    usnap 'rad';

	    // When Acc/Don on the bottom "S:" line changes, populate
	    // the values

	elseif trig == 'eD_svalType' then
	    m = DD_usel or app anytrue DD_sel;	// selected items
	    m | x_id m > DF_count = 0;		// affect features only
	    update_sval wkey;
	    // !!! setall_from_DDnDC wkey

	elseif m_findmatch ['eD_[srm]val', trig] then
	    local Xxx = v.eD_svalType;
	    m = cat [keep [DD_sel, DF_count], rep [0, DV_count]];
	    // m = DD_usel or app anytrue DD_sel;	// selected items
	    // m | x_id m > DF_count = 0;		// affect features only

	    local sval = DD_sval.(Xxx) | m;
	    local rval = DD_rval.(Xxx) | m;
	    local mval = DD_mval.(Xxx) | m;

	    if trig === 'eD_sval' then
		sval = f100 v.(trig);
		mval = sval * rval;
		DD_sval.(Xxx) = mput [DD_sval.(Xxx), m, sval];
		DD_mval.(Xxx) = mput [DD_mval.(Xxx), m, mval];
		tval_set [wkey, [
		    eD_sval: sval,
		    eD_mval: f100 avg mval
		]];

	    elseif trig === 'eD_rval' then
		rval = f100 v.(trig);
		sval = mval / rval;
		DD_rval.(Xxx) = mput [DD_rval.(Xxx), m, rval];
		DD_sval.(Xxx) = mput [DD_sval.(Xxx), m, sval];
		tval_set [wkey, [
		    eD_rval: rval,
		    eD_sval: f100 avg sval
		]];

	    elseif trig === 'eD_mval' then
		mval = f100 v.(trig);
		sval = mval / rval;
		DD_mval.(Xxx) = mput [DD_mval.(Xxx), m, mval];
		DD_sval.(Xxx) = mput [DD_sval.(Xxx), m, sval];
		tval_set [wkey, [
		    eD_mval: mval,
		    eD_sval: f100 avg sval
		]];
	    else
		E_BUG[];
	    endif

	    setall_from_DDnDC wkey;
	    usnap 'sval';

	    // Constraint type

	elseif trig == 'eC_type' then
	    DC_expr | DC_sel = CTYPE(1)(v.eC_type);
	    setall_from_DDnDC wkey;
	    usnap 'exprC';

	    // Constraint ignore

	elseif trig == 'eC_ignore' then
	    m = DC_sel;
	    m | m = not bitand [DC_ebits | m, EBIT_IGNORED] <> not v.eC_ignore;
	    DC_ebits | m = bitxor [DC_ebits | m, EBIT_IGNORED];
	    setall_from_DDnDC wkey;

	    // Set contraint visualization mode

#if SHOW_DC_OPTION
	elseif trig == 'eC_show' then
#if SHOW_DC_CONES
	    DC_gbits | DC_sel = dec v.eC_show;
#else
	    DC_gbits | DC_sel = v.eC_show;
#endif
	    setall_from_DDnDC wkey;
#endif
	    usnap 'exprC';

	    // Process constrain_ widgets on EPAGE_CONSTRAINTS.

	elseif m_findmatch ['constrain_*', trig] then

	    // Select constrained items

	    if trig == 'constrain_select' then		// 'constraint2list'
		// _update_dcsel[];
		k = igen DF_count;
		DD_sel[k] = m_join [k, cat (DC_ids | DC_sel)];

		// Constrain selected items

	    elseif trig == 'constrain_replace' then	// 'list2constraint'
		if add keep [get_listsel[], DF_count] < 2 then
		    Warning 'Select at least 2 features.';
		    continue;
		endif
		// _update_dcsel[];

		DC_ids | DC_sel = [x_pack keep [DD_sel, DF_count]];
		check_query wkey;

		// Change constraint type (radio + 2 options).

	    else
		WindowSetAttr [wkey, [
		    constrain_nfeatures: [sensitive: v.constrain_type == 1],
		    constrain_sourceatoms: [sensitive: v.constrain_type == 2]
		]];

		    // constrain_type:	1=#Features, 2=Atoms/Projections

		local ctype	= v.constrain_type;
		local cNF	= v.constrain_nfeatures;
		local cSA	= v.constrain_sourceatoms;

		v.eC_type = [cNF, cSA + N_CTYPE_NFEAT](ctype);
		WindowSetData [wkey, [ eC_type: v.eC_type ]];
		DC_expr | DC_sel = CTYPE(1)(v.eC_type);
		check_query wkey;
	    endif

	    setall_from_DDnDC wkey;
	    usnap 'exprC';

	    // Minimum match size

	elseif m_findmatch ['msize*', trig] then
	    // _update_dcsel[];

		// !!! Don't clamp the value now!  (The counts could easily
		// change between now and any search.) Just indicate a potential
		// problem with check_query.

	    // local n_ignore = add notnot bitand [0x8, DD_ebits];
	    // local n_ess    = add notnot bitand [0x1, DD_ebits];
	    // v.msize = max [1, min [v.msize, DF_count]];

	    if not leL [0, v.msize, DF_count] then
		v.msize	= select [0, DF_count, v.msize < 0];
		WindowSetData [wkey, [msize: v.msize]];
		LAST_msize	= v.msize;	// no monitor update needed
	    endif

	    DS_matchsize = msize_3to1 [v.msize_nonzero, v.msize_sign, v.msize];
	    tval_set [wkey, [msize: v.msize]];
	    check_partialmatch wkey;
	    WindowSetAttr [wkey, [
#if PARTIAL_MATCH_P
		msize_p: [page: 2- notnot v.msize_nonzero],
#endif
		msize_sign: [sensitive: v.msize_nonzero],
		msize: [sensitive: v.msize_nonzero]
	    ]];
	    check_query wkey;
	    QUE_changed = 1;
	    QUE_qdataOK = 0;
	    update_ph4title wkey;
	    MATCH_update = 1;
	    if WIN_SEARCH_key then update_search_window WIN_SEARCH_key; endif
	    usnap 'msize';

#if USE_GEAR
	elseif trig == 'config' then
	    task_call [#config, [wkey, [wkey, trig, 71]], POPT];
#endif

	    // svalXxx updates the minimum strength of Xxx to appear on
	    // the screen.

	elseif trig == 'sval_useRval' then
	    SVAL_useRval = v.(trig);
	    SetRCBoolean [RC_USE_RVAL, SVAL_useRval];

	    WindowSetAttr [wkey, [
		eD_useRval_p: [page: inc SVAL_useRval]
	    ]];
	    // !!! ??
	    setall_from_DDnDC wkey;
	    usnap 'useRval';

	    // Process triggers from the scheme info popup ("Show...")

	elseif trig == 'trig_sinfo' then	// scheme_info_window
	    [trig, v] = split [v.trig_sinfo, [1,999]];

	    if trig == 'svalMin' then		// v = ['Acc', 1.34]
		[Xxx, v] = v;
		LIG_svalMin.(Xxx) = v;
		update_lig_annotation 1;
	    endif

	elseif trig == 'trig_allrec' then
	    LIG_allrec = v.(trig);
	    update_lig_annotation [1,0,0];

	elseif trig == 'trig_use_Hs' then
	    LIG_use_Hs = v.(trig);
	    update_lig_annotation 1;

	elseif trig == 'trig_abspos' then
	    LIG_abspos = v.(trig);
	    update_lig_annotation 1;

	    // Specify what to annotate and how to annotate it:
	    // Gray: no annotation, Yellow: ann.pts only, Green: ann.pts+labels
	    // Ctrl: toggle: use/don't use H coords to place projected Don/Acc
	    // Shift: toggle: annotate all rec atoms / annotate rec pocket only

// !!!
// 1) do use R=dark-green and do NOT show rec.strength if R-strength is OFF
// 2) do use Q=dark-green if the query does not contain any Acc or Don
	    // In Ligand mode: Don't show receptor strengths.

	elseif k = indexof [trig, ['rec', 'sol', 'lig']] then	// see RSL
	    local tval = v.(trig);
	    LIG_rsl(k) = mod [
		LIG_rsl(k) - sgn [1, bitand [tval, WMOD_SHIFT]],
		3 + anytrue DL_sval		// !!! USE_DARKGREEN
	    ];

	    // WindowSetData [wkey, [ rsl:	LIG_rsl ]];
	    update_lig_annotation ([1,2,3] == k);
	    setattr_ligrec wkey;
	    if DIST_monitor then update_dist [wkey, 1]; endif

	elseif trig == 'que' then	// see RSL
	    QUE_textmode = mod [
		QUE_textmode - sgn [1, bitand [v.(trig), WMOD_SHIFT]],
		3 + (anytrue SCHEME_svalOK and anytrue DD_svalXxx)
	    ];
	    setall_from_DDnDC wkey;
	    setattr_quebutton wkey;

	    // Read in a new query

	elseif v.(trig) === 'Open...' then

		// Spawn a new task (for safety) and prompt for the filename

	    DS_title = v.que_title;
	    targ = [master: 'parent', title: '! PH4:Open'];
	    if 'child'<>second task_fork targ then continue; endif
	    rfn = FilePrompt [
		title: 'Get Query From File',
		mode: 'open',
		// filter: '*.ph4',
		name: token QUE_fname,
		filterList: ['', 'Pharmacophores\t*.ph4,*.ph4.gz'],
		filterIndex: 2,
		checkFileFcn: 'ph4_CheckFile'
	    ];
	    if isnull rfn then exit[]; endif

#if 0
		// Get the current query

	    qdata = qdata_Get[];

		// If the current query has not been saved, ask for
		// confirmation.
		// !!! The message should be more explicit about the current
		// query going to be lost!

	    if eqL [QUE_saved_data, qdata_Get[]] then	// don't ask
	    elseif [DD_expr, DC_expr] === [[],[]] then	// don't ask
	    elseif not YesNo 'Replace the current query?' then
		exit[];
	    endif

		// Read in the new query, update the scheme and display
		// the new query

	    qdata = fread_PH4 [rfn, [], [header:1]];

		// Send qdata to be loaded by the main event loop

	    WindowTrigger [wkey, [LoadData: [qdata, _fenvname rfn]]];
	    exit[];
#else
		// Read in the new query and send qdata to processed
		// by the main event loop and its task.
		// Note: the read is done here, in a separate task, so
		// that if fread_PH4 fails, the editor panel will survive.

	    qdata = fread_PH4 [rfn, [], [header:1]];
	    WindowTrigger [wkey, [trig_Open: [qdata, rfn]]];
	    exit[];

	    // Process qdata from the 'Open...' subtask.
	    // This branch only prompts the users and if all OK,
	    // sends the job to the 'LoadData' trigger.

	elseif trig === 'trig_Open' then
	    [qdata, rfn] = v.(trig);

		// If the current query has not been saved, ask for
		// confirmation.
		// !!! The message should be more explicit about the current
		// query going to be lost!

	    if eqL [QUE_saved_data, qdata_Get[]] then	// don't ask
	    elseif [DD_expr, DC_expr] === [[],[]] then	// don't ask
	    elseif not YesNo 'Replace the current query?' then
		continue;
	    endif

		// Send the qdata to be loaded on a separate trigger.
		// Note: 'LoadData' is used to load qdata on behalf of
		// other jobs, so it can't deny the load request.
		// In the future, we could change the args and merge
		// trig_Open and LoadData into one.

	    WindowTrigger [wkey, [LoadData: [qdata, _fenvname rfn]]];
#endif

	    // Load data received from the 'Open...' subtask

	elseif trig === 'LoadData' then
	    [qdata, fn] = v.(trig);
	    [qdata, err] = ph4_QdataValidate [qdata];
	    if isnull qdata then Warning err; continue; endif
	    load_qdata [wkey, qdata];
	    if anytrue fn then
		QUE_fname = fn;
		QUE_fplus = 0;
		update_ph4title wkey;
	    endif
	    QUE_changed = 0;

	    [pmsg, cmsg] = check_query wkey;
	    if anytrue [pmsg, cmsg] then
		Warning tok_cat [
		    'The current query cannot be matched because:',
		    select ['\n', '', anytrue pmsg],
		    pmsg,
		    select ['\n', '', anytrue cmsg],
		    cmsg,
		    '\n\nModification of the query is recommended.'
		];
	    endif
	    usnap '';

	    // 'get/setph4data' are external triggers to get/set ph4data.
	    // !!! We no longer need to use task_send to send qdata.
	    // !!! Use WindowCall with 'GetQdata'/'SetQdata' methods.

	elseif trig === 'setph4data' then
	    val = task_send [task_key v.(trig)];
	    if length val then WindowTrigger [wkey,[LoadData:[qdata,'']]]; endif

	elseif trig === 'getph4data' then
	    val = qdata_Get[];
	    task_send [task_key v.(trig), val];

	    // Write out the current query

	elseif v.(trig) === 'Save...' then

		// Last update of selected items
		// !!! should be done elsewhere

	    // _update_dcsel[];
	    // v.msize = max [1, min [v.msize, DF_count]];
	    if not leL [0, v.msize, DF_count] then
		v.msize = max [0, min [v.msize, DF_count]];
		WindowSetData [wkey, [msize: v.msize]];
	    endif
	    tval_set [wkey, [msize: v.msize]];
	    DS_matchsize = msize_3to1 [v.msize_nonzero, v.msize_sign, v.msize];
	    DS_title = v.que_title;

	    [pmsg, cmsg] = check_query wkey;
	    if anytrue [pmsg, cmsg] then
		if not NoYes tok_cat [
		    'The current query cannot be matched because:',
		    select ['\n', '', anytrue pmsg],
		    pmsg,
		    select ['\n', '', anytrue cmsg],
		    cmsg,
		    '\n\nModification of the query is recommended.',
		    '\nContinue saving?'
		] then
		    continue;
		endif
	    endif

	    // if check_matchsize [] then continue; endif

		// Spawn a new task (for safety) and prompt for the filename

	    targ = [master: 'parent', title: '! PH4:Save'];
	    if 'child'<>second task_fork targ then continue; endif
	    wfn = FilePrompt [
		title: 'Write Query File',
		mode: 'saveAs',
		name: token QUE_fname,
		// filter: '*.ph4',
		filterList: ['', 'Pharmacophores (*.ph4)\t*.ph4'],
		filterIndex: 2,
		allowWhitespace: 2,
		autoExtension: 'ph4'
	    ];
	    if isnull wfn then exit[]; endif
#if 0
	    QUE_changed = QUE_fplus = 0;
	    qdata = qdata_Get[];

		// If the filename seems valid, store the query in the file

	    if not (ftail wfn === '0' or isspace ftail wfn) then
		QUE_saved_data = qdata;
		fwrite_PH4 [wfn, QUE_saved_data, [header:1]];
		QUE_fname = wfn;
		exit[];
	    endif

		// Write the query in the CLI

	    Warning	'The contents of the PH4 query file\n'
			'will be printed in the SVL Commands\n'
			'window (CLI).';
	    write	'\n'
			'============================================\n'
			'Contents of the Pharmacophore Query File:\n'
			'============================================\n';
	    fwrite_PH4 [0, qdata, [header:1]];
	    write	'============================================\n';
	    exit[];
#else
		// Send the output field to the main event loop task
		// for processing.

	    WindowTrigger [wkey, [trig_Save: wfn]];
	    exit[];

	    // Process qdata from the 'Open...' subtask.

	elseif trig === 'trig_Save' then
	    wfn = v.(trig);

	    qdata = qdata_Get[];
	    if ftail wfn === '0' or isspace ftail wfn then
		    // Write the query in the CLI

		Warning	'The contents of the PH4 query file\n'
			'will be printed in the SVL Commands\n'
			'window (CLI).';
		write	'\n'
			'============================================\n'
			'Contents of the Pharmacophore Query File:\n'
			'============================================\n';
		wfn = 0;
	    endif

		// If the filename seems valid, store the query in the file.
		// (wfn=0 means CLI)

	    targ = [master: 'parent', title: '! PH4:Save'];
	    [tid, tcode] = task_wfork targ;
	    if tcode == 'child' then
		fwrite_PH4 [wfn, qdata, [header:1]];
		task_return[];		// tcode='' (exit[] --> tcode='kill')
	    elseif tcode <> '' then
		if wfn === 0 then write '\tERROR\n'; endif
	    elseif wfn === 0 then
		write	'============================================\n';
	    else
	    QUE_changed = QUE_fplus = 0;
		QUE_saved_data = qdata;
		QUE_fname = wfn;
	    endif
#endif

	    // Start/show the search panel

	elseif v.(trig) === 'Search...' then
	    // _update_dcsel[];
	    if not leL [0, v.msize, DF_count] then
		v.msize = max [0, min [v.msize, DF_count]];
		WindowSetData [wkey, [msize: v.msize]];
	    endif
	    tval_set [wkey, [msize: v.msize]];
	    DS_matchsize = msize_3to1 [v.msize_nonzero, v.msize_sign, v.msize];
	    DS_title = v.que_title;
	    start_search wkey;

	endif

    endloop

    WindowDestroy wkey;
    dvar_close tm_opt;
    exit[];
endfunction


// PH4 Editor:
// 1) Generate a cleanup task.  2) Call the main editor panel control.
// 3) Exit immediately.

local function ph4_QueryEditor [fn, opt, force]
    if MOE_BATCH then return; endif
    // if WindowShow [WIN_QUE_NAME, 1] then return; endif

    const TTITLE = 'Pharmacophore Editor';

	// Start a cleanup child task t2.  The parent task, t1, first
	// wait for the the grandchild, t3, to report (back to t1) that
	// the panel has started and then it return to the caller.
	// (see task_send [t1, wkey] in query_editor[])

    const targ1 = [master:'none', title:'! PH4:Cleanup'];
    local t1 = task_key -1;
    static eDONE = 0;
    if 'child' <> second task_fork targ1 then
	local [t3, d]	= task_receive 5;	// wait for grandchild's wkey
	task_reply add t3;

	    // On timeout, either complain or ignore (if eDONE=1)

	if isnull t3 then
	    if not eDONE then exit 'ERROR: init timeout'; endif

	    // Wait until grandchild starts.

	elseif d = dvar_keyopen d then
	    dvar_lock d;
	    dvar_unlock d;
	    dvar_close d;
	endif
	return;
    endif

    SystemCurrent 0;	// always use the public system

	// Start the GUI grandchild task t3.  The cleanup task t2 waits
	// until the granchild is done.

    const targ2 = [creator:'blockEOK', master:'parent', title:TTITLE];
    local [tid, tcode] = task_fork targ2;
    if 'child' <> tcode then
	eDONE = 1;
	// task t2: Cleanup (child)

	GClose [DD_gkey, GOBJ_QUE_key1, GOBJ_QUE_key2];
	DD_gkey = GOBJ_QUE_key1 = GOBJ_QUE_key2 = [];
	GDestroy cat [
#if SHOW_DL_SAMEAIDX
	    GOBJ_LIG_key2,
#endif
	    GOBJ_LIG_key
	]; // clean up
	oDestroy cat [CHAIN_QUE_key, CHAIN_LIG_key];
	task_kill opt.sigchld;
	// task_kill SEARCH_tid;

#if NO_WIN_QUIT_MSG
	exit[];
#endif
	if tcode == 'error' then			// just die
	elseif eqL [QUE_saved_data, qdata_Get[]] then	// don't ask
	elseif [DD_expr, DC_expr] === [[],[]] then	// don't ask
	elseif not YesNo WIN_QUIT_MSG then
	else
	    local wfn = FilePrompt [
		title: 'Write Query File',
		mode: 'saveAs',
		name: token QUE_fname,
		// filter: '*.ph4'
		filterList: ['', 'Pharmacophores (*.ph4)\t*.ph4'],
		filterIndex: 2,
		autoExtension: 'ph4'
	    ];
	    if length wfn then
		fwrite_PH4 [wfn, qdata_Get[], [header:1]];
	    endif
	endif
	exit[];

    else
	// task t3: GUI (granchild)
	// query_editor [fn, opt, t1];
	query_editor [fn, opt, t1];
    endif
    exit[];
endfunction

#if NEW_AFF
const AFF_HACK = 1;		// use orthographic for now

// !!!
// [rad, center, normal] = AffSphereHorizon [A, rad, center];

local function SystemViewState []
    static state_val, state_data;
    local stereo = Stereo[];
    local state_now = [stereo, ViewOrientation[]];
    if stereo <> 'parallel' then
	state_now[[3,4]] = [ViewLookAt[], ViewScale[]];
    endif
    if neL [state_data, state_data = state_now] then
	state_val = add state_val + 1;
    endif
    return state_val;
endfunction


local function ViewAffData []
#if AFF_HACK
    local yz = ViewOrientation [];
    local x = vcross yz;
    // return = prepend [yz, rot3d_vCross yz];
    local W2V = prepend [yz, x];
    local V2W = tr W2V;
    local A = [W2V: W2V, V2W: V2W];
    A.scale = ViewScale[];
    A.orgV = [0,0,0];
    A.orgW = ViewLookAt[];
    const SCALE = 300;		// ???
    A.eyeV = (ViewSetup[]).eye_location * A.scale / SCALE;
    A.eyeW = A.orgW + matmul [V2W, A.eyeV];

    return A;
#else
    // ?? return (ViewGet[]).affdata;
#endif
endfunction

local function ViewSetAffData A
#if AFF_HACK
    ViewOrientation dropfirst A.W2V;
    ViewLookAt dropfirst A.orgW;
    ViewScale A.scale;
#else
    // ?? ViewSet [affdata: affdata];
#endif
endfunction

local function AffW2V [A, pos]
#if AFF_HACK
    return matmul [A.W2V, pos - A.orgW] + A.orgV;
#else
    // ... return world in A to view (in mm?) ...
#endif
endfunction

local function AffV2W [A, pos]
#if AFF_HACK
    return matmul [A.V2W, pos - A.orgV] + A.orgW;
#else
    // ... return inverse AffW2V ...
#endif
endfunction
#endif

